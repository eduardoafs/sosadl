*
*Questions de sémantique

*Portée des noms : Une variable peut-elle avoir le même nom qu'un type ? etc.
Pour l'instant, oui : c'est une des raisons pour lesquelles il y a plusieurs environnements.

*Assert dans Behavior et ProtocolBehavior ?
	* Est-ce que name intervient dans le typage de ask et tell ? Quelle est sa sémantique ?
	* Faut-il typer l' « l'environnement » qui contient les contraintes ?
		* Par exemple « ask toto is (x=y) » ne permettra de conclure rien d'autre que le fait que x et y sont du même type. Cependant les autres instructions pourraient fournir suffisamment de contraintes pour déterminer ce type.
		* Par exemple dans « ask toto is (x=y) value z = x+1 » : on peut conclure que x et y sont des entiers. Néanmoins rien ne permettrait de s'assurer que les types correspondent bien au tell correspondant « value x = sequence{1} tell toto is x=y ». Cet exemple contient manifestement un problème de types qui pourrait être détecté par le typage de l' « l'environnement ».

*Environnement
	* Préciser exactement son fonctionnement.
	* Si l'environnement est global à tout le SoS, préciser comment se résolvent les conflits de nommage.


*Les bindings

	* les multiplicités :
		* Ont-elles un sens dans tous les cas d'unification possibles ?
		* Préciser exactement ce que les multiplicités veulent dire.

	* relations de sous-typage dans chaque cas possible ?

	* unification possible entre in et inout ?
	Out et inout ?

	* Quelles sont les unifications autorisées ? Si oui, préciser la sémantique.
		* gate-gate,
		* gate-système(s),
		* gate-médiateur(s): peut-être non
		* système(s)-médiateur(s),
		* système(s)-système(s) : a priori non
		* médiateur(s)-médiateur(s) : a priori non
*
*
*Expressions
	* Faut-il garder "div" (division entière) : a priori non, c'est un reste du temps où le langage comprenait d'autres types que Integer et Range.

*Type integer = type range integer{MIN_INT .. MAX_INT}
	* Que se passe-t-il si un type range a une de ses bornes en-dehors de l'intervalle MIN_INT,MAX_INT?
	* Quelle sémantique pour les opérations arithmétiques: modulo? saturée? erreur?
	* Quel intérêt de conserver le type integer (sans intervalle)? Le supprimer résoudrait les deux questions précédentes.



*Vérification des types range
	* Deux choses à vérifier
		* vmin <= vmax
		* relation de sous-typage sur les types range
	* Plusieurs situations possibles
		* Il y aura des situations triviales pour lesquelles on peut espérer que notre algorithme de typage soit capable de vérifier les types range.
		* Peut-on utiliser un solveur de contraintes pour résoudre des problèmes un peu plus complexes?
		* Lorsqu'il n'est pas possible de vérifier les types range lors de la phase de typage, on peut:
			* soit espérer que la phase d'analyse (model-checking) fasse les vérifications
			* soit générer des obligations de preuve auxquelles l'architecte doit répondre
		* En dernier recours, s'autorise-t-on à produire des tests à l'exécution? ou bien rejette-t-on l'architecture?


*
*Import
	* autorise-t-on ou interdit-on des cycles dans les imports?


