grammar org.archware.sosadl.SosADL with org.eclipse.xtext.common.Terminals

generate sosADL 'http://www-archware.irisa.fr/sosadl/SosADL'

SosADL: (imports+=Import)* content=(NewNamedLibrary | NewSoS);

Import: 'with' importName=Name;

NewNamedLibrary: 'library' libraryName=Name 'is' '{' decls=EntityBlock '}';

NewSoS: 'sos' sosName=Name 'is' '{'
  (decls=EntityBlock)
  '}';

EntityBlock: {EntityBlock}
	(datatypes+=DataTypeDecl)*
	(functions+=FunctionDecl)*
	(systems+=SystemDecl)*
	(mediators+=MediatorDecl)*
	(architectures+=ArchitectureDecl)*
;

SystemDecl: 'system' systemName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' 'is' '{'
	(datatypes+=DataTypeDecl)*
	(gates+=GateDecl)+
	behavior=BehaviorDecl
	'}' ('guarantee' '{' assertionDecl=AssertionDecl '}')?
	;

ArchitectureDecl: 'architecture' architectureName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' 'is' '{'
	(datatypes+=DataTypeDecl)*
	(gates+=GateDecl)+
	archBehavior=ArchBehaviorDecl
	'}'
	;

MediatorDecl: 'mediator' mediatorName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' 'is' '{'
	(datatypes+=DataTypeDecl)*
	(duties+=DutyDecl)+
	behavior=BehaviorDecl
	'}'
	;

GateDecl:
	'gate' gateName=Name 'is' '{'
	  (connections+=Connection)+
	'}' 'guarantee' '{' protocolDecl=ProtocolDecl '}'
;

DutyDecl:
	'duty' dutyName=Name 'is' '{'
	  (connections+=Connection)+
	'}'
	'require' '{' assertion=AssertionDecl '}'
	'assume' '{' assumedProtocol=ProtocolDecl '}'
;

Connection:
	(envConnection?='environment')? 'connection' name=Name 'is' mode=ModeType '{' valueType=DataType '}';

AssertionDecl:
	'assertion' assertionName=Name 'is' '{'
    (valuing+=Valuing+ 'within')?
    assertionExpr=Assertion '}'
;


ProtocolDecl:
    'protocol' protocolName=Name 'is' protocolBody=Protocol
;

Protocol:
	'{' PrefixedProtocol '}'
	| FinalProtocol
;

PrefixedProtocol returns Protocol:
	({PrefixedProtocol} (statements+=ProtocolStatement)+ finalProtocol=FinalProtocol?)
	| FinalProtocol
	;

FinalProtocol returns Protocol:
   {IfThenElse} 'if' cond=BooleanExpression 'then' '{' ifTrueProtocol=PrefixedProtocol '}' ('else' '{' ifFalseProtocol=PrefixedProtocol '}')?
	| {Choose} 'choose' '{' choiceBehavior+=PrefixedProtocol '}'  ('or'  '{' choiceProtocol+=PrefixedProtocol '}' )+  // au lieu de 'choose { b1 or ... or bn }' car 'or' apparait dans Expression et Behavior
	| {ForEach} 'foreach' name=Name 'in' setOfValues=Expression '{' foreachProtocol=ProtocolStatement '}'
	| {DoExpr} 'do' expr=Expression
	| {RepeatForever} 'forever' '{' repeatedProtocol=PrefixedProtocol '}' 
    | {Done} 'done'
	;

ProtocolStatement:
	Valuing
	| Assert
	| ProtocolAction
	| {AnyAction} 'anyaction'
	| {Repeat} 'repeat' '{' (repeatedProtocol+=ProtocolStatement)+ '}' 
;

ProtocolAction:
	'via' ComplexName
	(({SendProtocolAction.target=current} 'send' sendExpression=FinalExpression)
		| ('receive' (({ReceiveAnyProtocolAction.target=current} 'any')
			| {ReceiveProtocolAction.target=current} receivedValue=ComplexName
		)))
;

BehaviorDecl:
	'behavior' behaviorName=Name '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')' 'is' behaviorBody=Behavior
;

Behavior:
	'{' PrefixedBehavior '}'
	| FinalBehavior
;

PrefixedBehavior returns Behavior:
	({PrefixedBehavior} (statements+=BehaviorStatement)+ finalBehavior=FinalBehavior?)
	| FinalBehavior
	;

FinalBehavior returns Behavior:
	{Forever} 'forever' '{' repeatedBehavior=PrefixedBehavior '}'
	| {IfThenElse} 'if' cond=BooleanExpression 'then' '{' ifTrueBehavior=PrefixedBehavior '}' ('else' '{' ifFalseBehavior=PrefixedBehavior '}')?
	| {Choose} 'choose' '{' choiceBehavior+=PrefixedBehavior '}'  ('or'  '{' choiceBehavior+=PrefixedBehavior '}' )+  // au lieu de 'choose { b1 or ... or bn }' car 'or' apparait dans Expression et Behavior
	| {ForEach} 'foreach' name=Name 'in' setOfValues=Expression '{' foreachBehavior=BehaviorStatement '}'
	| {DoExpr} 'do' expr=Expression
	| {Done} 'done'
	| {RecursiveCall} 'behavior' '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')'
	;

BehaviorStatement:
	Valuing
	| Assert
	| Action
;

Assert:
	'assert' assertName=Name 'is' '{' assertExpression=AssertExpression '}'
;

AssertExpression:
	valueing=Valuing
	| constraint=BooleanExpression
;

Action:
	'via' ComplexName (({SendAction.target=current} 'send' sendExpression=FinalExpression)
		| ({ReceiveAction.target=current} 'receive' receivedValue=ComplexName))
;

ArchBehaviorDecl:
	'behavior' behaviorName=Name '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')'
	'is' 'compose' '{' constituentList=ConstituentAndList '}'
	'binding' '{' bindings=BindingExpression '}' 
;

ConstituentAndList:
	(constituent+=Constituent)+
;

Constituent:
	constituentName=Name 'is' constituentValue=Expression
;

Binding:
	{Relay} 'relay' gate=ComplexName 'to' connection=ComplexName
	| {Unify} 'unify' multLeft=Multiplicity '{' connLeft=ComplexName '}' 'to' multRight=Multiplicity '{' connRight=ComplexName '}'
	| {Quantify} quantifier=Quantifier '{' element+=Name 'in' constituent+=Name (',' element+=Name 'in' constituent+=Name)* 'suchthat' bindings=BindingExpression '}'
;

Quantifier:
	'forall' | 'exists'
;

Multiplicity:
	'one' | 'none' | 'lone' | 'any' | 'some' | 'all'
;

DataTypeDecl: 'datatype' datatypeName=Name ('is' datatype=DataType)? ('{' function+=FunctionDecl+ '}')?;

DataType:
	BaseType
	| ConstructedType
	| {TypeName} typeName=Name  // name of another type
;

FunctionDecl:
	'function' '(' dataName=Name ':' dataTypeName=Name ')' '::'
	functionName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' ':' returnType=DataType 'is' '{'
	    // TODO! syntax of valuing and statements
	    (valuing+=Valuing)*
		'return' returnExpression=Expression
	'}'
;

ParamType:
	name=Name ':' type=DataType
;

BaseType:
	{IntegerType} 'integer'
;

ConstructedType:
	{TupleType} 'tuple' '{' field+= LabelledType (',' field+=LabelledType)* '}'
	| {SequenceType} 'sequence' '{' typeOfSequence=DataType '}'
	| {RangeType} 'integer' '{' vmin=Expression '..' vmax=Expression '}'  // range of Integer
	| {ConnectionType} mode=ModeType '{' typeOfConnection=DataType '}'
	;
	
LabelledType:
	label=Label ':' type=DataType
;

enum ModeType:
	ModeTypeIn='in' | ModeTypeOut='out' | ModeTypeInout='inout';
	
Label:
	Name;

Ident:
	name=Name;

Name: ID ;

ComplexName:
	complexName+=Name ('::' complexName+=Name)*
;

Valuing:
	'value' valueName=Name ('is' valueType=DataType)? '=' expression=Expression;

Value returns Expression:
	BaseValue
	| ConstructedValue
	| {UnobservableValue} 'unobservable'
;

BaseValue returns Expression:
	IntegerValue
	| {Any} 'any'
;

// IntegerValue est un entier naturel >=0. Pour avoir un entier <0, utiliser une expression
IntegerValue:
	absInt=INT // INT == ('0'..'9')+ rend une valeur ecore::EInt;
;

ConstructedValue:
	{Tuple} 'tuple' '{' tupleElement+=TupleElement (',' tupleElement+=TupleElement)* '}'
	| {Sequence} 'sequence' '{' (paramExpr+=Expression (',' paramExpr+=Expression)*)? '}'
;

TupleElement:
	elementLabel=Name '=' elementValue=Expression
;

// BindingExpression is just an alias for Expression to help the poor human reader.
BindingExpression: Expression;

// BooleanExpression is just an alias for Expression to help the poor human reader.
BooleanExpression: Expression;

Expression:
	BinaryExpression0
;
	
BinaryExpression0 returns Expression:
	BinaryExpression1 ({BinaryExpression.left=current} op=BinaryOp0 right=BinaryExpression0)?
	;

BinaryExpression1 returns Expression:
	BinaryExpression2 ({BinaryExpression.left=current} op=BinaryOp1 right=BinaryExpression2)*
	;

BinaryExpression2 returns Expression:
	BinaryExpression3 ({BinaryExpression.left=current} op=BinaryOp2 right=BinaryExpression3)*
	;
	
BinaryExpression3 returns Expression:
	BinaryExpression4 ({BinaryExpression.left=current} op=BinaryOp3 right=BinaryExpression4)*
	;

BinaryExpression4 returns Expression:
	BinaryExpression5 ({BinaryExpression.left=current} op=BinaryOp4 right=BinaryExpression5)*
	;

BinaryExpression5 returns Expression:
	BinaryExpression6 ({BinaryExpression.left=current} op=BinaryOp5 right=BinaryExpression6)*
	;

BinaryExpression6 returns Expression:
	BinaryExpression7 ({BinaryExpression.left=current} op=BinaryOp6 right=BinaryExpression7)*
	;

BinaryExpression7 returns Expression:
	FinalExpression ({BinaryExpression.left=current} op=BinaryOp7 right=FinalExpression)*
	;

FinalExpression returns Expression:
	UnaryExpression
	| CallExpression
	| '(' Expression ')'
	| Binding
;

UnaryExpression:
	op=UnaryOp right=FinalExpression
	;

CallExpression returns Expression:
	( Ident
	 ({FunctionCall.target=current} '(' (params+=Expression (',' params+=Expression)*)? ')')?
	 | LitteralExpression
	 )
	 (    {Field.target=current} '::' field+=Name
	 	| {Select.target=current} '::' 'select' '{' var=Name 'suchthat' res=Expression '}'
	 	| {Map.target=current} '::' 'map' '{' var=Name 'to' res=Expression '}'
	 	| {MethodCall.target=current} '::' method+=Name '(' (params+=Expression (',' params+=Expression)*)? ')'
	 )*
;

LitteralExpression returns Expression:
	Value
;

BinaryOp0:	'implies' ; 

BinaryOp1:	'or' ; 

BinaryOp2:	'xor' ;

BinaryOp3:	'and' ;

BinaryOp4:	'=' | '<>' ;

BinaryOp5:  '<' | '<=' | '>' | '>=' ;

BinaryOp6:  '+' | '-' ;

BinaryOp7:  '*' | '/' | 'mod' | 'div' ;

UnaryOp:
	BooleanUnaryOp
	| ArithmeticUnaryOp
	;

BooleanUnaryOp: 'not';

ArithmeticUnaryOp:	'+' | '-';

// Assertions

Assertion:
	BinaryAssertion0
	| Action
;

BinaryAssertion0 returns Assertion:
	BinaryAssertion1 ({BinaryAssertion.left=current} op=BinaryOp0 right=BinaryAssertion0)?
	;

BinaryAssertion1 returns Assertion:
	BinaryAssertion2 ({BinaryAssertion.left=current} op=BinaryOp1 right=BinaryAssertion2)*
	;

BinaryAssertion2 returns Assertion:
	BinaryAssertion3 ({BinaryAssertion.left=current} op=BinaryOp2 right=BinaryAssertion3)*
	;
	
BinaryAssertion3 returns Assertion:
	BinaryAssertion4 ({BinaryAssertion.left=current} op=BinaryOp3 right=BinaryAssertion4)*
	;

BinaryAssertion4 returns Assertion:
	BinaryAssertion5 ({BinaryAssertion.left=current} op=BinaryOp4 right=BinaryAssertion5)*
	;

BinaryAssertion5 returns Assertion:
	BinaryAssertion6 ({BinaryAssertion.left=current} op=BinaryOp5 right=BinaryAssertion6)*
	;

BinaryAssertion6 returns Assertion:
	BinaryAssertion7 ({BinaryAssertion.left=current} op=BinaryOp6 right=BinaryAssertion7)*
	;

BinaryAssertion7 returns Assertion:
	FinalAssertion ({BinaryAssertion.left=current} op=BinaryOp7 right=FinalAssertion)*
	;

UnaryAssertion:
	op=UnaryOp right=FinalAssertion
	;

CallAssertion returns Assertion:
	( Ident
	 ({FunctionCall.target=current} '(' (params+=Expression (',' params+=Expression)*)? ')')?
	 | LitteralAssertion
	 )
	 (    {Field.target=current} '::' field+=Name
	 	| {Select.target=current} '::' 'select' '{' var=Name 'suchthat' res=Expression '}'
	 	| {Map.target=current} '::' 'map' '{' var=Name 'to' res=Expression '}'
	 	| {MethodCall.target=current} '::' method+=Name '(' (params+=Expression (',' params+=Expression)*)? ')'
	 )*
;

LitteralAssertion returns Assertion:
	Value
;

FinalAssertion returns Assertion:
	UnaryAssertion
	| CallAssertion
	| '(' Assertion ')'
	| {Always} 'always' '{' expr=Assertion '}'
	| {Anynext} 'anynext' '{' expr=Assertion '}'
;