grammar org.archware.sosadl.SosADL with org.eclipse.xtext.common.Terminals

generate sosADL 'http://www-archware.irisa.fr/sosadl/SosADL'

SosADL: (imports+=Import)* content=(NewNamedLibrary | NewSoS);

Import: 'with' importName=Name;

NewNamedLibrary returns Unit: {Library} 'library' libraryName=Name 'is' '{' decls=EntityBlock '}';

NewSoS returns Unit: {SoS} 'sos' sosName=Name 'is' '{'
  (decls=EntityBlock)
  '}';

EntityBlock: {EntityBlock}
	(datatypes+=DataTypeDecl)*
	(functions+=FunctionDecl)*
	(systems+=SystemDecl)*
	(mediators+=MediatorDecl)*
	(architectures+=ArchitectureDecl)*
;

SystemDecl: 'system' systemName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' 'is' '{'
	(datatypes+=DataTypeDecl)*
	(gates+=GateDecl)+
	behavior=BehaviorDecl
	'}' ('guarantee' '{' assertionDecl=AssertionDecl '}')?
	;

ArchitectureDecl: 'architecture' architectureName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' 'is' '{'
	(datatypes+=DataTypeDecl)*
	(gates+=GateDecl)+
	archBehavior=ArchBehaviorDecl
	'}' ('guarantee' '{' assertionDecl=AssertionDecl '}')?
	;

MediatorDecl: 'mediator' mediatorName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' 'is' '{'
	(datatypes+=DataTypeDecl)*
	(duties+=DutyDecl)+
	behavior=BehaviorDecl
	'}'
	;

GateDecl:
	'gate' gateName=Name 'is' '{'
	  (connections+=Connection)+
	'}' 'guarantee' '{' protocolDecl=ProtocolDecl '}'
;

DutyDecl:
	'duty' dutyName=Name 'is' '{'
	  (connections+=Connection)+
	'}'
	'require' '{' assertion=AssertionDecl '}'
	'assume' '{' assumedProtocol=ProtocolDecl '}'
;

Connection:
	(envConnection?='environment')? 'connection' name=Name 'is' mode=ModeType '{' valueType=DataType '}';

AssertionDecl:
	'property' assertionName=Name 'is' '{'
    (valuing+=Valuing+ 'within')?
    assertionExpr=Assertion '}'
;

ProtocolDecl:
    'protocol' protocolName=Name 'is' protocolBody=Protocol
;

/* previous version distinguishes PrefixedProtocol and FinalProtocol
Protocol:
	'{' PrefixedProtocol '}'
	| FinalProtocol
;

PrefixedProtocol returns Protocol:
	({PrefixedProtocol} (statements+=ProtocolStatement)+ finalProtocol=FinalProtocol?)
	| FinalProtocol
	;

FinalProtocol returns FinalProtocol:
    {IfThenElseProtocol} 'if' cond=BooleanExpression 'then' '{' ifTrueProtocol=PrefixedProtocol '}' ('else' '{' ifFalseProtocol=PrefixedProtocol '}')?
	| {ChooseProtocol} 'choose' '{' choiceProtocol+=PrefixedProtocol '}'  ('or'  '{' choiceProtocol+=PrefixedProtocol '}' )+  // au lieu de 'choose { b1 or ... or bn }' car 'or' apparait dans Expression et Behavior
	| {ForEachProtocol} 'foreach' name=Name 'in' setOfValues=Expression '{' foreachProtocol=ProtocolStatement '}'
	| {DoExpr} 'do' expr=Expression
	| {RepeatForeverProtocol} 'forever' '{' repeatedProtocol=PrefixedProtocol '}' 
    | {Done} 'done'
	;

ProtocolStatement:
	Valuing
	| Assert
	| ProtocolAction
	| ({AnyAction} 'anyaction')
	| ({Repeat} 'repeat' '{' (repeatedProtocol+=ProtocolStatement)+ '}') 
;
*/

Protocol:
	'{' (statements+=ProtocolStatement)+ '}'
;

ProtocolStatement:
	Valuing
	| Assert
	| ProtocolAction
	| {AnyAction} 'anyaction'
	| {RepeatProtocol} 'repeat' repeatedProtocol=Protocol
	| {IfThenElseProtocol} 'if' cond=BooleanExpression 'then' ifTrueProtocol=Protocol ('else' ifFalseProtocol=Protocol)?
	| {ChooseProtocol} 'choose' choiceProtocol+=Protocol  ('or' choiceProtocol+=Protocol)+  // au lieu de 'choose { b1 or ... or bn }' car 'or' apparait dans Expression et Behavior
	| {ForEachProtocol} 'foreach' name=Name 'in' setOfValues=Expression foreachProtocol=Protocol
	| {DoExpr} 'do' expr=Expression
	| {Done} 'done'
;

ProtocolAction:
	'via' complexName=ComplexName suite=ProtocolActionSuite
;

ProtocolActionSuite:
	({SendProtocolAction} 'send' sendExpression=FinalExpression)
	| ('receive' ({ReceiveAnyProtocolAction} 'any'
	   			 |{ReceiveProtocolAction} receivedValue=ComplexName))
;

BehaviorDecl:
	'behavior' behaviorName=Name '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')' 'is' behaviorBody=Behavior
;

/* previous version distinguishes PrefixedBehavior and FinalBehavior
Behavior:
	'{' PrefixedBehavior '}'
	| FinalBehavior
;

PrefixedBehavior returns Behavior:
	{PrefixedBehavior} (statements+=BehaviorStatement)+ finalBehavior=FinalBehavior?
	| FinalBehavior
	;

FinalBehavior returns FinalBehavior:
	{ForeverBehavior} 'forever' '{' repeatedBehavior=PrefixedBehavior '}'
	| {IfThenElseBehavior} 'if' cond=BooleanExpression 'then' '{' ifTrueBehavior=PrefixedBehavior '}' ('else' '{' ifFalseBehavior=PrefixedBehavior '}')?
	| {ChooseBehavior} 'choose' '{' choiceBehavior+=PrefixedBehavior '}'  ('or'  '{' choiceBehavior+=PrefixedBehavior '}' )+  // au lieu de 'choose { b1 or ... or bn }' car 'or' apparait dans Expression et Behavior
	| {ForEachBehavior} 'foreach' name=Name 'in' setOfValues=Expression '{' foreachBehavior=BehaviorStatement '}'
	| {DoExpr} 'do' expr=Expression
	| {Done} 'done'
	| {RecursiveCall} 'behavior' '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')'
	;

BehaviorStatement:
	Valuing
	| Assert
	| Action
;
*/

Behavior:
	'{' (statements+=BehaviorStatement)+ '}'
;

BehaviorStatement:
	Valuing
	| Assert
	| Action
	| {RepeatBehavior} 'repeat' repeatedBehavior=Behavior
	| {IfThenElseBehavior} 'if' cond=BooleanExpression 'then' ifTrueBehavior=Behavior ('else' ifFalseBehavior=Behavior)?
	| {ChooseBehavior} 'choose' choiceBehavior+=Behavior  ('or' choiceBehavior+=Behavior )+  // au lieu de 'choose { b1 or ... or bn }' car 'or' apparait dans Expression et Behavior
	| {ForEachBehavior} 'foreach' name=Name 'in' setOfValues=Expression foreachBehavior=Behavior
	| {DoExpr} 'do' expr=Expression
	| {Done} 'done'
	| {RecursiveCall} 'behavior' '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')'
;

Assert:
	{TellAssertion} 'assert' assertName=Name 'is' '{' assertExpression=AssertExpression '}'
	| {AskAssertion} 'ask' assertName=Name 'is' '{' assertExpression=AssertExpression '}'
;

AssertExpression:
	Valuing
	| BooleanExpression
	;

Action:
	'via' complexName=ComplexName suite=ActionSuite
;

ActionSuite:
	{SendAction} 'send' sendExpression=FinalExpression
	| {ReceiveAction} 'receive' receivedValue=ComplexName
;

ArchBehaviorDecl:
	'behavior' behaviorName=Name '(' (paramExpr+=Expression (',' paramExpr+=Expression)*)? ')'
	'is' 'compose' '{' constituentList=ConstituentList '}'
	'binding' '{' bindings=BindingExpression '}' 
;

ConstituentList:
	(constituent+=Constituent)+
;

Constituent:
	constituentName=Name 'is' constituentValue=Expression
;

Binding:
	{Relay} 'relay' gate=ComplexName 'to' connection=ComplexName
	| {Unify} 'unify' multLeft=Multiplicity '{' connLeft=ComplexName '}' 'to' multRight=Multiplicity '{' connRight=ComplexName '}'
	| {Quantify} quantifier=Quantifier '{' elementInConstituent+=ElementInConstituent (',' elementInConstituent+=ElementInConstituent)* 'suchthat' bindings=BindingExpression '}'
;

Quantifier:
	'forall' | 'exists'
;

ElementInConstituent:
	element=Name 'in' constituent=Name
;

Multiplicity:
	'one' | 'none' | 'lone' | 'any' | 'some' | 'all'
;

DataTypeDecl: 'datatype' datatypeName=Name ('is' datatype=DataType)? ('{' function+=FunctionDecl+ '}')?;

DataType:
	BaseType
	| ConstructedType
	| {TypeName} typeName=Name  // name of another type
;

FunctionDecl:
	'function' '(' dataName=Name ':' dataTypeName=Name ')' '::'
	functionName=Name '(' (params+=ParamType (',' params+=ParamType)*)? ')' ':' returnType=DataType 'is' '{'
	    (valuing+=Valuing)*
		'return' returnExpression=Expression
	'}'
;

ParamType:
	name=Name ':' type=DataType
;

BaseType:
	{IntegerType} 'integer'
;

ConstructedType:
	{TupleType} 'tuple' '{' field+=ParamType (',' field+=ParamType)* '}'
	| {SequenceType} 'sequence' '{' typeOfSequence=DataType '}'
	| {RangeType} 'integer' '{' vmin=Expression '..' vmax=Expression '}'  // range of Integer
	| {ConnectionType} mode=ModeType '{' typeOfConnection=DataType '}'
	;


enum ModeType:
	ModeTypeIn='in' | ModeTypeOut='out' | ModeTypeInout='inout';
	
Label:
	Name;

/*
Ident:
	name=Name;
*/

Name: ID ;

ComplexName:
	complexName+=Name ('::' complexName+=Name)*
;

Valuing:
	'value' valueName=Name ('is' valueType=DataType)? '=' expression=Expression;

Value returns Expression:
	BaseValue
	| ConstructedValue
	| {UnobservableValue} 'unobservable'
;

BaseValue returns Expression:
	IntegerValue
	| {Any} 'any'
;

// IntegerValue est un entier naturel >=0. Pour avoir un entier <0, utiliser une expression
IntegerValue:
	absInt=INT // INT == ('0'..'9')+ rend une valeur ecore::EInt;
;

ConstructedValue:
	{Tuple} 'tuple' '{' tupleElement+=TupleElement (',' tupleElement+=TupleElement)* '}'
	| {Sequence} 'sequence' '{' (paramExpr+=Expression (',' paramExpr+=Expression)*)? '}'
;

TupleElement:
	elementLabel=Name '=' elementValue=Expression
;

// BindingExpression is just an alias for Expression to help the poor human reader.
BindingExpression returns Expression: Expression;

// BooleanExpression is just an alias for Expression to help the poor human reader.
BooleanExpression returns Expression: Expression;

Expression:
	BinaryExpression0
;
	
BinaryExpression0 returns Expression:
	BinaryExpression1 ({BinaryExpression.left=current} op=BinaryOp0 right=BinaryExpression0)?
	;

BinaryExpression1 returns Expression:
	BinaryExpression2 ({BinaryExpression.left=current} op=BinaryOp1 right=BinaryExpression2)*
	;

BinaryExpression2 returns Expression:
	BinaryExpression3 ({BinaryExpression.left=current} op=BinaryOp2 right=BinaryExpression3)*
	;
	
BinaryExpression3 returns Expression:
	BinaryExpression4 ({BinaryExpression.left=current} op=BinaryOp3 right=BinaryExpression4)*
	;

BinaryExpression4 returns Expression:
	BinaryExpression5 ({BinaryExpression.left=current} op=BinaryOp4 right=BinaryExpression5)*
	;

BinaryExpression5 returns Expression:
	BinaryExpression6 ({BinaryExpression.left=current} op=BinaryOp5 right=BinaryExpression6)*
	;

BinaryExpression6 returns Expression:
	BinaryExpression7 ({BinaryExpression.left=current} op=BinaryOp6 right=BinaryExpression7)*
	;

BinaryExpression7 returns Expression:
	FinalExpression ({BinaryExpression.left=current} op=BinaryOp7 right=FinalExpression)*
	;

FinalExpression returns Expression:
	UnaryExpression
	| CallExpression
	| '(' Expression ')'
	| Binding
;

UnaryExpression:
	op=UnaryOp right=FinalExpression
	;

/*
 * CallExpression est réécrite:
 * - ne rend plus Expression
 * - la suite d'expressions derrière des :: fait appel à une nouvelle règle CallExpressionSuite
 */
CallExpression returns Expression:
	(
		{IdentExpression} ident=Name
		| {CallExpression} functionName=Name '(' (params+=Expression (',' params+=Expression)*)? ')'
	    | LitteralExpression
	)
	
	('::'
		(
			{Field.object=current} fieldName=Name
			| {Select.object=current} 'select' '{' selectName=Name 'suchthat' selectExpr=Expression '}'
			| {Map.object=current} 'map' '{' mapName=Name 'to' mapExpr=Expression '}'
			| {MethodCall.object=current} methodName=Name '(' (params+=Expression (',' params+=Expression)*)? ')'
		)
	)*

;

LitteralExpression returns Expression:
	Value
;

BinaryOp0:	'implies' ; 

BinaryOp1:	'or' ; 

BinaryOp2:	'xor' ;

BinaryOp3:	'and' ;

BinaryOp4:	'=' | '<>' ;

BinaryOp5:  '<' | '<=' | '>' | '>=' ;

BinaryOp6:  '+' | '-' ;

BinaryOp7:  '*' | '/' | 'mod' | 'div' ;

UnaryOp:
	BooleanUnaryOp
	| ArithmeticUnaryOp
	;

BooleanUnaryOp: 'not';

ArithmeticUnaryOp:	'+' | '-';

// Assertions

Assertion:
	BinaryAssertion0
	| Action
;

BinaryAssertion0 returns Assertion:
	BinaryAssertion1 ({BinaryAssertion.left=current} op=BinaryOp0 right=BinaryAssertion0)?
	;

BinaryAssertion1 returns Assertion:
	BinaryAssertion2 ({BinaryAssertion.left=current} op=BinaryOp1 right=BinaryAssertion2)*
	;

BinaryAssertion2 returns Assertion:
	BinaryAssertion3 ({BinaryAssertion.left=current} op=BinaryOp2 right=BinaryAssertion3)*
	;
	
BinaryAssertion3 returns Assertion:
	BinaryAssertion4 ({BinaryAssertion.left=current} op=BinaryOp3 right=BinaryAssertion4)*
	;

BinaryAssertion4 returns Assertion:
	BinaryAssertion5 ({BinaryAssertion.left=current} op=BinaryOp4 right=BinaryAssertion5)*
	;

BinaryAssertion5 returns Assertion:
	BinaryAssertion6 ({BinaryAssertion.left=current} op=BinaryOp5 right=BinaryAssertion6)*
	;

BinaryAssertion6 returns Assertion:
	BinaryAssertion7 ({BinaryAssertion.left=current} op=BinaryOp6 right=BinaryAssertion7)*
	;

BinaryAssertion7 returns Assertion:
	FinalAssertion ({BinaryAssertion.left=current} op=BinaryOp7 right=FinalAssertion)*
	;

UnaryAssertion:
	op=UnaryOp right=FinalAssertion
	;

/*
 * CallAssertion est supprimée car en fait, elle est identique à CallExpression.
 * En effet, LitteralAssertion est identique à LitteralExpression.
 * Autre conséquence : LitteralAssertion est supprimée. 
 */

FinalAssertion returns Assertion:
	UnaryAssertion
	| CallExpression
	| '(' Assertion ')'
	| {Always} 'always' '{' expr=Assertion '}'
	| {Anynext} 'anynext' '{' expr=Assertion '}'
;
/*
CallAssertion: //; returns Expression:
	 ( ident=Ident ('(' (params+=Expression (',' params+=Expression)*)? ')')? 
	  | litteral=LitteralAssertion
	 )
	 (fieldSuite+=CallAssertionSuite)*
;

CallAssertionSuite:
     {Field} '::' fieldName=Name
	 | {Select} '::' 'select' '{' selectName=Name 'suchthat' selectExpr=Expression '}'
	 | {Map} '::' 'map' '{' mapName=Name 'to' mapExpr=Expression '}'
	 | {MethodCall} '::' methodName=Name '(' (params+=Expression (',' params+=Expression)*)? ')'
;

LitteralAssertion returns Assertion:
	Value
;
*/