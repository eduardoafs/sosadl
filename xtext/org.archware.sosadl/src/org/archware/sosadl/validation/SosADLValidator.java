/*
 * generated by Xtext
 */
package org.archware.sosadl.validation;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.archware.sosadl.attributed.AttributeAdapter;
import org.archware.sosadl.sosADL.ArchitectureDecl;
import org.archware.sosadl.sosADL.AssertionDecl;
import org.archware.sosadl.sosADL.BehaviorDecl;
import org.archware.sosadl.sosADL.BinaryExpression;
import org.archware.sosadl.sosADL.DataType;
import org.archware.sosadl.sosADL.DataTypeDecl;
import org.archware.sosadl.sosADL.EntityBlock;
import org.archware.sosadl.sosADL.Expression;
import org.archware.sosadl.sosADL.FieldDecl;
import org.archware.sosadl.sosADL.FormalParameter;
import org.archware.sosadl.sosADL.FunctionDecl;
import org.archware.sosadl.sosADL.GateDecl;
import org.archware.sosadl.sosADL.Import;
import org.archware.sosadl.sosADL.IntegerValue;
import org.archware.sosadl.sosADL.Library;
import org.archware.sosadl.sosADL.MediatorDecl;
import org.archware.sosadl.sosADL.NamedType;
import org.archware.sosadl.sosADL.RangeType;
import org.archware.sosadl.sosADL.SequenceType;
import org.archware.sosadl.sosADL.SoS;
import org.archware.sosadl.sosADL.SosADL;
import org.archware.sosadl.sosADL.SosADLPackage;
import org.archware.sosadl.sosADL.SystemDecl;
import org.archware.sosadl.sosADL.TupleType;
import org.archware.sosadl.sosADL.UnaryExpression;
import org.archware.sosadl.sosADL.Unit;
import org.archware.sosadl.validation.typing.EnvContent;
import org.archware.sosadl.validation.typing.Environment;
import org.archware.sosadl.validation.typing.impl.ArchitectureEnvContent;
import org.archware.sosadl.validation.typing.impl.FunctionEnvContent;
import org.archware.sosadl.validation.typing.impl.MediatorEnvContent;
import org.archware.sosadl.validation.typing.impl.SystemEnvContent;
import org.archware.sosadl.validation.typing.impl.TypeEnvContent;
import org.archware.sosadl.validation.typing.impl.VariableEnvContent;
import org.archware.sosadl.validation.typing.interp.InterpInZ;
import org.archware.sosadl.validation.typing.proof.And;
import org.archware.sosadl.validation.typing.proof.Conj;
import org.archware.sosadl.validation.typing.proof.Constexpr_Add;
import org.archware.sosadl.validation.typing.proof.Constexpr_Div;
import org.archware.sosadl.validation.typing.proof.Constexpr_IntegerValue;
import org.archware.sosadl.validation.typing.proof.Constexpr_Mod;
import org.archware.sosadl.validation.typing.proof.Constexpr_Mul;
import org.archware.sosadl.validation.typing.proof.Constexpr_Opposite;
import org.archware.sosadl.validation.typing.proof.Constexpr_Same;
import org.archware.sosadl.validation.typing.proof.Constexpr_Sub;
import org.archware.sosadl.validation.typing.proof.Constexpr_expression;
import org.archware.sosadl.validation.typing.proof.Eluded;
import org.archware.sosadl.validation.typing.proof.Eq_refl;
import org.archware.sosadl.validation.typing.proof.Equality;
import org.archware.sosadl.validation.typing.proof.Ex;
import org.archware.sosadl.validation.typing.proof.Ex_intro;
import org.archware.sosadl.validation.typing.proof.Expression_le;
import org.archware.sosadl.validation.typing.proof.Forall;
import org.archware.sosadl.validation.typing.proof.Forall_cons;
import org.archware.sosadl.validation.typing.proof.Forall_nil;
import org.archware.sosadl.validation.typing.proof.In_Z;
import org.archware.sosadl.validation.typing.proof.Incrementally;
import org.archware.sosadl.validation.typing.proof.Incrementally_cons;
import org.archware.sosadl.validation.typing.proof.Incrementally_nil;
import org.archware.sosadl.validation.typing.proof.Mandatory;
import org.archware.sosadl.validation.typing.proof.Mutually;
import org.archware.sosadl.validation.typing.proof.Mutually_all;
import org.archware.sosadl.validation.typing.proof.Mutually_all_explicit;
import org.archware.sosadl.validation.typing.proof.ProofTerm;
import org.archware.sosadl.validation.typing.proof.Type_EntityBlock_whole;
import org.archware.sosadl.validation.typing.proof.Type_Library;
import org.archware.sosadl.validation.typing.proof.Type_NamedType;
import org.archware.sosadl.validation.typing.proof.Type_RangeType_trivial;
import org.archware.sosadl.validation.typing.proof.Type_SequenceType;
import org.archware.sosadl.validation.typing.proof.Type_SoS;
import org.archware.sosadl.validation.typing.proof.Type_SosADL;
import org.archware.sosadl.validation.typing.proof.Type_SystemDecl;
import org.archware.sosadl.validation.typing.proof.Type_SystemDecl_None;
import org.archware.sosadl.validation.typing.proof.Type_SystemDecl_datatype_Some;
import org.archware.sosadl.validation.typing.proof.Type_TupleType;
import org.archware.sosadl.validation.typing.proof.Type_architecture;
import org.archware.sosadl.validation.typing.proof.Type_behavior;
import org.archware.sosadl.validation.typing.proof.Type_datatype;
import org.archware.sosadl.validation.typing.proof.Type_datatypeDecl;
import org.archware.sosadl.validation.typing.proof.Type_entityBlock;
import org.archware.sosadl.validation.typing.proof.Type_function;
import org.archware.sosadl.validation.typing.proof.Type_mediator;
import org.archware.sosadl.validation.typing.proof.Type_sosADL;
import org.archware.sosadl.validation.typing.proof.Type_system;
import org.archware.sosadl.validation.typing.proof.Type_systemblock;
import org.archware.sosadl.validation.typing.proof.Type_unit;
import org.eclipse.emf.common.util.ECollections;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class SosADLValidator extends AbstractSosADLValidator {
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	public Type_sosADL type_sosADL(SosADL file) {
		// type_SosADL:
		if(file.getContent() != null) {
			return saveProof(file, createType_SosADL(file.getImports(), file.getContent(), type_unit(Environment.empty(), file.getContent())));
		} else {
			error("The file must contains a unit", file, null);
			return null;
		}
	}

	private Type_unit type_unit(Environment gamma, Unit content) {
		// type_SoS:
		if(content instanceof SoS && ((SoS)content).getName() != null && ((SoS)content).getDecls() != null) {
			return saveProof(content, createType_SoS(gamma, ((SoS)content).getName(), ((SoS)content).getDecls(), type_entityBlock(gamma, ((SoS)content).getDecls())));
		} else
		// type_Library:
		if(content instanceof Library && ((Library)content).getName() != null && ((Library)content).getDecls() != null) {
			return saveProof(content, createType_Library(gamma, ((Library)content).getName(), ((Library)content).getDecls(), type_entityBlock(gamma, ((Library)content).getDecls())));
		} else {
			error("The unit must contain a name and a block", content, null);
			return null;
		}
	}

	private Type_entityBlock type_entityBlock(Environment gamma, EntityBlock decls) {
		saveEnvironment(decls, gamma);
		return saveProof(decls, type_entityBlock(gamma, decls, decls.getDatatypes(), decls.getFunctions(), decls.getSystems(), decls.getMediators(), decls.getArchitectures()));
	}

	private Type_entityBlock type_entityBlock(Environment gamma, EntityBlock decls, EList<DataTypeDecl> datatypes, EList<FunctionDecl> functions,
			EList<SystemDecl> systems, EList<MediatorDecl> mediators, EList<ArchitectureDecl> architectures) {
		Pair<Incrementally<DataTypeDecl, Type_datatypeDecl>, Environment> p1 = type_datatypeDecls(gamma, datatypes);
		Pair<Incrementally<FunctionDecl, Type_function>, Environment> p2 = type_functions(p1.getB(), functions);
		Pair<Incrementally<SystemDecl, Type_system>, Environment> p3 = type_systems(p2.getB(), systems);
		Pair<Incrementally<MediatorDecl, Type_mediator>, Environment> p4 = type_mediators(p3.getB(), mediators);
		Pair<Incrementally<ArchitectureDecl, Type_architecture>, Environment> p5 = type_architectures(p4.getB(), architectures);
		return createType_EntityBlock_whole(gamma, datatypes, p1.getB(), functions, p2.getB(), systems, p3.getB(), mediators, p4.getB(), architectures, p5.getB(), p1.getA(), p2.getA(), p3.getA(), p4.getA(), p5.getA());
	}

	private Pair<Incrementally<ArchitectureDecl, Type_architecture>, Environment> type_architectures(Environment gamma, EList<ArchitectureDecl> architectures) {
		return proveIncrementally(gamma, architectures, this::type_architecture, ArchitectureDecl::getName, (d) -> new ArchitectureEnvContent(d));
	}

	private Pair<Incrementally<MediatorDecl, Type_mediator>, Environment> type_mediators(
			Environment gamma, EList<MediatorDecl> mediators) {
		return proveIncrementally(gamma, mediators, this::type_mediator, MediatorDecl::getName, (d) -> new MediatorEnvContent(d));
	}

	private Pair<Incrementally<SystemDecl, Type_system>, Environment> type_systems(Environment gamma, EList<SystemDecl> systems) {
		return proveIncrementally(gamma, systems, this::type_system, SystemDecl::getName, (d) -> new SystemEnvContent(d));
	}

	private Pair<Incrementally<FunctionDecl, Type_function>, Environment> type_functions(
			Environment gamma, EList<FunctionDecl> functions) {
		return proveIncrementally(gamma, functions, this::type_function, FunctionDecl::getName, (d) -> new FunctionEnvContent(d));
	}

	private Pair<Incrementally<DataTypeDecl, Type_datatypeDecl>, Environment> type_datatypeDecls(Environment gamma,
			EList<DataTypeDecl> datatypes) {
		return proveIncrementally(gamma, datatypes, this::type_datatypeDecl, DataTypeDecl::getName, (d) -> new TypeEnvContent(d));
	}

	private Type_datatypeDecl type_datatypeDecl(Environment gamma, DataTypeDecl dataTypeDecl) {
		saveEnvironment(dataTypeDecl, gamma);
		// TODO Auto-generated method stub
		return null;
	}

	private Type_function type_function(Environment gamma, FunctionDecl fun) {
		saveEnvironment(fun, gamma);
		// TODO Auto-generated method stub
		return null;
	}

	private Type_system type_system(Environment gamma, SystemDecl systemDecl) {
		saveEnvironment(systemDecl, gamma);
		// type_SystemDecl:
		if(systemDecl.getName() != null && systemDecl.getBehavior() != null) {
			Pair<Mutually<FormalParameter,Ex<DataType, And<Equality,Type_datatype>>>, Environment> p = proveMutually(gamma, systemDecl.getParameters(),
					this::type_formalParameter, "SosADL.SosADL.FormalParameter_name", FormalParameter::getName,
					"SosADL.TypeSystem.formalParameter_to_EVariable", SosADLValidator::formalParameterEnvContent);
			return saveProof(systemDecl, createType_SystemDecl(gamma, systemDecl.getName(), systemDecl.getParameters(), p.getB(), systemDecl.getDatatypes(), systemDecl.getGates(), systemDecl.getBehavior(), systemDecl.getAssertion(), p.getA(),
					type_systemblock(env_add_params(systemDecl.getParameters(), gamma), systemDecl, systemDecl.getDatatypes(), systemDecl.getGates(), systemDecl.getAssertion(), systemDecl.getBehavior())));
		} else {
			if(systemDecl.getBehavior() == null) {
				error("The system must have a behavior", systemDecl, null);
			} else if(systemDecl.getName() == null) {
				error("The system must have a name", systemDecl, null);
			} else {
				error("Type error", systemDecl, null);
			}
			return null;
		}
	}

	private Type_mediator type_mediator(Environment gamma, MediatorDecl mediator) {
		saveEnvironment(mediator, gamma);
		// TODO Auto-generated method stub
		return null;
	}

	private Type_architecture type_architecture(Environment gamma, ArchitectureDecl architecture) {
		saveEnvironment(architecture, gamma);
		// TODO Auto-generated method stub
		return null;
	}

	private <T> Ex<DataType, And<Equality,Type_datatype>> proveExistsAndEqType(Environment gamma, T t, Function<T, DataType> getter) {
		return createEx_intro(getter.apply(t), createConj(createReflexivity(), type_datatype(gamma, getter.apply(t))));
	}
	
	private Ex<DataType, And<Equality,Type_datatype>> type_formalParameter(Environment gamma, FormalParameter p, Environment gamma1) {
		return proveExistsAndEqType(gamma, p, FormalParameter::getType);
	}
	
	private static EnvContent formalParameterEnvContent(FormalParameter p) {
		DataType t = p.getType();
		if(t == null) {
			return null;
		} else {
			return new VariableEnvContent(p, t);
		}
	}

	private Type_datatype type_datatype(Environment gamma, DataType type) {
		saveEnvironment(type, gamma);
		// type_NamedType:
		if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) != null && gamma.get(((NamedType)type).getName()) instanceof TypeEnvContent && ((TypeEnvContent)gamma.get(((NamedType)type).getName())).getDataTypeDecl() != null) {
			return saveProof(type, createType_NamedType(gamma, ((NamedType)type).getName(), ((TypeEnvContent)gamma.get(((NamedType)type).getName())).getDataTypeDecl(), createReflexivity()));
		}
		// type_TupleType:
		else if(type instanceof TupleType && noDuplicate(((TupleType)type).getFields().stream().map(FieldDecl::getName))) {
			return saveProof(type, createType_TupleType(gamma, ((TupleType)type).getFields(), createReflexivity(),
					proveForall(((TupleType)type).getFields(), (f) -> proveExistsAndEqType(gamma, f, FieldDecl::getType))));
		}
		// type_SequenceType:
		else if(type instanceof SequenceType && ((SequenceType)type).getType() != null) {
			return saveProof(type, createType_SequenceType(gamma, ((SequenceType)type).getType(), type_datatype(gamma, ((SequenceType)type).getType())));
		}
		// type_RangeType_trivial
		else if(type instanceof RangeType && ((RangeType)type).getVmin() != null && ((RangeType)type).getVmax() != null && !containsSomeNull(constexpr_expression(((RangeType)type).getVmin())) && !containsSomeNull(constexpr_expression(((RangeType)type).getVmax())) && InterpInZ.le(((RangeType)type).getVmin(), ((RangeType)type).getVmax())) {
			saveMin(type, InterpInZ.eval(((RangeType)type).getVmin()));
			saveMax(type, InterpInZ.eval(((RangeType)type).getVmax()));
			return saveProof(type, createType_RangeType_trivial(gamma, ((RangeType)type).getVmin(), ((RangeType)type).getVmax(), constexpr_expression(((RangeType)type).getVmin()), constexpr_expression(((RangeType)type).getVmax()), createIn_Z(((RangeType)type).getVmin(), InterpInZ.eval(((RangeType)type).getVmin()), ((RangeType)type).getVmax(), InterpInZ.eval(((RangeType)type).getVmax()), createReflexivity(), createReflexivity(), createReflexivity())));
		} else {
			if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) != null && gamma.get(((NamedType)type).getName()) instanceof TypeEnvContent && ((TypeEnvContent)gamma.get(((NamedType)type).getName())).getDataTypeDecl() == null) {
				error("No type declaration named `" + gamma.get(((NamedType)type).getName()) + "'", type, null);
			} else if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) != null && !(gamma.get(((NamedType)type).getName()) instanceof TypeEnvContent)) {
				error("`" + ((NamedType)type).getName() + "' is not a type declaration", type, null);
			} else if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) == null) {
				error("`" + ((NamedType)type).getName() + "' is undefined in this context", type, null);
			} else if(type instanceof NamedType && ((NamedType)type).getName() == null) {
				error("The named type must have a name", type, null);
			} else if(type instanceof TupleType && !noDuplicate(((TupleType)type).getFields().stream().map(FieldDecl::getName))) {
				EList<FieldDecl> fields = ((TupleType)type).getFields();
				fields.stream().filter((f) -> fields.stream().map(FieldDecl::getName).filter((n) -> n.equals(f.getName())).count() >= 2).forEach((f) -> error("Multiple fields named `" + f.getName() + "' in the tuple type", f, null));
			} else if(type instanceof SequenceType && ((SequenceType)type).getType() == null) {
				error("The sequence type must declare a base type", type, null);
			} else if(type instanceof RangeType && ((RangeType)type).getVmin() != null && ((RangeType)type).getVmax() != null && !containsSomeNull(constexpr_expression(((RangeType)type).getVmin())) && !containsSomeNull(constexpr_expression(((RangeType)type).getVmax())) && InterpInZ.gt(((RangeType)type).getVmin(), ((RangeType)type).getVmax())) {
				error("The lower bound of the range is greater than the upper bound", type, null);
			} else if(type instanceof RangeType && ((RangeType)type).getVmin() != null && ((RangeType)type).getVmax() != null) {
				if(containsSomeNull(constexpr_expression(((RangeType)type).getVmin()))) {
					error("The lower bound of the range is not a constant integer", type, SosADLPackage.Literals.RANGE_TYPE__VMIN);
				}
				if(containsSomeNull(constexpr_expression(((RangeType)type).getVmax()))) {
					error("The upper bound of the range is not a constant integer", type, SosADLPackage.Literals.RANGE_TYPE__VMIN);
				}
			} else if(type instanceof RangeType) {
				error("The range must have a lower bound and an upper bound", type, null);
			} else {
				error("Type error", type, null);
			}
			return null;
		}
	}

	private Constexpr_expression constexpr_expression(Expression e) {
		// constexpr_IntegerValue:
		if(e instanceof IntegerValue) {
			return saveProof(e, createConstexpr_IntegerValue(BigInteger.valueOf(((IntegerValue) e).getAbsInt())));
		}
		// constexpr_Opposite:
		else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getOp().equals("-") && ((UnaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Opposite(((UnaryExpression)e).getRight(), constexpr_expression(((UnaryExpression)e).getRight())));
		}
		// constexpr_Same:
		else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getOp().equals("+") && ((UnaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Same(((UnaryExpression)e).getRight(), constexpr_expression(((UnaryExpression)e).getRight())));
		}
		// constexpr_Add:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("+") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Add(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Sub:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("-") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Sub(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Mul:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("*") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Mul(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Div:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("/") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Div(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Mod:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("mod") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Mod(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		} else {
			if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
				error("Invalid binary operator for constant-integer expressions", e, SosADLPackage.Literals.BINARY_EXPRESSION__OP);
			} else if(e instanceof BinaryExpression) {
				error("Missing operator or operand", e, null);
			} else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getRight() != null) {
				error("Invalid unary operator for constant-integer expressions", e, SosADLPackage.Literals.BINARY_EXPRESSION__OP);
			} else if(e instanceof UnaryExpression) {
				error("Missing operator or operand", e, null);
			} else {
				error("This expression is not a constant-integer expression", e, null);
			}
			return null;
		}
	}

	private Type_systemblock type_systemblock(Environment gamma, SystemDecl systemDecl, EList<DataTypeDecl> dataTypeDecls, EList<GateDecl> gateDecls, AssertionDecl assertionDecl, BehaviorDecl behaviorDecl) {
		// type_SystemDecl_datatype_Some
		if(systemDecl.getName() != null && !dataTypeDecls.isEmpty() && dataTypeDecls.get(0).getName() != null && dataTypeDecls.get(0).getDatatype() != null && behaviorDecl != null) {
			return saveProof(systemDecl, createType_SystemDecl_datatype_Some(gamma, systemDecl.getName(), dataTypeDecls.get(0).getName(), dataTypeDecls.get(0).getDatatype(), dataTypeDecls.get(0).getFunctions(), cdr(dataTypeDecls), gateDecls, behaviorDecl, assertionDecl,
					type_datatypeDecl(gamma, dataTypeDecls.get(0)),
					type_systemblock(gamma.put(dataTypeDecls.get(0).getName(), new TypeEnvContent(dataTypeDecls.get(0))), systemDecl, cdr(dataTypeDecls), gateDecls, assertionDecl, behaviorDecl)));
		}
		// type_SystemDecl_None:
		else if(systemDecl.getName() != null && dataTypeDecls.isEmpty() && gateDecls.isEmpty() && assertionDecl == null && behaviorDecl != null) {
			return createType_SystemDecl_None(gamma, systemDecl.getName(), behaviorDecl, type_behavior(gamma, behaviorDecl));
		} else {
			// TODO error("Type error", systemDecl, null);
			return null;
		}
	}

	private Type_behavior type_behavior(Environment gamma, BehaviorDecl behaviorDecl) {
		// TODO Auto-generated method stub
		return null;
	}

	private static <T extends EObject, P extends ProofTerm> Forall<T, P> proveForall(
			List<? extends T> l, Function<T, ? extends P> prover) {
		if(l.isEmpty()) {
			return createForall_nil();
		} else {
			return createForall_cons(l.get(0), prover.apply(l.get(0)), proveForall(cdr(l), prover));
		}
	}
	
	private static <T extends EObject, P extends ProofTerm> Pair<Incrementally<T,P>,Environment> proveIncrementally(Environment gamma, List<T> l,
			BiFunction<Environment, T, P> prover, Function<T, ? extends String> name, Function<T, ? extends EnvContent> content) {
		if(l.isEmpty()) {
			return new Pair<>(createIncrementally_nil(gamma), gamma);
		} else {
			Environment gammai = augment_env(gamma, name.apply(l.get(0)), content.apply(l.get(0)));
			Pair<Incrementally<T, P>, Environment> p = proveIncrementally(gammai, cdr(l), prover, name, content);
			Environment gamma1 = p.getB();
			return new Pair<>(createIncrementally_cons(gamma, l.get(0), name.apply(l.get(0)), content.apply(l.get(0)), gammai, cdr(l), gamma1,
					prover.apply(gamma, l.get(0)), createReflexivity(), createReflexivity(), createReflexivity(), p.getA()), gamma1);
		}
	}
	
	private <T extends EObject, P extends ProofTerm> Pair<Mutually<T,P>, Environment> proveMutually(Environment gamma, List<T> l,
			TriFunction<Environment, T, Environment, P> prover, Function<T, ? extends String> name, Function<T, ? extends EnvContent> content) {
		if(noDuplicate(l.stream().map(name))) {
			Environment gamma1 = fold_right((x, g) -> augment_env(g, name.apply(x), content.apply(x)), gamma, l);
			return new Pair<>(createMutually_all(gamma, l, gamma1, createReflexivity(), createReflexivity(), proveForall(l, (x) -> prover.apply(gamma,  x,  gamma1))), gamma1);
		} else {
			l.stream().filter((p) -> l.stream().map(name).filter((n) -> n.equals(name.apply(p))).count() >= 2)
			.forEach((f) -> error("Multiple definitions of `" + name.apply(f) + "'", f, null));
			return new Pair<>(null, gamma);
		}
	}

	private <T extends EObject, P extends ProofTerm> Pair<Mutually<T,P>, Environment> proveMutually(Environment gamma, List<T> l,
			TriFunction<Environment, T, Environment, P> prover, String n, Function<T, ? extends String> name,
			String c, Function<T, ? extends EnvContent> content) {
		if(noDuplicate(l.stream().map(name))) {
			Environment gamma1 = fold_right((x, g) -> augment_env(g, name.apply(x), content.apply(x)), gamma, l);
			return new Pair<>(createMutually_all_explicit(n, c, gamma, l, gamma1, createReflexivity(), createReflexivity(), proveForall(l, (x) -> prover.apply(gamma,  x,  gamma1))), gamma1);
		} else {
			l.stream().filter((p) -> l.stream().map(name).filter((x) -> x.equals(name.apply(p))).count() >= 2)
			.forEach((f) -> error("Multiple definitions of `" + name.apply(f) + "'", f, null));
			return new Pair<>(null, gamma);
		}
	}

	public static final String ENVIRONMENT = "Environment";
	public static final String PROOF = "Proof";
	public static final String MIN = "Min";
	public static final String MAX = "Max";
	
	public static void saveMin(EObject eObject, BigInteger i) {
		AttributeAdapter.adapterOf(eObject).putAttribute(MIN, i);
	}
	
	public static void saveMax(EObject eObject, BigInteger i) {
		AttributeAdapter.adapterOf(eObject).putAttribute(MAX, i);
	}
	
	public static void saveEnvironment(EObject eObject, Environment env) {
		AttributeAdapter.adapterOf(eObject).putAttribute(ENVIRONMENT, env);
	}
	
	public static <T> T saveProof(EObject eObject, T proof) {
		AttributeAdapter.adapterOf(eObject).putAttribute(PROOF, proof);
		return proof;
	}

	public static Object getProof(EObject eObject) {
		return AttributeAdapter.adapterOf(eObject).getAttribute(PROOF);
	}
	
	private static Environment augment_env(Environment gamma, String name, EnvContent content) {
		if(name == null) {
			return gamma;
		} else if(content == null) {
			return gamma;
		} else {
			return gamma.put(name, content);
		}
	}

	private static <T> EList<T> cdr(List<T> l) {
		Iterator<T> i = l.iterator();
		EList<T> ret;
		if(i.hasNext()) {
			i.next();
			ret = ECollections.toEList(i);
		} else {
			ret = ECollections.emptyEList();
		}
		return ECollections.unmodifiableEList(ret);
	}
	
	private static Environment env_add_params(List<FormalParameter> l, Environment gamma) {
		return fold_right((p,e) -> (p.getName() != null && p.getType() != null ? e.put(p.getName(), new VariableEnvContent(p, p.getType())) : e), gamma, l);
	}
	
	@SuppressWarnings("unused")
	private static <A,B> A fold_left(BiFunction<A,B,A> f, List<B> l, A i) {
		/*
		if(l.isEmpty()) {
			return i;
		} else {
			return fold_left(f, cdr(l), f.apply(i, l.get(0)));
		}
		*/
		A r = i;
		for(B x:l) {
			r = f.apply(r, x);
		}
		return r;
	}
	
	private static <A,B> A fold_right(BiFunction<B,A,A> f, A i, List<B> l) {
		/*
		if(l.isEmpty()) {
			return i;
		} else {
			return f.apply(l.get(0), fold_right(f, i, cdr(l)));
		}
		*/
		A r = i;
		for(int j = l.size();j > 0;) {
			--j;
			B x = l.get(j);
			r = f.apply(x, r);
		}
		return r;
	}
	
	private static <T> boolean noDuplicate(Stream<T> s) {
		List<T> list = s.collect(Collectors.toList());
		Set<T> set = new TreeSet<>(list);
		return list.size() == set.size();
	}

	private boolean containsSomeNull(Object o) {
		for(Field f : o.getClass().getDeclaredFields()) {
			if(!f.isAnnotationPresent(Eluded.class) && f.isAnnotationPresent(Mandatory.class) && ProofTerm.class.isAssignableFrom(f.getType())) {
				try {
					Method getter = o.getClass().getMethod("get" + StringExtensions.toFirstUpper(f.getName()));
					Object i = getter.invoke(o);
					if(i == null) {
						return true;
					} else if(containsSomeNull(i)) {
						return true;
					}
				} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
				}
			}
		}
		return false;
	}
	
	private static Type_sosADL createType_SosADL(EList<Import> i, Unit d, Type_unit p) {
		return new Type_SosADL(i, d, p);
	}
	
	private static Type_unit createType_SoS(Environment gamma, String n, EntityBlock e, Type_entityBlock p) {
		return new Type_SoS(gamma, n, e, p);
	}
	
	private static Type_unit createType_Library(Environment gamma, String n, EntityBlock e, Type_entityBlock p) {
		return new Type_Library(gamma, n, e, p);
	}
	
	private static Type_entityBlock createType_EntityBlock_whole(Environment gamma, List<DataTypeDecl> datatypes, Environment gamma1,
			List<FunctionDecl> funs, Environment gamma2, List<SystemDecl> systems, Environment gamma3,
			List<MediatorDecl> mediators, Environment gamma4, List<ArchitectureDecl> architectures, Environment gamma5,
			Incrementally<DataTypeDecl, Type_datatypeDecl> p1, Incrementally<FunctionDecl, Type_function> p2,
			Incrementally<SystemDecl, Type_system> p3, Incrementally<MediatorDecl, Type_mediator> p4,
			Incrementally<ArchitectureDecl, Type_architecture> p5) {
		return new Type_EntityBlock_whole(gamma, datatypes, gamma1, funs, gamma2, systems, gamma3, mediators, gamma4, architectures, gamma5, p1, p2, p3, p4, p5);
	}
	
	private static Type_system createType_SystemDecl(Environment gamma, String name, EList<FormalParameter> params, Environment gamma1, EList<DataTypeDecl> datatypes, EList<GateDecl> gates, BehaviorDecl bhv, AssertionDecl assrt, Mutually<FormalParameter, Ex<DataType, And<Equality, Type_datatype>>> p1, Type_systemblock p2) {
		return new Type_SystemDecl(gamma, name, params, gamma1, datatypes, gates, bhv, assrt, p1, p2);
	}

	private static Type_datatype createType_NamedType(Environment gamma, String n, DataTypeDecl t, Equality p) {
		return new Type_NamedType(gamma, n, t, p);
	}
	
	private static Type_datatype createType_TupleType(Environment gamma, EList<FieldDecl> fields, Equality p1, Forall<FieldDecl, Ex<DataType, And<Equality, Type_datatype>>> p2) {
		return new Type_TupleType(gamma, fields, p1, p2);
	}
	
	private static Type_datatype createType_SequenceType(Environment gamma, DataType t, Type_datatype p) {
		return new Type_SequenceType(gamma, t, p);
	}
	
	private static Type_datatype createType_RangeType_trivial(Environment gamma, Expression min, Expression max, Constexpr_expression p1, Constexpr_expression p2, Expression_le p3) {
		return new Type_RangeType_trivial(gamma, min, max, p1, p2, p3);
	}
	
	private static Type_systemblock createType_SystemDecl_None(Environment gamma, String name, BehaviorDecl bhv, Type_behavior p) {
		return new Type_SystemDecl_None(gamma, name, bhv, p);
	}
	
	private static Type_systemblock createType_SystemDecl_datatype_Some(Environment gamma, String name, String d_name, DataType d_def, EList<FunctionDecl> d_funs, EList<DataTypeDecl> l, EList<GateDecl> gates, BehaviorDecl bhv, AssertionDecl assrt, Type_datatypeDecl p1, Type_systemblock p2) {
		return new Type_SystemDecl_datatype_Some(gamma, name, d_name, d_def, d_funs, l, gates, bhv, assrt, p1, p2);
	}
	
	private static Expression_le createIn_Z(Expression l, BigInteger zl, Expression r, BigInteger zr, Equality p1, Equality p2, Equality p3) {
		return new In_Z(l, zl, r, zr, p1, p2, p3);
	}
	
	private static Constexpr_expression createConstexpr_IntegerValue(BigInteger v) {
		return new Constexpr_IntegerValue(v);
	}
	
	private static Constexpr_expression createConstexpr_Opposite(Expression e, Constexpr_expression p) {
		return new Constexpr_Opposite(e, p);
	}
	
	private static Constexpr_expression createConstexpr_Same(Expression e, Constexpr_expression p) {
		return new Constexpr_Same(e, p);
	}
	
	private static Constexpr_expression createConstexpr_Add(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Add(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Sub(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Sub(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Mul(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Mul(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Div(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Div(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Mod(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Mod(l, r, p1, p2);
	}
	
	private static <T,P> Incrementally<T,P> createIncrementally_nil(Environment gamma) {
		return new Incrementally_nil<>(gamma);
	}
	
	private static <T,P> Incrementally<T,P> createIncrementally_cons(Environment gamma, T x, String n, EnvContent c, Environment gammai, List<T> l, Environment gamma1, P p1, Equality p2, Equality p3, Equality p4, Incrementally<T,P> p5) {
		return new Incrementally_cons<T, P>(gamma, x, n, c, gammai, l, gamma1, p1, p2, p3, p4, p5);
	}
	
	private static <T,P> Mutually<T,P> createMutually_all(Environment gamma, List<T> l, Environment gamma1, Equality p1, Equality p2, Forall<T,P> p3) {
		return new Mutually_all<>(gamma, l, gamma1, p1, p2, p3);
	}

	private static <T,P> Mutually<T,P> createMutually_all_explicit(String name, String content, Environment gamma, List<T> l, Environment gamma1, Equality p1, Equality p2, Forall<T,P> p3) {
		return new Mutually_all_explicit<>(name, content, gamma, l, gamma1, p1, p2, p3);
	}
	
	private static <A,B> And<A,B> createConj(A a, B b) {
		return new Conj<>(a, b);
	}
	
	private static <T, P> Ex<T, P> createEx_intro(T t, P p) {
		return new Ex_intro<>(t, p);
	}
	
	private static <T, P> Forall<T,P> createForall_nil() {
		return new Forall_nil<>();
	}

	private static <T, P> Forall<T,P> createForall_cons(T t, P p1, Forall<T,P> p2) {
		return new Forall_cons<>(t, p1, p2);
	}

	private static Equality createReflexivity() {
		return new Eq_refl();
	}
}
