/*
 * generated by Xtext
 */
package org.archware.sosadl.validation;

import org.eclipse.emf.common.util.ECollections;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import java.util.Iterator;

import org.archware.sosadl.attributed.AttributeAdapter;
import org.archware.sosadl.sosADL.ArchitectureDecl;
import org.archware.sosadl.sosADL.DataTypeDecl;
import org.archware.sosadl.sosADL.EntityBlock;
import org.archware.sosadl.sosADL.FunctionDecl;
import org.archware.sosadl.sosADL.Library;
import org.archware.sosadl.sosADL.MediatorDecl;
import org.archware.sosadl.sosADL.SoS;
import org.archware.sosadl.sosADL.SosADL;
import org.archware.sosadl.sosADL.SystemDecl;
import org.archware.sosadl.sosADL.Unit;
import org.archware.sosadl.validation.typing.Environment;
import org.archware.sosadl.validation.typing.impl.TypeEnvContent;
import org.archware.sosadl.validation.typing.proof.Type_EntityBlock_datatype_None;
import org.archware.sosadl.validation.typing.proof.Type_EntityBlock_datatype_Some;
import org.archware.sosadl.validation.typing.proof.Type_Library;
import org.archware.sosadl.validation.typing.proof.Type_SoS;
import org.archware.sosadl.validation.typing.proof.Type_SosADL;
import org.archware.sosadl.validation.typing.proof.Type_datatypeDecl;
import org.archware.sosadl.validation.typing.proof.Type_entityBlock;
import org.archware.sosadl.validation.typing.proof.Type_sosADL;
import org.archware.sosadl.validation.typing.proof.Type_unit;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class SosADLValidator extends AbstractSosADLValidator {

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	public Type_sosADL type_sosADL(SosADL file) {
		// type_SosADL:
		if(file.getContent() != null) {
			return saveProof(file, new Type_SosADL(file.getImports(), file.getContent(), type_unit(file.getContent())));
		} else {
			error("No unit found", file, null);
			return null;
		}
	}

	private Type_unit type_unit(Unit content) {
		// type_SoS:
		if(content instanceof SoS && ((SoS)content).getName() != null && ((SoS)content).getDecls() != null) {
			return saveProof(content, new Type_SoS(((SoS)content).getName(), ((SoS)content).getDecls(), type_entityBlock(Environment.empty(), ((SoS)content).getDecls())));
		} else
		// type_Library:
		if(content instanceof Library && ((Library)content).getName() != null && ((Library)content).getDecls() != null) {
			return saveProof(content, new Type_Library(((Library)content).getName(), ((Library)content).getDecls(), type_entityBlock(Environment.empty(), ((SoS)content).getDecls())));
		} else {
			error("The unit must contain a name and a block", content, null);
			return null;
		}
	}

	private Type_entityBlock type_entityBlock(Environment gamma, EntityBlock decls) {
		saveEnvironment(decls, gamma);
		return saveProof(decls, type_entityBlock(gamma, decls.getDatatypes(), decls.getFunctions(), decls.getSystems(), decls.getMediators(), decls.getArchitectures()));
	}

	private Type_entityBlock type_entityBlock(Environment gamma, EList<DataTypeDecl> datatypes, EList<FunctionDecl> functions,
			EList<SystemDecl> systems, EList<MediatorDecl> mediators, EList<ArchitectureDecl> architectures) {
		// type_EntityBlock_datatype_Some:
		if(datatypes.size() >= 1 && datatypes.get(0).getName() != null && datatypes.get(0).getDatatype() != null) {
			return new Type_EntityBlock_datatype_Some(gamma, datatypes.get(0).getName(), datatypes.get(0).getDatatype(),
					datatypes.get(0).getFunctions(), cdr(datatypes), functions, systems, mediators, architectures,
					type_datatypeDecl(gamma, datatypes.get(0)),
					type_entityBlock(gamma.put(datatypes.get(0).getName(), new TypeEnvContent(datatypes.get(0))), cdr(datatypes), functions, systems, mediators, architectures));
		} else
		// type_EntityBlock_datatype_None:
			if(datatypes.size() >= 1 && datatypes.get(0).getName() != null && datatypes.get(0).getDatatype() == null) {
				return new Type_EntityBlock_datatype_None(gamma, datatypes.get(0).getName(),
						datatypes.get(0).getFunctions(), cdr(datatypes), functions, systems, mediators, architectures,
						type_datatypeDecl(gamma, datatypes.get(0)),
						type_entityBlock(gamma.put(datatypes.get(0).getName(), new TypeEnvContent(datatypes.get(0))), cdr(datatypes), functions, systems, mediators, architectures));
		} else {
			// TODO
			return null;
		}
	}
	
	private Type_datatypeDecl type_datatypeDecl(Environment gamma, DataTypeDecl dataTypeDecl) {
		// TODO Auto-generated method stub
		return null;
	}

	public static final String ENVIRONMENT = "Environment";
	public static final String PROOF = "Proof";
	
	private static void saveEnvironment(EObject eObject, Environment env) {
		AttributeAdapter.adapterOf(eObject).putAttribute(ENVIRONMENT, env);
	}
	
	private static <T> T saveProof(EObject eObject, T proof) {
		AttributeAdapter.adapterOf(eObject).putAttribute(PROOF, proof);
		return proof;
	}

	private static <T> EList<T> cdr(EList<T> l) {
		Iterator<T> i = l.iterator();
		EList<T> ret;
		if(i.hasNext()) {
			i.next();
			ret = ECollections.toEList(i);
		} else {
			ret = ECollections.emptyEList();
		}
		return ECollections.unmodifiableEList(ret);
	}
}
