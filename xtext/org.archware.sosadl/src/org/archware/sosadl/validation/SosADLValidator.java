/*
 * generated by Xtext
 */
package org.archware.sosadl.validation;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.archware.sosadl.attributed.AttributeAdapter;
import org.archware.sosadl.sosADL.ArchitectureDecl;
import org.archware.sosadl.sosADL.AssertionDecl;
import org.archware.sosadl.sosADL.BehaviorDecl;
import org.archware.sosadl.sosADL.BinaryExpression;
import org.archware.sosadl.sosADL.BooleanType;
import org.archware.sosadl.sosADL.DataType;
import org.archware.sosadl.sosADL.DataTypeDecl;
import org.archware.sosadl.sosADL.EntityBlock;
import org.archware.sosadl.sosADL.Expression;
import org.archware.sosadl.sosADL.FieldDecl;
import org.archware.sosadl.sosADL.FormalParameter;
import org.archware.sosadl.sosADL.FunctionDecl;
import org.archware.sosadl.sosADL.GateDecl;
import org.archware.sosadl.sosADL.Import;
import org.archware.sosadl.sosADL.IntegerValue;
import org.archware.sosadl.sosADL.Library;
import org.archware.sosadl.sosADL.MediatorDecl;
import org.archware.sosadl.sosADL.NamedType;
import org.archware.sosadl.sosADL.RangeType;
import org.archware.sosadl.sosADL.SequenceType;
import org.archware.sosadl.sosADL.SoS;
import org.archware.sosadl.sosADL.SosADL;
import org.archware.sosadl.sosADL.SosADLFactory;
import org.archware.sosadl.sosADL.SosADLPackage;
import org.archware.sosadl.sosADL.SystemDecl;
import org.archware.sosadl.sosADL.TupleType;
import org.archware.sosadl.sosADL.UnaryExpression;
import org.archware.sosadl.sosADL.Unit;
import org.archware.sosadl.sosADL.Valuing;
import org.archware.sosadl.validation.typing.EnvContent;
import org.archware.sosadl.validation.typing.Environment;
import org.archware.sosadl.validation.typing.impl.ArchitectureEnvContent;
import org.archware.sosadl.validation.typing.impl.MediatorEnvContent;
import org.archware.sosadl.validation.typing.impl.SystemEnvContent;
import org.archware.sosadl.validation.typing.impl.TypeEnvContent;
import org.archware.sosadl.validation.typing.impl.VariableEnvContent;
import org.archware.sosadl.validation.typing.interp.InterpInZ;
import org.archware.sosadl.validation.typing.proof.And;
import org.archware.sosadl.validation.typing.proof.Conj;
import org.archware.sosadl.validation.typing.proof.Constexpr_Add;
import org.archware.sosadl.validation.typing.proof.Constexpr_Div;
import org.archware.sosadl.validation.typing.proof.Constexpr_IntegerValue;
import org.archware.sosadl.validation.typing.proof.Constexpr_Mod;
import org.archware.sosadl.validation.typing.proof.Constexpr_Mul;
import org.archware.sosadl.validation.typing.proof.Constexpr_Opposite;
import org.archware.sosadl.validation.typing.proof.Constexpr_Same;
import org.archware.sosadl.validation.typing.proof.Constexpr_Sub;
import org.archware.sosadl.validation.typing.proof.Constexpr_expression;
import org.archware.sosadl.validation.typing.proof.Eluded;
import org.archware.sosadl.validation.typing.proof.Eq_refl;
import org.archware.sosadl.validation.typing.proof.Equality;
import org.archware.sosadl.validation.typing.proof.Ex;
import org.archware.sosadl.validation.typing.proof.Ex_intro;
import org.archware.sosadl.validation.typing.proof.Expression_le;
import org.archware.sosadl.validation.typing.proof.Forall;
import org.archware.sosadl.validation.typing.proof.Forall_cons;
import org.archware.sosadl.validation.typing.proof.Forall_nil;
import org.archware.sosadl.validation.typing.proof.In_Z;
import org.archware.sosadl.validation.typing.proof.Incrementally;
import org.archware.sosadl.validation.typing.proof.Incrementally_cons;
import org.archware.sosadl.validation.typing.proof.Incrementally_nil;
import org.archware.sosadl.validation.typing.proof.Mandatory;
import org.archware.sosadl.validation.typing.proof.Mutually;
import org.archware.sosadl.validation.typing.proof.Mutually_all;
import org.archware.sosadl.validation.typing.proof.Mutually_all_explicit;
import org.archware.sosadl.validation.typing.proof.Optionally;
import org.archware.sosadl.validation.typing.proof.Optionally_None;
import org.archware.sosadl.validation.typing.proof.Optionally_Some;
import org.archware.sosadl.validation.typing.proof.ProofTerm;
import org.archware.sosadl.validation.typing.proof.Range_modulo_max;
import org.archware.sosadl.validation.typing.proof.Range_modulo_max_neg;
import org.archware.sosadl.validation.typing.proof.Range_modulo_max_pos;
import org.archware.sosadl.validation.typing.proof.Range_modulo_max_zero;
import org.archware.sosadl.validation.typing.proof.Range_modulo_min;
import org.archware.sosadl.validation.typing.proof.Range_modulo_min_neg;
import org.archware.sosadl.validation.typing.proof.Range_modulo_min_pos;
import org.archware.sosadl.validation.typing.proof.Range_modulo_min_zero;
import org.archware.sosadl.validation.typing.proof.Simple_increment;
import org.archware.sosadl.validation.typing.proof.Simple_increment_step;
import org.archware.sosadl.validation.typing.proof.Subtype;
import org.archware.sosadl.validation.typing.proof.Subtype_refl;
import org.archware.sosadl.validation.typing.proof.Subtype_unfold_left;
import org.archware.sosadl.validation.typing.proof.Type_BooleanType;
import org.archware.sosadl.validation.typing.proof.Type_DataTypeDecl_def;
import org.archware.sosadl.validation.typing.proof.Type_EntityBlock_whole;
import org.archware.sosadl.validation.typing.proof.Type_FunctionDecl_Method;
import org.archware.sosadl.validation.typing.proof.Type_Library;
import org.archware.sosadl.validation.typing.proof.Type_NamedType;
import org.archware.sosadl.validation.typing.proof.Type_RangeType_trivial;
import org.archware.sosadl.validation.typing.proof.Type_SequenceType;
import org.archware.sosadl.validation.typing.proof.Type_SoS;
import org.archware.sosadl.validation.typing.proof.Type_SosADL;
import org.archware.sosadl.validation.typing.proof.Type_SystemDecl;
import org.archware.sosadl.validation.typing.proof.Type_TupleType;
import org.archware.sosadl.validation.typing.proof.Type_architecture;
import org.archware.sosadl.validation.typing.proof.Type_assertion;
import org.archware.sosadl.validation.typing.proof.Type_behavior;
import org.archware.sosadl.validation.typing.proof.Type_datatype;
import org.archware.sosadl.validation.typing.proof.Type_datatypeDecl;
import org.archware.sosadl.validation.typing.proof.Type_entityBlock;
import org.archware.sosadl.validation.typing.proof.Type_expression;
import org.archware.sosadl.validation.typing.proof.Type_expression_node;
import org.archware.sosadl.validation.typing.proof.Type_expression_Add;
import org.archware.sosadl.validation.typing.proof.Type_expression_And;
import org.archware.sosadl.validation.typing.proof.Type_expression_Diff;
import org.archware.sosadl.validation.typing.proof.Type_expression_Div_neg;
import org.archware.sosadl.validation.typing.proof.Type_expression_Div_pos;
import org.archware.sosadl.validation.typing.proof.Type_expression_Equal;
import org.archware.sosadl.validation.typing.proof.Type_expression_Ge;
import org.archware.sosadl.validation.typing.proof.Type_expression_Gt;
import org.archware.sosadl.validation.typing.proof.Type_expression_Implies;
import org.archware.sosadl.validation.typing.proof.Type_expression_IntegerValue;
import org.archware.sosadl.validation.typing.proof.Type_expression_Le;
import org.archware.sosadl.validation.typing.proof.Type_expression_Lt;
import org.archware.sosadl.validation.typing.proof.Type_expression_Mod;
import org.archware.sosadl.validation.typing.proof.Type_expression_Mul;
import org.archware.sosadl.validation.typing.proof.Type_expression_Not;
import org.archware.sosadl.validation.typing.proof.Type_expression_Opposite;
import org.archware.sosadl.validation.typing.proof.Type_expression_Or;
import org.archware.sosadl.validation.typing.proof.Type_expression_Same;
import org.archware.sosadl.validation.typing.proof.Type_expression_Sub;
import org.archware.sosadl.validation.typing.proof.Type_expression_Xor;
import org.archware.sosadl.validation.typing.proof.Type_expression_and_type;
import org.archware.sosadl.validation.typing.proof.Type_function;
import org.archware.sosadl.validation.typing.proof.Type_gate;
import org.archware.sosadl.validation.typing.proof.Type_mediator;
import org.archware.sosadl.validation.typing.proof.Type_sosADL;
import org.archware.sosadl.validation.typing.proof.Type_system;
import org.archware.sosadl.validation.typing.proof.Type_unit;
import org.archware.sosadl.validation.typing.proof.Type_valuing;
import org.eclipse.emf.common.util.ECollections;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class SosADLValidator extends AbstractSosADLValidator {
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	public void typecheck(SosADL file) {
		try {
			type_sosADL(file);
		} catch(Throwable t) {
			t.printStackTrace();
			error("Bug in the type checker", file, null);
			throw t;
		}
	}
	
	private Type_sosADL type_sosADL(SosADL file) {
		// type_SosADL:
		if(file.getContent() != null) {
			return saveProof(file, createType_SosADL(file.getImports(), file.getContent(), type_unit(Environment.empty(), file.getContent())));
		} else {
			error("The file must contains a unit", file, null);
			return null;
		}
	}

	private Type_unit type_unit(Environment gamma, Unit content) {
		// type_SoS:
		if(content instanceof SoS && ((SoS)content).getName() != null && ((SoS)content).getDecls() != null) {
			return saveProof(content, createType_SoS(gamma, ((SoS)content).getName(), ((SoS)content).getDecls(), type_entityBlock(gamma, ((SoS)content).getDecls())));
		} else
		// type_Library:
		if(content instanceof Library && ((Library)content).getName() != null && ((Library)content).getDecls() != null) {
			return saveProof(content, createType_Library(gamma, ((Library)content).getName(), ((Library)content).getDecls(), type_entityBlock(gamma, ((Library)content).getDecls())));
		} else {
			error("The unit must contain a name and a block", content, null);
			return null;
		}
	}

	private Type_entityBlock type_entityBlock(Environment gamma, EntityBlock decls) {
		saveEnvironment(decls, gamma);
		return saveProof(decls, type_entityBlock(gamma, decls, decls.getDatatypes(), decls.getFunctions(), decls.getSystems(), decls.getMediators(), decls.getArchitectures()));
	}

	private Type_entityBlock type_entityBlock(Environment gamma, EntityBlock decls, EList<DataTypeDecl> datatypes, EList<FunctionDecl> functions,
			EList<SystemDecl> systems, EList<MediatorDecl> mediators, EList<ArchitectureDecl> architectures) {
		Pair<Incrementally<DataTypeDecl,Type_datatypeDecl>,Environment> p1 = type_datatypeDecls(gamma, datatypes);
		Pair<Incrementally<FunctionDecl,Type_function>,Environment> p2 = type_functions(p1.getB(), functions);
		Pair<Incrementally<SystemDecl,Simple_increment<SystemDecl,Type_system>>,Environment> p3 = type_systems(p2.getB(), systems);
		Pair<Incrementally<MediatorDecl,Simple_increment<MediatorDecl,Type_mediator>>,Environment> p4 = type_mediators(p3.getB(), mediators);
		Pair<Incrementally<ArchitectureDecl, Simple_increment<ArchitectureDecl, Type_architecture>>, Environment> p5 = type_architectures(p4.getB(), architectures);
		return createType_EntityBlock_whole(gamma, datatypes, p1.getB(), functions, p2.getB(), systems, p3.getB(), mediators, p4.getB(), architectures, p5.getB(), p1.getA(), p2.getA(), p3.getA(), p4.getA(), p5.getA());
	}

	private Pair<Incrementally<ArchitectureDecl, Simple_increment<ArchitectureDecl, Type_architecture>>, Environment> type_architectures(Environment gamma, EList<ArchitectureDecl> architectures) {
		return proveIncrementally(gamma, architectures, (g,x) -> proveSimpleIncrement(g, x, this::type_architecture, "SosADL.SosADL.ArchitectureDecl_name", ArchitectureDecl::getName, "(fun x => Some (EArchitecture x))", (d) -> new ArchitectureEnvContent(d)));
	}

	private Pair<Incrementally<MediatorDecl, Simple_increment<MediatorDecl,Type_mediator>>, Environment> type_mediators(
			Environment gamma, EList<MediatorDecl> mediators) {
		return proveIncrementally(gamma, mediators, (g,x) -> proveSimpleIncrement(g, x, this::type_mediator, "SosADL.SosADL.MediatorDecl_name", MediatorDecl::getName, "(fun x => Some (EMediator x))", (d) -> new MediatorEnvContent(d)));
	}

	private Pair<Incrementally<SystemDecl, Simple_increment<SystemDecl,Type_system>>, Environment> type_systems(Environment gamma, EList<SystemDecl> systems) {
		return proveIncrementally(gamma, systems, (g,x) -> proveSimpleIncrement(g, x, this::type_system, "SosADL.SosADL.SystemDecl_name", SystemDecl::getName, "(fun x => Some (ESystem x))", (d) -> new SystemEnvContent(d)));
	}

	private Pair<Incrementally<FunctionDecl, Type_function>, Environment> type_functions(
			Environment gamma, EList<FunctionDecl> functions) {
		return proveIncrementally(gamma, functions, this::type_function);
	}

	private Pair<Incrementally<DataTypeDecl, Type_datatypeDecl>, Environment> type_datatypeDecls(Environment gamma,
			EList<DataTypeDecl> datatypes) {
		return proveIncrementally(gamma, datatypes, this::type_datatypeDecl);
	}

	private Pair<Type_datatypeDecl, Environment> type_datatypeDecl(Environment gamma, DataTypeDecl dataTypeDecl) {
		saveEnvironment(dataTypeDecl, gamma);
		if(dataTypeDecl.getName() != null) {
			Pair<Incrementally<FunctionDecl, Type_function>, Environment> p3 =
					type_functions(gamma.put(dataTypeDecl.getName(),
							new TypeEnvContent(dataTypeDecl, nil())), dataTypeDecl.getFunctions());
			return new Pair<>(saveProof(dataTypeDecl,createType_DataTypeDecl_def(gamma, dataTypeDecl.getName(), dataTypeDecl.getDatatype(), dataTypeDecl.getFunctions(), p3.getB(),
					proveOptionally(gamma, dataTypeDecl.getDatatype(), this::type_datatype),
					proveForall(dataTypeDecl.getFunctions(), (f) -> proveDataIsSelf(dataTypeDecl, f)),
					p3.getA())), p3.getB());
		} else {
			if(dataTypeDecl.getName() == null) {
				error("The data type declaration must have a name", dataTypeDecl, null);
			}
			return new Pair<>(null, gamma);
		}
	}

	private Ex<FormalParameter, And<Equality,Equality>> proveDataIsSelf(DataTypeDecl d, FunctionDecl f) {
		if(f.getData() != null && f.getData().getType() instanceof NamedType && ((NamedType)f.getData().getType()).getName().equals(d.getName())) {
			return createEx_intro(f.getData(), createConj(createReflexivity(), createReflexivity()));
		} else {
			if(f.getData() != null && (!(f.getData().getType() instanceof NamedType) || !((NamedType)f.getData().getType()).getName().equals(d.getName()))) {
				error("The type of the data parameter " + f.getData().getName() + " must be `" + d.getName() + "'", f.getData().getType(), null);
			} else if(f.getData() == null) {
				error("The function must have a data parameter", f, null);
			} else {
				error("Type error", f, null);
			}
			return null;
		}
	}

	private Pair<Type_function, Environment> type_function(Environment gamma, FunctionDecl f) {
		saveEnvironment(f, gamma);
		if(f.getData() != null && f.getData().getName() != null && f.getData().getType() != null && f.getData().getType() instanceof NamedType
				&& ((NamedType)f.getData().getType()).getName() != null && gamma.get(((NamedType)f.getData().getType()).getName()) != null
				&& gamma.get(((NamedType)f.getData().getType()).getName()) instanceof TypeEnvContent
				&& f.getName() != null && f.getType() != null && f.getExpression() != null) {
			Pair<Mutually<FormalParameter, Ex<DataType, And<Equality,Type_datatype>>>, Environment> p3 = type_formalParameters(gamma, cons(f.getData(), f.getParameters()));
			Pair<Incrementally<Valuing, Type_valuing>, Environment> p4 = type_valuings(p3.getB(), f.getValuing());
			Pair<Type_expression, DataType> p5 = type_expression(p4.getB(), f.getExpression());
			Environment gamma1 = gamma.put(((NamedType)f.getData().getType()).getName(),
					((TypeEnvContent)gamma.get(((NamedType)f.getData().getType()).getName())).addMethod(f));
			return new Pair<>(saveProof(f, createType_FunctionDecl_Method(gamma, f.getData().getName(),
					((NamedType)f.getData().getType()).getName(),
					((TypeEnvContent)gamma.get(((NamedType)f.getData().getType()).getName())).getDataTypeDecl(),
					((TypeEnvContent)gamma.get(((NamedType)f.getData().getType()).getName())).getMethods(),
					f.getName(), f.getParameters(), p3.getB(), f.getType(), f.getValuing(), p4.getB(),
					f.getExpression(), p5.getB(),
					gamma1,
					createReflexivity(), type_datatype(gamma, f.getType()), p3.getA(), p4.getA(), p5.getA(),
					subtype(gamma, p5.getB(), f.getType()), createReflexivity())),
				gamma1);
		} else {
			if(f.getExpression() == null) {
				error("The function must contain an expression", f, SosADLPackage.Literals.FUNCTION_DECL__EXPRESSION);
			}
			if(f.getType() == null) {
				error("The function must have a return type", f, SosADLPackage.Literals.FUNCTION_DECL__TYPE);
			}
			if(f.getName() == null) {
				error("The function must have a name", f, SosADLPackage.Literals.FUNCTION_DECL__NAME);
			}
			if(f.getData() == null) {
				error("The function must have a data parameter", f, SosADLPackage.Literals.FUNCTION_DECL__DATA);
			} else {
				if(f.getData().getName() == null) {
					error("The data parameter must have a name", f.getData(), SosADLPackage.Literals.FORMAL_PARAMETER__NAME);
				}
				if(f.getData().getType() == null) {
					error("The data parameter must have a type", f.getData(), SosADLPackage.Literals.FORMAL_PARAMETER__TYPE);
				} else {
					if (!(f.getData().getType() instanceof NamedType)) {
						error("The type of the data parameter must be a named type", f.getData().getType(), null);
					} else {
						if(((NamedType)f.getData().getType()).getName() == null) {
							error("The type of the data parameter must have a name", f.getData().getType(), SosADLPackage.Literals.NAMED_TYPE__NAME);
						} else {
							if (gamma.get(((NamedType)f.getData().getType()).getName()) == null) {
								error("The type `" + ((NamedType)f.getData().getType()).getName() + "' is undefined in this context", f.getData().getType(), null);
							} else if (!(gamma.get(((NamedType)f.getData().getType()).getName()) instanceof TypeEnvContent)) {
								error("`" + ((NamedType)f.getData().getType()).getName() + "' is not a type in this context", f.getData().getType(), null);
							}
						}
					}
				}
			}
			return new Pair<>(null, gamma);
		}
	}

	private Subtype subtype(Environment gamma, DataType a, DataType b) {
		// TODO Auto-generated method stub
		return null;
	}

	private static UnaryTypeInfo<?>[] unaryTypeInformations = new UnaryTypeInfo[] {
			new UnaryTypeInfo<>("+", RangeType.class, "range type", () -> createRangeType(0,0),
					(g, e, p1, p2) -> createType_expression_Same(g, e.getRight(), p1.getB(),
							p2.getB().getVmin(), p2.getB().getVmax(), p1.getA(), p2.getA()),
					(g, e, p1, p2) -> p2.getB()),
			new UnaryTypeInfo<>("-", RangeType.class, "range type", () -> createRangeType(0,0),
					(g, e, p1, p2) ->  createType_expression_Opposite(g, ((UnaryExpression)e).getRight(), p1.getB(),
							p2.getB().getVmax(), p2.getB().getVmax(), p1.getA(), p2.getA()),
					(g, e, p1, p2) -> createRangeType(createOpposite(EcoreUtil.copy(p2.getB().getVmax())),
							createOpposite(EcoreUtil.copy(p2.getB().getVmax())))),
			new UnaryTypeInfo<>("not", BooleanType.class, "boolean type", () -> createBooleanType(),
					(g, e, p1, p2) -> createType_expression_Not(g, e.getRight(), p1.getB(), p1.getA(), p2.getA()),
					(g, e, p1, p2) -> p2.getB())
	};
	
	private BinaryTypeInfo<?, ?, ?>[] binaryTypeInformations = new BinaryTypeInfo[] {
			new BinaryTypeInfo<>("+",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Add(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createRangeType(
							createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "+", EcoreUtil.copy(p4.getB().getVmin())),
							createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "+", EcoreUtil.copy(p4.getB().getVmax()))),
					() -> createRangeType(0, 0)),
			new BinaryTypeInfo<>("-",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Sub(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createRangeType(
							createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "-", EcoreUtil.copy(p4.getB().getVmax())),
							createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "-", EcoreUtil.copy(p4.getB().getVmin()))),
					() -> createRangeType(0, 0)),
			new BinaryTypeInfo<>("*",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> {
						Expression c1 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "*", EcoreUtil.copy(p4.getB().getVmin()));
						Expression c2 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "*", EcoreUtil.copy(p4.getB().getVmax()));
						Expression c3 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "*", EcoreUtil.copy(p4.getB().getVmin()));
						Expression c4 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "*", EcoreUtil.copy(p4.getB().getVmax()));
						return createType_expression_Mul(g,
								e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
								e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
								r.getVmin(), r.getVmax(), p1.getA(), p2.getA(), p3.getA(), p4.getA(),
								expression_le(r.getVmin(), c1),
								expression_le(r.getVmin(), c2),
								expression_le(r.getVmin(), c3),
								expression_le(r.getVmin(), c4),
								expression_le(c1, r.getVmax()),
								expression_le(c2, r.getVmax()),
								expression_le(c3, r.getVmax()),
								expression_le(c4, r.getVmax()));
					},
					(g, e, p1, p2, p3, p4) -> {
						Expression c1 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "*", EcoreUtil.copy(p4.getB().getVmin()));
						Expression c2 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "*", EcoreUtil.copy(p4.getB().getVmax()));
						Expression c3 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "*", EcoreUtil.copy(p4.getB().getVmin()));
						Expression c4 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "*", EcoreUtil.copy(p4.getB().getVmax()));
						Expression mi = EcoreUtil.copy(min(min(c1, c2), min(c3, c4)));
						Expression ma = EcoreUtil.copy(max(max(c1, c2), max(c3, c4)));
						return createRangeType(mi, ma);
						},
					() -> createRangeType(0, 0)),
			new BinaryTypeInfo<>("/",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> {
						if(isLe(createIntegerValue(1), p4.getB().getVmin())) {
							Expression c1 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "/", EcoreUtil.copy(p4.getB().getVmin()));
							Expression c2 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "/", EcoreUtil.copy(p4.getB().getVmax()));
							Expression c3 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "/", EcoreUtil.copy(p4.getB().getVmin()));
							Expression c4 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "/", EcoreUtil.copy(p4.getB().getVmax()));
							return createType_expression_Div_pos(g,
									e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
									e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
									r.getVmin(), r.getVmax(), p1.getA(), p2.getA(), p3.getA(), p4.getA(),
									expression_le(createIntegerValue(1), p4.getB().getVmin()),
									expression_le(r.getVmin(), c1),
									expression_le(r.getVmin(), c2),
									expression_le(r.getVmin(), c3),
									expression_le(r.getVmin(), c4),
									expression_le(c1, r.getVmax()),
									expression_le(c2, r.getVmax()),
									expression_le(c3, r.getVmax()),
									expression_le(c4, r.getVmax()));
						} else if (isLe(p4.getB().getVmax(), createOpposite(createIntegerValue(1)))) {
							Expression c1 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "/", EcoreUtil.copy(p4.getB().getVmin()));
							Expression c2 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "/", EcoreUtil.copy(p4.getB().getVmax()));
							Expression c3 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "/", EcoreUtil.copy(p4.getB().getVmin()));
							Expression c4 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "/", EcoreUtil.copy(p4.getB().getVmax()));
							return createType_expression_Div_neg(g,
									e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
									e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
									r.getVmin(), r.getVmax(), p1.getA(), p2.getA(), p3.getA(), p4.getA(),
									expression_le(p4.getB().getVmax(), createOpposite(createIntegerValue(1))),
									expression_le(r.getVmin(), c1),
									expression_le(r.getVmin(), c2),
									expression_le(r.getVmin(), c3),
									expression_le(r.getVmin(), c4),
									expression_le(c1, r.getVmax()),
									expression_le(c2, r.getVmax()),
									expression_le(c3, r.getVmax()),
									expression_le(c4, r.getVmax()));
						} else {
							error("The divisor must be different from 0", e.getRight(), null);
							return null;
						}
					},
					(g, e, p1, p2, p3, p4) -> {
						if(isLe(createIntegerValue(1), p4.getB().getVmin()) || isLe(p4.getB().getVmax(), createOpposite(createIntegerValue(1)))) {
							Expression c1 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "/", EcoreUtil.copy(p4.getB().getVmin()));
							Expression c2 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmin()), "/", EcoreUtil.copy(p4.getB().getVmax()));
							Expression c3 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "/", EcoreUtil.copy(p4.getB().getVmin()));
							Expression c4 = createBinaryExpression(EcoreUtil.copy(p2.getB().getVmax()), "/", EcoreUtil.copy(p4.getB().getVmax()));
							Expression mi = EcoreUtil.copy(min(min(c1, c2), min(c3, c4)));
							Expression ma = EcoreUtil.copy(max(max(c1, c2), max(c3, c4)));
							return createRangeType(mi, ma);
						} else {
							error("The divisor must be different from 0", e.getRight(), null);
							return null;
						}
					},
					() -> createRangeType(0, 0)),
			new BinaryTypeInfo<>("mod",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> {
						Range_modulo_min min = range_modulo_min(
								p2.getB().getVmin(), p2.getB().getVmax(),
								p4.getB().getVmin(), p4.getB().getVmax(),
								() -> createRange_modulo_min_pos(p2.getB().getVmin(), p2.getB().getVmax(),
										p4.getB().getVmin(), p4.getB().getVmax(),
										r.getVmin(),
										expression_le(createIntegerValue(1), p4.getB().getVmin()),
										expression_le(r.getVmin(), createBinaryExpression(createIntegerValue(1), "-", EcoreUtil.copy(p4.getB().getVmax())))),
								() -> createRange_modulo_min_zero(p2.getB().getVmin(), p2.getB().getVmax(),
										p4.getB().getVmin(), p4.getB().getVmax(),
										r.getVmin(),
										expression_le(createIntegerValue(0), p2.getB().getVmin()),
										expression_le(r.getVmin(), createIntegerValue(0))),
								() -> createRange_modulo_min_neg(p2.getB().getVmin(), p2.getB().getVmax(),
										p4.getB().getVmin(), p4.getB().getVmax(),
										r.getVmin(),
										expression_le(p4.getB().getVmax(), createOpposite(createIntegerValue(1))),
										expression_le(r.getVmin(), createBinaryExpression(EcoreUtil.copy(p4.getB().getVmin()), "+", createIntegerValue(1)))),
								() -> { error("The divisor must be different from 0", e.getRight(), null); return null; });
						if(min != null) {
							Range_modulo_max max = range_modulo_max(
									p2.getB().getVmin(), p2.getB().getVmax(),
									p4.getB().getVmin(), p4.getB().getVmax(),
									() -> createRange_modulo_max_pos(p2.getB().getVmin(), p2.getB().getVmax(),
											p4.getB().getVmin(), p4.getB().getVmax(),
											r.getVmax(),
											expression_le(createIntegerValue(1), p4.getB().getVmin()),
											expression_le(createBinaryExpression(EcoreUtil.copy(p4.getB().getVmax()), "-", createIntegerValue(1)), r.getVmax())),
									() -> createRange_modulo_max_zero(p2.getB().getVmin(), p2.getB().getVmax(),
											p4.getB().getVmin(), p4.getB().getVmax(),
											r.getVmax(),
											expression_le(p2.getB().getVmax(), createIntegerValue(0)),
											expression_le(createIntegerValue(0), r.getVmax())),
									() -> createRange_modulo_max_neg(p2.getB().getVmin(), p2.getB().getVmax(),
											p4.getB().getVmin(), p4.getB().getVmax(),
											r.getVmax(),
											expression_le(p4.getB().getVmax(), createOpposite(createIntegerValue(1))),
											expression_le(createBinaryExpression(createIntegerValue(1), "-", EcoreUtil.copy(p4.getB().getVmin())), r.getVmax())),
									() -> { error("The divisor must be different from 0", e.getRight(), null); return null; });
							if(max != null) {
								return createType_expression_Mod(g,
										e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
										e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
										r.getVmin(), r.getVmax(),
										p1.getA(), p2.getA(), p3.getA(), p4.getA(), min, max);
							} else {
								return null;
							}
						} else {
							return null;
						}
					},
					(g, e, p1, p2, p3, p4) -> {
						Expression min = range_modulo_min(
								p2.getB().getVmin(), p2.getB().getVmax(),
								p4.getB().getVmin(), p4.getB().getVmax(),
								() -> createBinaryExpression(createIntegerValue(1), "-", EcoreUtil.copy(p4.getB().getVmax())),
								() -> createIntegerValue(0),
								() -> createBinaryExpression(EcoreUtil.copy(p4.getB().getVmin()), "+", createIntegerValue(1)),
								() -> { error("The divisor must be different from 0", e.getRight(), null); return null; });
						if(min != null) {
							Expression max = range_modulo_max(
									p2.getB().getVmin(), p2.getB().getVmax(),
									p4.getB().getVmin(), p4.getB().getVmax(),
									() -> createBinaryExpression(EcoreUtil.copy(p4.getB().getVmax()), "-", createIntegerValue(1)),
									() -> createIntegerValue(0),
									() -> createBinaryExpression(createIntegerValue(1), "-", EcoreUtil.copy(p4.getB().getVmin())),
									() -> { error("The divisor must be different from 0", e.getRight(), null); return null; });
							if(max != null) {
								return createRangeType(min, max);
							} else {
								return null;
							}
						} else {
							return null;
						}
					},
					() -> createRangeType(0, 0)),
			new BinaryTypeInfo<>("implies",
					BooleanType.class, "boolean type", () -> createBooleanType(),
					BooleanType.class, "boolean type", () -> createBooleanType(),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Implies(g,
							e.getLeft(), p1.getB(),
							e.getRight(), p3.getB(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("or",
					BooleanType.class, "boolean type", () -> createBooleanType(),
					BooleanType.class, "boolean type", () -> createBooleanType(),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Or(g,
							e.getLeft(), p1.getB(),
							e.getRight(), p3.getB(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("xor",
					BooleanType.class, "boolean type", () -> createBooleanType(),
					BooleanType.class, "boolean type", () -> createBooleanType(),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Xor(g,
							e.getLeft(), p1.getB(),
							e.getRight(), p3.getB(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("and",
					BooleanType.class, "boolean type", () -> createBooleanType(),
					BooleanType.class, "boolean type", () -> createBooleanType(),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_And(g,
							e.getLeft(), p1.getB(),
							e.getRight(), p3.getB(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("=",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Equal(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("<>",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Diff(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("<",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Lt(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>("<=",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Le(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>(">",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Gt(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
			new BinaryTypeInfo<>(">=",
					RangeType.class, "range type", () -> createRangeType(0, 0),
					RangeType.class, "range type", () -> createRangeType(0, 0),
					(g, e, p1, p2, p3, p4, r) -> createType_expression_Ge(g,
							e.getLeft(), p1.getB(), p2.getB().getVmin(), p2.getB().getVmax(),
							e.getRight(), p3.getB(), p4.getB().getVmin(), p4.getB().getVmax(),
							p1.getA(), p2.getA(), p3.getA(), p4.getA()),
					(g, e, p1, p2, p3, p4) -> createBooleanType(),
					() -> createBooleanType()),
	};
	
	private <T> T range_modulo_min(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Supplier<T> pos, Supplier<T> zero, Supplier<T> neg, Supplier<T> divByZero) {
		if(isLe(createIntegerValue(1), rmin)) {
			if(isLe(createIntegerValue(0), lmin)) {
				return zero.get();
			} else {
				return pos.get();
			}
		} else if(isLe(rmax, createOpposite(createIntegerValue(1)))) {
			if(isLe(createIntegerValue(0), lmin)) {
				return zero.get();
			} else {
				return neg.get();
			}
		} else {
			return divByZero.get();
		}
	}
	
	private <T> T range_modulo_max(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Supplier<T> pos, Supplier<T> zero, Supplier<T> neg, Supplier<T> divByZero) {
		if(isLe(createIntegerValue(1), rmin)) {
			if(isLe(lmax, createIntegerValue(0))) {
				return zero.get();
			} else {
				return pos.get();
			}
		} else if(isLe(rmax, createOpposite(createIntegerValue(1)))) {
			if(isLe(lmax, createIntegerValue(0))) {
				return zero.get();
			} else {
				return neg.get();
			}
		} else {
			return divByZero.get();
		}
	}
	
	private static Expression min(Expression l, Expression r) {
		if(InterpInZ.le(l, r)) {
			return l;
		} else {
			return r;
		}
	}
	
	private static Expression max(Expression l, Expression r) {
		if(InterpInZ.le(r, l)) {
			return l;
		} else {
			return r;
		}
	}
	
	private <T extends DataType> Pair<Type_expression_node, DataType> typeUnaryExpression(Environment gamma, UnaryExpression e, UnaryTypeInfo<T> i) {
		Pair<Type_expression, DataType> p1 = type_expression(gamma, e.getRight());
		Pair<Subtype, T> p2 = smallestSuperType(i.getClazz(), i.getLabel(), i.getIfNone().get(), gamma, p1.getB(), e, SosADLPackage.Literals.UNARY_EXPRESSION__RIGHT);
		return new Pair<>(saveProof(e, i.getCreateProofTerm().apply(gamma, e, p1, p2)), saveType(e, i.getCreateType().apply(gamma, e, p1, p2)));
	}
	
	private <L extends DataType, R extends DataType, X extends DataType> Pair<Type_expression_node, DataType> typeBinaryExpression(Environment gamma, BinaryExpression e, BinaryTypeInfo<L, R, X> i) {
		Pair<Type_expression, DataType> p1 = type_expression(gamma, e.getLeft());
		Pair<Subtype, L> p2 = smallestSuperType(i.getlClass(), i.getlLabel(), i.getlIfNone().get(), gamma, p1.getB(), e, SosADLPackage.Literals.BINARY_EXPRESSION__LEFT);
		Pair<Type_expression, DataType> p3 = type_expression(gamma, e.getRight());
		Pair<Subtype, R> p4 = smallestSuperType(i.getrClass(), i.getrLabel(), i.getrIfNone().get(), gamma, p3.getB(), e, SosADLPackage.Literals.BINARY_EXPRESSION__RIGHT);
		X r = i.createType.apply(gamma, e, p1, p2, p3, p4);
		if(r != null) {
			return new Pair<>(saveProof(e, i.createProofTerm.apply(gamma, e, p1, p2, p3, p4, r)), saveType(e, r));
		} else {
			return new Pair<>(null, i.createDefault.get());
		}
	}

	private Pair<Type_expression, DataType> type_expression(Environment gamma, Expression e) {
		Pair<Type_expression_node, DataType> p1 = type_expression_node(gamma, e);
		return new Pair<>(createType_expression_and_type(gamma, e, p1.getB(), p1.getA(), type_datatype(gamma, p1.getB())), p1.getB());
	}
	
	private Pair<Type_expression_node, DataType> type_expression_node(Environment gamma, Expression e) {
		saveEnvironment(e, gamma);
		if(e instanceof IntegerValue) {
			DataType t = createRangeType(EcoreUtil.copy(e), EcoreUtil.copy(e));
			return new Pair<>(saveProof(e, createType_expression_IntegerValue(gamma, BigInteger.valueOf(((IntegerValue) e).getAbsInt()))),
					saveType(e, t));
		} else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getRight() != null) {
			for(UnaryTypeInfo<? extends DataType> i : unaryTypeInformations) {
				if(((UnaryExpression)e).getOp().equals(i.getOperator())) {
					return typeUnaryExpression(gamma, (UnaryExpression)e, i);
				}
			}
			error("Unknown unary operator", e, SosADLPackage.Literals.UNARY_EXPRESSION__OP);
			return new Pair<>(null, SosADLFactory.eINSTANCE.createBooleanType());
		} else if(e instanceof BinaryExpression && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getRight() != null) {
			for(BinaryTypeInfo<? extends DataType, ? extends DataType, ? extends DataType> i: binaryTypeInformations) {
				if(((BinaryExpression)e).getOp().equals(i.getOperator())) {
					return typeBinaryExpression(gamma, (BinaryExpression)e, i);
				}
			}
			error("Unknown binary operator", e, SosADLPackage.Literals.BINARY_EXPRESSION__OP);
			return new Pair<>(null, SosADLFactory.eINSTANCE.createBooleanType());
		} else {
			// TODO
			if(e instanceof UnaryExpression) {
				if(((UnaryExpression)e).getRight() == null) {
					error("The unary operator must have a right operand", e, SosADLPackage.Literals.UNARY_EXPRESSION__RIGHT);
				}
				if(((UnaryExpression)e).getOp() == null) {
					error("The unary expression must have an operator", e, SosADLPackage.Literals.UNARY_EXPRESSION__OP);
				}
			} else if(e instanceof BinaryExpression) {
				if(((BinaryExpression)e).getLeft() == null) {
					error("The binary operator must have a left operand", e, SosADLPackage.Literals.BINARY_EXPRESSION__LEFT);
				}
				if(((BinaryExpression)e).getOp() == null) {
					error("The binary operator must have an operator", e, SosADLPackage.Literals.BINARY_EXPRESSION__OP);
				}
				if(((BinaryExpression)e).getRight() == null) {
					error("The binary operator must have a right operand", e, SosADLPackage.Literals.BINARY_EXPRESSION__RIGHT);
				}
			} else {
				error("Type error", e, null);
			}
			return new Pair<>(null, SosADLFactory.eINSTANCE.createBooleanType());
		}
	}

	private <T extends DataType> Pair<Subtype, T> smallestSuperType(Class<T> target, String label, T ifNone, Environment gamma, DataType t, EObject targetForError, EStructuralFeature forError) {
		if(target.isInstance(t)) {
			return new Pair<>(createSubtype_refl(gamma, t), target.cast(t));
		} else if(t instanceof NamedType && ((NamedType)t).getName() != null && gamma.get(((NamedType)t).getName()) != null
				&& gamma.get(((NamedType)t).getName()) instanceof TypeEnvContent
				&& ((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getName() != null
				&& ((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getName().equals(((NamedType)t).getName())
				&& ((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getDatatype() != null) {
			DataType def = ((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getDatatype();
			Pair<Subtype, T> p2 = smallestSuperType(target, label, ifNone, gamma, def, targetForError, forError);
			return new Pair<>(createSubtype_unfold_left(gamma, ((NamedType)t).getName(), def,
					((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getFunctions(),
					((TypeEnvContent)gamma.get(((NamedType)t).getName())).getMethods(),
					p2.getB(), createReflexivity(), p2.getA()), p2.getB());
		} else {
			if(t instanceof NamedType) {
				if(((NamedType)t).getName() == null) {
					error("The named type must have a name", targetForError, forError);
				} else if (gamma.get(((NamedType)t).getName()) == null) {
					error("The named type `" + ((NamedType)t).getName() + "' is undefined in this context", targetForError, forError);
				} else if (!(gamma.get(((NamedType)t).getName()) instanceof TypeEnvContent)) {
					error("The name `" + ((NamedType)t).getName() + "' must be a type declaration", targetForError, forError);
				} else if (((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getName() == null || !((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getName().equals(((NamedType)t).getName())) {
					error("The name `" + ((NamedType)t).getName() + "' does not match the declaration `" + ((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getName() + "'", targetForError, forError);
				} else if (((TypeEnvContent)gamma.get(((NamedType)t).getName())).getDataTypeDecl().getDatatype() == null) {
					error("The type `" + ((NamedType)t).getName() + "', whose definition is opaque, cannot be converted to a " + label, targetForError, forError);
				} else {
					error("Type error", targetForError, forError);
				}
			} else if(t instanceof BooleanType) {
				error("A boolean type cannot be converted to a " + label, targetForError, forError);
			} else if(t instanceof SequenceType) {
				error("A sequence type cannot be converted to a " + label, targetForError, forError);
			} else if(t instanceof TupleType) {
				error("A tuple type cannot be converted to a " + label, targetForError, forError);
			} else if(t instanceof RangeType) {
				error("A range type cannot be converted to a " + label, targetForError, forError);
			} else {
				error("Type error", targetForError, forError);
			}
			return new Pair<>(null, ifNone);
		}
	}

	private Pair<Incrementally<Valuing, Type_valuing>, Environment> type_valuings(Environment gamma,
			EList<Valuing> l) {
		// TODO Auto-generated method stub
		return new Pair<>(null, gamma);
	}

	private Type_system type_system(Environment gamma, SystemDecl systemDecl) {
		saveEnvironment(systemDecl, gamma);
		// type_SystemDecl:
		if(systemDecl.getName() != null && systemDecl.getBehavior() != null) {
			Pair<Mutually<FormalParameter,Ex<DataType, And<Equality,Type_datatype>>>, Environment> p1 = type_formalParameters(gamma, systemDecl.getParameters());
			Pair<Incrementally<DataTypeDecl,Type_datatypeDecl>,Environment> p2 = type_datatypeDecls(p1.getB(), systemDecl.getDatatypes());
			Pair<Incrementally<GateDecl,Simple_increment<GateDecl,Type_gate>>,Environment> p3 = type_gates(p2.getB(), systemDecl.getGates());
			return saveProof(systemDecl, createType_SystemDecl(gamma, systemDecl.getName(), systemDecl.getParameters(), p1.getB(), systemDecl.getDatatypes(), p2.getB(), systemDecl.getGates(), p3.getB(),
					systemDecl.getBehavior(), systemDecl.getAssertion(), p1.getA(), p2.getA(), p3.getA(),
					type_behavior(p3.getB(), systemDecl.getBehavior()),
					proveOptionally(p3.getB(), systemDecl.getAssertion(), this::type_assertion)));
		} else {
			if(systemDecl.getBehavior() == null) {
				error("The system must have a behavior", systemDecl, null);
			} else if(systemDecl.getName() == null) {
				error("The system must have a name", systemDecl, null);
			} else {
				error("Type error", systemDecl, null);
			}
			return null;
		}
	}

	private Pair<Incrementally<GateDecl, Simple_increment<GateDecl,Type_gate>>, Environment> type_gates(Environment gamma, EList<GateDecl> l) {
		return proveIncrementally(gamma, l, (g,x) -> proveSimpleIncrement(g, x, this::type_gate, "SosADL.SosADL.GateDecl_name", GateDecl::getName, "(fun x => None)", (y) -> null));
	}
	
	private Type_assertion type_assertion(Environment gamma, AssertionDecl a) {
		// TODO Auto-generated method stub
		return null;
	}
	
	private Type_gate type_gate(Environment gamma, GateDecl g) {
		// TODO Auto-generated method stub
		return null;
	}

	private Pair<Mutually<FormalParameter, Ex<DataType, And<Equality, Type_datatype>>>, Environment> type_formalParameters(
			Environment gamma, EList<FormalParameter> params) {
		return proveMutually(gamma, params,
				this::type_formalParameter, "SosADL.SosADL.FormalParameter_name", FormalParameter::getName,
				"SosADL.TypeSystem.formalParameter_to_EVariable", SosADLValidator::formalParameterEnvContent);
	}

	private Type_mediator type_mediator(Environment gamma, MediatorDecl mediator) {
		saveEnvironment(mediator, gamma);
		// TODO Auto-generated method stub
		return null;
	}

	private Type_architecture type_architecture(Environment gamma, ArchitectureDecl architecture) {
		saveEnvironment(architecture, gamma);
		// TODO Auto-generated method stub
		return null;
	}

	private <T> Ex<DataType, And<Equality,Type_datatype>> proveExistsAndEqType(Environment gamma, T t, Function<T, DataType> getter) {
		return createEx_intro(getter.apply(t), createConj(createReflexivity(), type_datatype(gamma, getter.apply(t))));
	}
	
	private Ex<DataType, And<Equality,Type_datatype>> type_formalParameter(Environment gamma, FormalParameter p, Environment gamma1) {
		return saveProof(p, proveExistsAndEqType(gamma, p, FormalParameter::getType));
	}
	
	private static EnvContent formalParameterEnvContent(FormalParameter p) {
		DataType t = p.getType();
		if(t == null) {
			return null;
		} else {
			return new VariableEnvContent(p, t);
		}
	}
	
	private Expression_le expression_le(Expression l, Expression r) {
		if(isLe(l, r)) {
			return createIn_Z(l, InterpInZ.eval(l), r, InterpInZ.eval(r), createReflexivity(), createReflexivity(), createReflexivity());
		} else {
			if(isConstExprNoError(l) && isConstExprNoError(r)) {
				error("The lower bound must be smaller than the upper bound", l, null);
				error("The upper bound must be greater than the lower bound", r, null);
			} else {
				error("Type error", l, null);
			}
			return null;
		}
	}

	private boolean isLe(Expression l, Expression r) {
		return isConstExprOrError(l) && isConstExprOrError(r) && InterpInZ.le(l, r);
	}

	private Type_datatype type_datatype(Environment gamma, DataType type) {
		saveEnvironment(type, gamma);
		// type_NamedType:
		if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) != null && gamma.get(((NamedType)type).getName()) instanceof TypeEnvContent && ((TypeEnvContent)gamma.get(((NamedType)type).getName())).getDataTypeDecl() != null) {
			return saveProof(type, createType_NamedType(gamma, ((NamedType)type).getName(), ((TypeEnvContent)gamma.get(((NamedType)type).getName())).getDataTypeDecl(),
					createEx_intro(((TypeEnvContent)gamma.get(((NamedType)type).getName())).getMethods(), createReflexivity())));
		}
		// type_TupleType:
		else if(type instanceof TupleType) {
			Pair<Mutually<FieldDecl, Ex<DataType, And<Equality, Type_datatype>>>, Environment> p1 = type_fields(gamma, ((TupleType)type).getFields());
			return saveProof(type, createType_TupleType(gamma, ((TupleType)type).getFields(), p1.getA()));
		}
		// type_SequenceType:
		else if(type instanceof SequenceType && ((SequenceType)type).getType() != null) {
			return saveProof(type, createType_SequenceType(gamma, ((SequenceType)type).getType(),
					type_datatype(gamma, ((SequenceType)type).getType())));
		}
		// type_RangeType_trivial
		else if(type instanceof RangeType && ((RangeType)type).getVmin() != null
				&& ((RangeType)type).getVmax() != null
				&& isLe(((RangeType)type).getVmin(), ((RangeType)type).getVmax())) {
			saveMin(type, InterpInZ.eval(((RangeType)type).getVmin()));
			saveMax(type, InterpInZ.eval(((RangeType)type).getVmax()));
			return saveProof(type, createType_RangeType_trivial(gamma, ((RangeType)type).getVmin(), ((RangeType)type).getVmax(),
					expression_le(((RangeType)type).getVmin(), ((RangeType)type).getVmax())));
		}
		// type_BooleanType:
		else if(type instanceof BooleanType) {
			return saveProof(type, createType_BooleanType(gamma));
		} else {
			if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) != null && gamma.get(((NamedType)type).getName()) instanceof TypeEnvContent && ((TypeEnvContent)gamma.get(((NamedType)type).getName())).getDataTypeDecl() == null) {
				error("No type declaration named `" + gamma.get(((NamedType)type).getName()) + "'", type, null);
			} else if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) != null && !(gamma.get(((NamedType)type).getName()) instanceof TypeEnvContent)) {
				error("`" + ((NamedType)type).getName() + "' is not a type declaration", type, null);
			} else if(type instanceof NamedType && ((NamedType)type).getName() != null && gamma.get(((NamedType)type).getName()) == null) {
				error("`" + ((NamedType)type).getName() + "' is undefined in this context", type, null);
			} else if(type instanceof NamedType && ((NamedType)type).getName() == null) {
				error("The named type must have a name", type, null);
			} else if(type instanceof SequenceType && ((SequenceType)type).getType() == null) {
				error("The sequence type must declare a base type", type, null);
			} else if(type instanceof RangeType && ((RangeType)type).getVmin() != null && ((RangeType)type).getVmax() != null && !containsSomeNull(constexpr_expression(((RangeType)type).getVmin())) && !containsSomeNull(constexpr_expression(((RangeType)type).getVmax())) && InterpInZ.gt(((RangeType)type).getVmin(), ((RangeType)type).getVmax())) {
				error("The lower bound of the range is greater than the upper bound", type, null);
			} else if(type instanceof RangeType && ((RangeType)type).getVmin() != null && ((RangeType)type).getVmax() != null) {
				if(!isConstExprNoError(((RangeType)type).getVmin())) {
					error("The lower bound of the range is not a constant integer", type, SosADLPackage.Literals.RANGE_TYPE__VMIN);
				}
				if(!isConstExprNoError(((RangeType)type).getVmax())) {
					error("The upper bound of the range is not a constant integer", type, SosADLPackage.Literals.RANGE_TYPE__VMAX);
				}
			} else if(type instanceof RangeType) {
				error("The range must have a lower bound and an upper bound", type, null);
			} else {
				error("Type error", type, null);
			}
			return null;
		}
	}
	
	private Ex<DataType, And<Equality,Type_datatype>> type_field(Environment gamma, FieldDecl f, Environment gamma1) {
		return saveProof(f, proveExistsAndEqType(gamma, f, FieldDecl::getType));
	}

	private Pair<Mutually<FieldDecl, Ex<DataType, And<Equality, Type_datatype>>>, Environment> type_fields(
			Environment gamma, EList<FieldDecl> fields) {
		return proveMutually(gamma, fields, this::type_field, "(fun _ => None)", (x) -> null, "(fun _ => None)", (x) -> null);
	}

	private boolean isConstExprOrError(Expression e) {
		return isConstExpr(e, this::error);
	}

	private boolean isConstExprNoError(Expression e) {
		return isConstExpr(e, (a,b,c) -> {});
	}

	private boolean isConstExpr(Expression e, TriConsumer<String, EObject, EStructuralFeature> trigger) {
		// constexpr_IntegerValue:
		if(e instanceof IntegerValue) {
			return true;
		}
		// constexpr_Opposite:
		else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getOp().equals("-") && ((UnaryExpression)e).getRight() != null) {
			return isConstExpr(((UnaryExpression)e).getRight(), trigger);
		}
		// constexpr_Same:
		else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getOp().equals("+") && ((UnaryExpression)e).getRight() != null) {
			return isConstExpr(((UnaryExpression)e).getRight(), trigger);
		}
		// constexpr_Add:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("+") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return isConstExpr(((BinaryExpression)e).getLeft(), trigger) & isConstExpr(((BinaryExpression)e).getRight(), trigger);
		}
		// constexpr_Sub:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("-") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return isConstExpr(((BinaryExpression)e).getLeft(), trigger) & isConstExpr(((BinaryExpression)e).getRight(), trigger);
		}
		// constexpr_Mul:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("*") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return isConstExpr(((BinaryExpression)e).getLeft(), trigger) & isConstExpr(((BinaryExpression)e).getRight(), trigger);
		}
		// constexpr_Div:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("/") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return isConstExpr(((BinaryExpression)e).getLeft(), trigger) & isConstExpr(((BinaryExpression)e).getRight(), trigger);
		}
		// constexpr_Mod:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("mod") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return isConstExpr(((BinaryExpression)e).getLeft(), trigger) & isConstExpr(((BinaryExpression)e).getRight(), trigger);
		} else {
			return false;
		}
	}

	private Constexpr_expression constexpr_expression(Expression e) {
		// constexpr_IntegerValue:
		if(e instanceof IntegerValue) {
			return saveProof(e, createConstexpr_IntegerValue(BigInteger.valueOf(((IntegerValue) e).getAbsInt())));
		}
		// constexpr_Opposite:
		else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getOp().equals("-") && ((UnaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Opposite(((UnaryExpression)e).getRight(), constexpr_expression(((UnaryExpression)e).getRight())));
		}
		// constexpr_Same:
		else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getOp().equals("+") && ((UnaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Same(((UnaryExpression)e).getRight(), constexpr_expression(((UnaryExpression)e).getRight())));
		}
		// constexpr_Add:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("+") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Add(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Sub:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("-") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Sub(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Mul:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("*") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Mul(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Div:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("/") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Div(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		}
		// constexpr_Mod:
		else if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getOp().equals("mod") && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
			return saveProof(e, createConstexpr_Mod(((BinaryExpression)e).getLeft(), ((BinaryExpression)e).getRight(), constexpr_expression(((BinaryExpression)e).getLeft()), constexpr_expression(((BinaryExpression)e).getRight())));
		} else {
			if(e instanceof BinaryExpression && ((BinaryExpression)e).getOp() != null && ((BinaryExpression)e).getLeft() != null && ((BinaryExpression)e).getRight() != null) {
				error("Invalid binary operator for constant-integer expressions", e, SosADLPackage.Literals.BINARY_EXPRESSION__OP);
			} else if(e instanceof BinaryExpression) {
				error("Missing operator or operand", e, null);
			} else if(e instanceof UnaryExpression && ((UnaryExpression)e).getOp() != null && ((UnaryExpression)e).getRight() != null) {
				error("Invalid unary operator for constant-integer expressions", e, SosADLPackage.Literals.BINARY_EXPRESSION__OP);
			} else if(e instanceof UnaryExpression) {
				error("Missing operator or operand", e, null);
			} else {
				error("This expression is not a constant-integer expression", e, null);
			}
			return null;
		}
	}

	private Type_behavior type_behavior(Environment gamma, BehaviorDecl behaviorDecl) {
		// TODO Auto-generated method stub
		return null;
	}

	private static <T extends EObject, P extends ProofTerm> Forall<T, P> proveForall(
			List<? extends T> l, Function<T, ? extends P> prover) {
		if(l.isEmpty()) {
			return createForall_nil();
		} else {
			return createForall_cons(l.get(0), prover.apply(l.get(0)), proveForall(cdr(l), prover));
		}
	}
	
	private static <T extends EObject, P extends ProofTerm> Pair<Incrementally<T,P>,Environment> proveIncrementally(Environment gamma, List<T> l,
			BiFunction<Environment, T, Pair<P, Environment>> prover) {
		if(l.isEmpty()) {
			return new Pair<>(createIncrementally_nil(gamma), gamma);
		} else {
			Pair<P, Environment> pi = prover.apply(gamma,  l.get(0));
			Environment gammai = pi.getB();
			Pair<Incrementally<T, P>, Environment> pn = proveIncrementally(gammai, cdr(l), prover);
			Environment gamma1 = pn.getB();
			return new Pair<>(createIncrementally_cons(gamma, l.get(0), gammai, cdr(l), gamma1, pi.getA(), pn.getA()), gamma1);
		}
	}
	
	private static <T extends EObject, P extends ProofTerm> Pair<Simple_increment<T,P>,Environment> proveSimpleIncrement(Environment gamma, T x,
			BiFunction<Environment, T, P> prover, String n, Function<T, ? extends String> name, String c, Function<T, ? extends EnvContent> content) {
		Environment gamma1 = augment_env(gamma, name.apply(x), content.apply(x));
		return new Pair<>(createSimple_increment_step(n, c, gamma, x, gamma1, createReflexivity(), prover.apply(gamma, x)), gamma1);
	}

	@SuppressWarnings("unused")
	private <T extends EObject, P extends ProofTerm> Pair<Mutually<T,P>, Environment> proveMutually(Environment gamma, List<T> l,
			TriFunction<Environment, T, Environment, P> prover, Function<T, ? extends String> name, Function<T, ? extends EnvContent> content) {
		if(noDuplicate(l.stream().map(name))) {
			Environment gamma1 = fold_right((x, g) -> augment_env(g, name.apply(x), content.apply(x)), gamma, l);
			return new Pair<>(createMutually_all(gamma, l, gamma1, createReflexivity(), createReflexivity(), proveForall(l, (x) -> prover.apply(gamma,  x,  gamma1))), gamma1);
		} else {
			l.stream().filter((p) -> l.stream().map(name).filter((n) -> n.equals(name.apply(p))).count() >= 2)
			.forEach((f) -> error("Multiple definitions of `" + name.apply(f) + "'", f, null));
			return new Pair<>(null, gamma);
		}
	}

	private <T extends EObject, P extends ProofTerm> Pair<Mutually<T,P>, Environment> proveMutually(Environment gamma, List<T> l,
			TriFunction<Environment, T, Environment, P> prover, String n, Function<T, ? extends String> name,
			String c, Function<T, ? extends EnvContent> content) {
		if(noDuplicate(l.stream().map(name))) {
			Environment gamma1 = fold_right((x, g) -> augment_env(g, name.apply(x), content.apply(x)), gamma, l);
			return new Pair<>(createMutually_all_explicit(n, c, gamma, l, gamma1, createReflexivity(), createReflexivity(), proveForall(l, (x) -> prover.apply(gamma,  x,  gamma1))), gamma1);
		} else {
			l.stream().filter((p) -> l.stream().map(name).filter((x) -> x.equals(name.apply(p))).count() >= 2)
			.forEach((f) -> error("Multiple definitions of `" + name.apply(f) + "'", f, null));
			return new Pair<>(null, gamma);
		}
	}
	
	private <T extends EObject, P extends ProofTerm> Optionally<T, P> proveOptionally(Environment gamma, T x, BiFunction<Environment,T,P> prover) {
		if(x == null) {
			return createOptionally_None(gamma);
		} else {
			return createOptionally_Some(gamma, x, prover.apply(gamma, x));
		}
	}

	public static final String ENVIRONMENT = "Environment";
	public static final String PROOF = "Proof";
	public static final String MIN = "Min";
	public static final String MAX = "Max";
	public static final String TYPE = "Type";

	public static DataType saveType(EObject eObject, DataType t) {
		AttributeAdapter.adapterOf(eObject).putAttribute(TYPE, t);
		return t;
	}
	
	public static DataType getType(EObject eObject) {
		return (DataType) AttributeAdapter.adapterOf(eObject).getAttribute(TYPE);
	}
	
	public static void saveMin(EObject eObject, BigInteger i) {
		AttributeAdapter.adapterOf(eObject).putAttribute(MIN, i);
	}
	
	public static void saveMax(EObject eObject, BigInteger i) {
		AttributeAdapter.adapterOf(eObject).putAttribute(MAX, i);
	}
	
	public static void saveEnvironment(EObject eObject, Environment env) {
		AttributeAdapter.adapterOf(eObject).putAttribute(ENVIRONMENT, env);
	}
	
	public static <T> T saveProof(EObject eObject, T proof) {
		AttributeAdapter.adapterOf(eObject).putAttribute(PROOF, proof);
		return proof;
	}

	public static Object getProof(EObject eObject) {
		return AttributeAdapter.adapterOf(eObject).getAttribute(PROOF);
	}
	
	private static Environment augment_env(Environment gamma, String name, EnvContent content) {
		if(name == null) {
			return gamma;
		} else if(content == null) {
			return gamma;
		} else {
			return gamma.put(name, content);
		}
	}

	private static <T> EList<T> cdr(List<T> l) {
		Iterator<T> i = l.iterator();
		EList<T> ret;
		if(i.hasNext()) {
			i.next();
			ret = ECollections.toEList(i);
		} else {
			ret = ECollections.emptyEList();
		}
		return ECollections.unmodifiableEList(ret);
	}
	
	private static <T> EList<T> cons(T v, List<T> l) {
		List<T> lv = new LinkedList<>();
		lv.add(v);
		EList<T> ret = ECollections.asEList(lv);
		ret.addAll(l);
		return ECollections.unmodifiableEList(ret);
	}
	
	private static <T> EList<T> nil() {
		return ECollections.unmodifiableEList(ECollections.emptyEList());
	}
	
	@SuppressWarnings("unused")
	private static <A,B> A fold_left(BiFunction<A,B,A> f, List<B> l, A i) {
		/*
		if(l.isEmpty()) {
			return i;
		} else {
			return fold_left(f, cdr(l), f.apply(i, l.get(0)));
		}
		*/
		A r = i;
		for(B x:l) {
			r = f.apply(r, x);
		}
		return r;
	}
	
	private static <A,B> A fold_right(BiFunction<B,A,A> f, A i, List<B> l) {
		/*
		if(l.isEmpty()) {
			return i;
		} else {
			return f.apply(l.get(0), fold_right(f, i, cdr(l)));
		}
		*/
		A r = i;
		for(int j = l.size();j > 0;) {
			--j;
			B x = l.get(j);
			r = f.apply(x, r);
		}
		return r;
	}
	
	private static <T> boolean noDuplicate(Stream<T> s) {
		List<T> list = s.filter((p) -> p != null).collect(Collectors.toList());
		Set<T> set = new TreeSet<>(list);
		return list.size() == set.size();
	}

	private boolean containsSomeNull(Object o) {
		for(Field f : o.getClass().getDeclaredFields()) {
			if(!f.isAnnotationPresent(Eluded.class) && f.isAnnotationPresent(Mandatory.class) && ProofTerm.class.isAssignableFrom(f.getType())) {
				try {
					Method getter = o.getClass().getMethod("get" + StringExtensions.toFirstUpper(f.getName()));
					Object i = getter.invoke(o);
					if(i == null) {
						return true;
					} else if(containsSomeNull(i)) {
						return true;
					}
				} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
				}
			}
		}
		return false;
	}
	
	private static Type_sosADL createType_SosADL(EList<Import> i, Unit d, Type_unit p) {
		return new Type_SosADL(i, d, p);
	}
	
	private static Type_unit createType_SoS(Environment gamma, String n, EntityBlock e, Type_entityBlock p) {
		return new Type_SoS(gamma, n, e, p);
	}
	
	private static Type_unit createType_Library(Environment gamma, String n, EntityBlock e, Type_entityBlock p) {
		return new Type_Library(gamma, n, e, p);
	}
	
	private static Type_entityBlock createType_EntityBlock_whole(Environment gamma, List<DataTypeDecl> datatypes, Environment gamma1,
			List<FunctionDecl> funs, Environment gamma2, List<SystemDecl> systems, Environment gamma3,
			List<MediatorDecl> mediators, Environment gamma4, List<ArchitectureDecl> architectures, Environment gamma5,
			Incrementally<DataTypeDecl,Type_datatypeDecl> p1, Incrementally<FunctionDecl, Type_function> p2,
			Incrementally<SystemDecl,Simple_increment<SystemDecl,Type_system>> p3, Incrementally<MediatorDecl,Simple_increment<MediatorDecl,Type_mediator>> p4,
			Incrementally<ArchitectureDecl, Simple_increment<ArchitectureDecl, Type_architecture>> p5) {
		return new Type_EntityBlock_whole(gamma, datatypes, gamma1, funs, gamma2, systems, gamma3, mediators, gamma4, architectures, gamma5, p1, p2, p3, p4, p5);
	}
	
	private static Type_system createType_SystemDecl(Environment gamma, String name, EList<FormalParameter> params, Environment gamma1,
			EList<DataTypeDecl> datatypes, Environment gamma2, EList<GateDecl> gates, Environment gamma3,
			BehaviorDecl bhv, AssertionDecl assrt,
			Mutually<FormalParameter, Ex<DataType, And<Equality, Type_datatype>>> p1,
			Incrementally<DataTypeDecl,Type_datatypeDecl> p2, Incrementally<GateDecl,Simple_increment<GateDecl,Type_gate>> p3, Type_behavior p4,
			Optionally<AssertionDecl, Type_assertion> p5) {
		return new Type_SystemDecl(gamma, name, params, gamma1, datatypes, gamma2, gates, gamma3, bhv, assrt, p1, p2, p3, p4, p5);
	}
	
	private static Type_datatypeDecl createType_DataTypeDecl_def(Environment gamma, String name, DataType t, EList<FunctionDecl> funs, Environment gamma1, Optionally<DataType, Type_datatype> p1, Forall<FunctionDecl,Ex<FormalParameter, And<Equality, Equality>>> p2, Incrementally<FunctionDecl, Type_function> p3) {
		return new Type_DataTypeDecl_def(gamma, name, t, funs, gamma1, p1, p2, p3);
	}

	private static Type_datatype createType_NamedType(Environment gamma, String n, DataTypeDecl t, Ex<List<FunctionDecl>, Equality> p) {
		return new Type_NamedType(gamma, n, t, p);
	}
	
	private static Type_datatype createType_TupleType(Environment gamma, EList<FieldDecl> fields, Mutually<FieldDecl, Ex<DataType, And<Equality, Type_datatype>>> p1) {
		return new Type_TupleType(gamma, fields, p1);
	}
	
	private static Type_datatype createType_SequenceType(Environment gamma, DataType t, Type_datatype p) {
		return new Type_SequenceType(gamma, t, p);
	}
	
	private static Type_datatype createType_RangeType_trivial(Environment gamma, Expression min, Expression max, Expression_le p1) {
		return new Type_RangeType_trivial(gamma, min, max, p1);
	}
	
	private static Type_datatype createType_BooleanType(Environment gamma) {
		return new Type_BooleanType(gamma);
	}
	
	private static Type_function createType_FunctionDecl_Method(Environment gamma, String dataName, String dataTypeName, DataTypeDecl dataTypeDecl,
			EList<FunctionDecl> dataTypeMethods, String name, EList<FormalParameter> params, Environment gammap,
			DataType rettype, EList<Valuing> vals, Environment gammav, Expression retexpr, DataType tau,
			Environment gamma1, Equality p1, Type_datatype p2,
			Mutually<FormalParameter, Ex<DataType, And<Equality, Type_datatype>>> p3,
			Incrementally<Valuing, Type_valuing> p4, Type_expression p5, Subtype p6, Equality p7) {
		return new Type_FunctionDecl_Method(gamma, dataName, dataTypeName, dataTypeDecl, dataTypeMethods, name, params, gammap, rettype, vals, gammav, retexpr, tau, gamma1, p1, p2, p3, p4, p5, p6, p7);
	}
	
	private static Type_expression_node createType_expression_IntegerValue(Environment gamma, BigInteger v) {
		return new Type_expression_IntegerValue(gamma, v);
	}

	private static Type_expression createType_expression_and_type(Environment gamma, Expression e,
			DataType t, Type_expression_node p1, Type_datatype p2) {
		return new Type_expression_and_type(gamma, e, t, p1, p2);
	}

	private static Expression_le createIn_Z(Expression l, BigInteger zl, Expression r, BigInteger zr, Equality p1, Equality p2, Equality p3) {
		return new In_Z(l, zl, r, zr, p1, p2, p3);
	}
	
	private static Constexpr_expression createConstexpr_IntegerValue(BigInteger v) {
		return new Constexpr_IntegerValue(v);
	}
	
	private static Constexpr_expression createConstexpr_Opposite(Expression e, Constexpr_expression p) {
		return new Constexpr_Opposite(e, p);
	}
	
	private static Constexpr_expression createConstexpr_Same(Expression e, Constexpr_expression p) {
		return new Constexpr_Same(e, p);
	}
	
	private static Constexpr_expression createConstexpr_Add(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Add(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Sub(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Sub(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Mul(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Mul(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Div(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Div(l, r, p1, p2);
	}
	
	private static Constexpr_expression createConstexpr_Mod(Expression l, Expression r, Constexpr_expression p1, Constexpr_expression p2) {
		return new Constexpr_Mod(l, r, p1, p2);
	}
	
	private static <T,P> Incrementally<T,P> createIncrementally_nil(Environment gamma) {
		return new Incrementally_nil<>(gamma);
	}
	
	private static <T,P> Incrementally<T,P> createIncrementally_cons(Environment gamma, T x, Environment gammai, List<T> l, Environment gamma1, P p1, Incrementally<T,P> p2) {
		return new Incrementally_cons<T, P>(gamma, x, gammai, l, gamma1, p1, p2);
	}
	
	private static <T, P> Simple_increment<T,P> createSimple_increment_step(String n, String c, Environment gamma, T x, Environment gamma1,
			Equality p1, P p2) {
		return new Simple_increment_step<>(n, c, gamma, x, gamma1, p1, p2);
	}
	
	private static <T,P> Mutually<T,P> createMutually_all(Environment gamma, List<T> l, Environment gamma1, Equality p1, Equality p2, Forall<T,P> p3) {
		return new Mutually_all<>(gamma, l, gamma1, p1, p2, p3);
	}

	private static <T,P> Mutually<T,P> createMutually_all_explicit(String name, String content, Environment gamma, List<T> l, Environment gamma1, Equality p1, Equality p2, Forall<T,P> p3) {
		return new Mutually_all_explicit<>(name, content, gamma, l, gamma1, p1, p2, p3);
	}
	
	private static <T,P> Optionally<T,P> createOptionally_None(Environment gamma) {
		return new Optionally_None<>(gamma);
	}
	
	private static <T,P> Optionally<T,P> createOptionally_Some(Environment gamma, T x, P p1) {
		return new Optionally_Some<>(gamma, x, p1);
	}
	
	private static <A,B> And<A,B> createConj(A a, B b) {
		return new Conj<>(a, b);
	}
	
	private static <T, P> Ex<T, P> createEx_intro(T t, P p) {
		return new Ex_intro<>(t, p);
	}
	
	private static <T, P> Forall<T,P> createForall_nil() {
		return new Forall_nil<>();
	}

	private static <T, P> Forall<T,P> createForall_cons(T t, P p1, Forall<T,P> p2) {
		return new Forall_cons<>(t, p1, p2);
	}

	private static Equality createReflexivity() {
		return new Eq_refl();
	}
	
	private static RangeType createRangeType(Expression min, Expression max) {
		RangeType r = SosADLFactory.eINSTANCE.createRangeType();
		r.setVmin(min);
		r.setVmax(max);
		return r;
	}
	
	@SuppressWarnings("unused")
	private static RangeType createRangeType(int min, Expression max) {
		return createRangeType(createIntegerValue(min), max);
	}

	@SuppressWarnings("unused")
	private static RangeType createRangeType(Expression min, int max) {
		return createRangeType(min, createIntegerValue(max));
	}

	private static RangeType createRangeType(int min, int max) {
		return createRangeType(createIntegerValue(min), createIntegerValue(max));
	}
	
	private static BooleanType createBooleanType() {
		return SosADLFactory.eINSTANCE.createBooleanType();
	}
	
	private static Expression createIntegerValue(int v) {
		IntegerValue r = SosADLFactory.eINSTANCE.createIntegerValue();
		r.setAbsInt(v);
		return r;
	}
	
	private static Expression createOpposite(Expression e) {
		UnaryExpression r = SosADLFactory.eINSTANCE.createUnaryExpression();
		r.setOp("-");
		r.setRight(e);
		return r;
	}
	
	private static Expression createBinaryExpression(Expression l, String o, Expression r) {
		BinaryExpression ret = SosADLFactory.eINSTANCE.createBinaryExpression();
		ret.setLeft(l);
		ret.setOp(o);
		ret.setRight(r);
		return ret;
	}
	
	private static Type_expression_node createType_expression_Same(Environment gamma, Expression e, DataType tau, Expression min,
			Expression max, Type_expression p1, Subtype p2) {
		return new Type_expression_Same(gamma, e, tau, min, max, p1, p2);
	}
	
	private static Type_expression_node createType_expression_Opposite(Environment gamma, Expression e, DataType tau, Expression min,
			Expression max, Type_expression p1, Subtype p2) {
		return new Type_expression_Opposite(gamma, e, tau, min, max, p1, p2);
	}
	
	private static Type_expression_node createType_expression_Not(Environment gamma, Expression e, DataType tau, Type_expression p1, Subtype p2) {
		return new Type_expression_Not(gamma, e, tau, p1, p2);
	}
	
	private static Type_expression_node createType_expression_Add(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Add(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Sub(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Sub(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Mul(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Expression min, Expression max,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4, Expression_le p5, Expression_le p6,
			Expression_le p7, Expression_le p8, Expression_le p9, Expression_le pa, Expression_le pb,
			Expression_le pc) {
		return new Type_expression_Mul(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, min, max, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc);
	}
	
	private static Type_expression_node createType_expression_Div_pos(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Expression min, Expression max,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4, Expression_le p5, Expression_le p6,
			Expression_le p7, Expression_le p8, Expression_le p9, Expression_le pa, Expression_le pb,
			Expression_le pc, Expression_le pd) {
		return new Type_expression_Div_pos(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, min, max, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd);
	}
	
	private static Type_expression_node createType_expression_Div_neg(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Expression min, Expression max,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4, Expression_le p5, Expression_le p6,
			Expression_le p7, Expression_le p8, Expression_le p9, Expression_le pa, Expression_le pb,
			Expression_le pc, Expression_le pd) {
		return new Type_expression_Div_neg(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, min, max, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd);
	}

	private static Type_expression_node createType_expression_Mod(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Expression min, Expression max,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4, Range_modulo_min p5, Range_modulo_max p6) {
		return new Type_expression_Mod(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, min, max, p1, p2, p3, p4, p5, p6);
	}
	
	private static Type_expression_node createType_expression_Implies(Environment gamma, Expression l, DataType l__tau, Expression r, DataType r__tau,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4) {
		return new Type_expression_Implies(gamma, l, l__tau, r, r__tau, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Or(Environment gamma, Expression l, DataType l__tau, Expression r, DataType r__tau,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4) {
		return new Type_expression_Or(gamma, l, l__tau, r, r__tau, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Xor(Environment gamma, Expression l, DataType l__tau, Expression r, DataType r__tau,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4) {
		return new Type_expression_Xor(gamma, l, l__tau, r, r__tau, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_And(Environment gamma, Expression l, DataType l__tau, Expression r, DataType r__tau,
			Type_expression p1, Subtype p2, Type_expression p3, Subtype p4) {
		return new Type_expression_And(gamma, l, l__tau, r, r__tau, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Equal(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Equal(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Diff(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Diff(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Lt(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Lt(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Le(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Le(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Gt(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Gt(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Type_expression_node createType_expression_Ge(Environment gamma, Expression l, DataType l__tau, Expression l__min, Expression l__max,
			Expression r, DataType r__tau, Expression r__min, Expression r__max, Type_expression p1, Subtype p2,
			Type_expression p3, Subtype p4) {
		return new Type_expression_Ge(gamma, l, l__tau, l__min, l__max, r, r__tau, r__min, r__max, p1, p2, p3, p4);
	}
	
	private static Range_modulo_min createRange_modulo_min_pos(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Expression min, Expression_le p1,
			Expression_le p2) {
		return new Range_modulo_min_pos(lmin, lmax, rmin, rmax, min, p1, p2);
	}
	
	private static Range_modulo_min createRange_modulo_min_zero(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Expression min, Expression_le p1,
			Expression_le p2) {
		return new Range_modulo_min_zero(lmin, lmax, rmin, rmax, min, p1, p2);
	}
	
	private static Range_modulo_min createRange_modulo_min_neg(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Expression min, Expression_le p1,
			Expression_le p2) {
		return new Range_modulo_min_neg(lmin, lmax, rmin, rmax, min, p1, p2);
	}

	private static Range_modulo_max createRange_modulo_max_pos(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Expression min, Expression_le p1,
			Expression_le p2) {
		return new Range_modulo_max_pos(lmin, lmax, rmin, rmax, min, p1, p2);
	}
	
	private static Range_modulo_max createRange_modulo_max_zero(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Expression min, Expression_le p1,
			Expression_le p2) {
		return new Range_modulo_max_zero(lmin, lmax, rmin, rmax, min, p1, p2);
	}
	
	private static Range_modulo_max createRange_modulo_max_neg(Expression lmin, Expression lmax, Expression rmin, Expression rmax, Expression min, Expression_le p1,
			Expression_le p2) {
		return new Range_modulo_max_neg(lmin, lmax, rmin, rmax, min, p1, p2);
	}

	private static Subtype createSubtype_refl(Environment gamma, DataType t) {
		return new Subtype_refl(gamma, t);
	}

	private static Subtype createSubtype_unfold_left(Environment gamma, String l, DataType def,
			EList<FunctionDecl> funs, EList<FunctionDecl> methods, DataType r, Equality p1,
			Subtype p2) {
		return new Subtype_unfold_left(gamma, l, def, funs, methods, r, p1, p2);
	}
}
