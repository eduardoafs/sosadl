/*
 * generated by Xtext
 */
package org.archware.sosadl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.archware.sosadl.sosADL.*
import org.archware.sosadl.SosADLStandaloneSetupGenerated
import org.eclipse.emf.common.util.URI
import org.archware.sosadl.SosADLComparator
import org.eclipse.xtext.parser.IParser
import java.io.StringReader
import java.util.LinkedHashMap
import java.util.Map.Entry
import java.util.ArrayList
import java.util.List
import java.lang.System

//import org.archware.iosts.ui.contentassist.AbstractIoSTSProposalProvider

/**
 * Generates IOSTS code from the given SosADL model files on save.
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class SosADL2IOSTSGenerator implements IGenerator {
    
    val DEBUG=false
    val DEBUG2=false
    val DEBUG3=false
    
    // global variables making the generation much easier
    var String resourceFilename = null          // current SoSADL file name to be transformed
    var LinkedHashMap<String,String> globalConstantsMap = newLinkedHashMap()
    var LinkedHashMap<String,IOstsType> globalTypesMap = newLinkedHashMap()     // map of (types -> typeDecl)
    var List<IOstsSystem> systems = null       // list of generated systems from one SoSADL file
    var IOstsSystem currentSystem = null       // system currently generated
    var IOstsProcess currentProcess = null           // process currently generated
    var lastIOstsTypeNum = 0
    
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		for (e : resource.allContents.toIterable.filter(SosADL)) {
		    var first=true
		    resourceFilename = e.eResource.URI.trimFileExtension.lastSegment
            System.out.print("Transforming '"+e.eResource.URI.lastSegment+"'")
            systems = newLinkedList()
            e.compile
            if (systems.empty) {
                System.out.println(" into nothing! Found no behavior, no protocol!")
            } else {
                if (DEBUG) System.out.println("--------- "+e.eResource.URI.lastSegment+" (starts) ----")
                for (s:systems) {
                    if (DEBUG) {
                        System.out.println("----> "+s.fileName+" (starts) ----")
                        System.out.println(s.toString)
                    }
                    else {
                        System.out.print((if (first) " into: " else ", ")+"'"+s.fileName+"'")
                        first=false
                    }
                    fsa.generateFile(s.fileName, s.toString)
                    if (DEBUG) System.out.println("----> "+s.fileName+" (ends) ------")
                }
                if (DEBUG) System.out.println("--------- "+e.eResource.URI.lastSegment+" (ends) ------")
                else System.out.println(". done.")
            }
		}
	}
    
	def compile(SosADL s) {
	globalConstantsMap = newLinkedHashMap()
	globalTypesMap = newLinkedHashMap()
	lastIOstsTypeNum = 0
	'''
    «FOR i : s.imports»
      «i.compile»
    «ENDFOR»

    «IF s.content instanceof Library»
      «(s.content as Library).compile»
    «ELSEIF s.content instanceof SoS»
      «(s.content as SoS).compile»
    «ENDIF»
	'''
	}
	

	def compile(Import i)'''
	'''

	def compile(Library l)'''
    «l.decls.compile»
    '''

	def compile(SoS s)'''
    «s.decls.compile»
    '''

	def compile(EntityBlock e) {
        for (d : e.datatypes) {
          d.compile
        }
        /*
        for (f : e.functions) {
          f.compile
        }
        */
        for (s : e.systems) {
          s.compile
        }
        for (m : e.mediators) {
          m.compile
        }
        for (a : e.architectures) {
          a.compile
        }
	''''''
	}

	def compile(SystemDecl s){
	  currentSystem = new IOstsSystem(s.name)
	  currentSystem.constantsMap.putAll(globalConstantsMap)
	  currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+s.name+".iosts")
	  s.parameters.map[compile]
	  for (d : s.datatypes) {
        d.compile
      }
      for (g : s.gates) {
        g.compile
      }
      //if (s.assertion != null) {s.assertion.compile}  // not a protocol?
      s.behavior.compile
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }

	def compile(ArchitectureDecl a){
	  currentSystem = new IOstsSystem(a.name)
      currentSystem.constantsMap.putAll(globalConstantsMap)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+a.name+".iosts")
      a.parameters.map[compile]
      for (d : a.datatypes) {d.compile}
      for (g : a.gates) {g.compile}
      a.behavior.compile
      //if (a.assertion != null) {a.assertion.compile} // not a protocol?
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }

    def compile(MediatorDecl m){
      currentSystem = new IOstsSystem(m.name)
      currentSystem.constantsMap.putAll(globalConstantsMap)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+m.name+".iosts")
      m.parameters.map[compile]
      for (d : m.datatypes) {
        d.compile
      }
      for (d : m.duties) {
        d.compile
      }
      //if (m.assertion != null) {m.assertion.compile}  // not a protocol?
      m.behavior.compile
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }
	
	def compile(GateDecl g){
	    for (c : g.connections) {
	        val name=g.name+"_"+c.name
	        val IOstsType type = computeIOstsType(c.valueType)
	        val typeName = nameOfIOstsType(type)
	        registerIOstsType(typeName, type)
	        val finalTypeName = finalNameOfIOstsType(typeName)
	        //currentSystem.addGate(new IOstsGate(name, computeIOstsType(c.valueType), c.mode.toString))
	        currentSystem.addGate(new IOstsGate(name, finalTypeName, c.mode.toString))
	    }
	    '''«g.protocol.compile»'''
	}

	
	def compile(DutyDecl d){
        for (c : d.connections) {
            val name=d.name+"_"+c.name
            val IOstsType type = computeIOstsType(c.valueType)
            val typeName = nameOfIOstsType(type)
            registerIOstsType(typeName, type)
            val finalTypeName = finalNameOfIOstsType(typeName)
            //currentSystem.addGate(new IOstsGate(name, computeIOstsType(c.valueType), c.mode.toString))
            currentSystem.addGate(new IOstsGate(name, finalTypeName, c.mode.toString))
        }
        '''«d.protocol.compile»'''
    }
	
	/*
	def compile(Connection c)'''«IF c.environment»environment «ENDIF»connection «c.name» is «c.mode»{«c.valueType.compile»}'''
	*/
	
	def compile(AssertionDecl a)''''''
    
    def compile(ProtocolDecl p) {
        currentProcess = new IOstsProcess(p.name+"_protocol")
        computeSTS(0,p.body)
        currentSystem.addProcess(currentProcess)
        '''«p.toString»'''
    }
    
    def CharSequence compile(Protocol p)''''''
	
	def compile(ProtocolStatement p)''''''
	
	def compile(IfThenElseProtocol i)''''''
	
	def compile(ChooseProtocol c)''''''
	
	def compile(ForEachProtocol f)''''''
	
	def compile(DoExpr d)'''
    do «d.expression.compile»
	'''
	
	def compile(RepeatProtocol r)'''''' 
	
	def compile(Done d)''''''  // nothing = no STS to be generated
	    
    def compile(ProtocolAction p)''''''
    
    def compile(SendProtocolAction s)''''''
    
    def compile(ReceiveAnyProtocolAction r)''''''
    
    def compile(ReceiveProtocolAction r)''''''
    
    def compile(AnyAction a)''''''
    
    def compile(BehaviorDecl b){
        //if (currentProcess != null) currentSystem.addProcess(currentProcess)
        currentProcess = new IOstsProcess(b.name+"_behavior")
        computeSTS(0,b.body)
        currentSystem.addProcess(currentProcess)
        ''''''
    }
    
    /*
     * All computeSTS() functions return the final states of the STS
     * according to the behavior starting at startState.
     */
    /*
     * - computeSTS for a Behavior (which is a sequence of BehaviorStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Behavior b) {
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        for (s : b.statements) {
            // in a sequence, one has to add a transition with no action between two statements
            if (first && (s instanceof Action) && startState==0 && state==0) {
                //System.out.println("Preparing empty transition, because sync is not allowed in first transition": from="+state+", to="+state)
                finalStates = newArrayList(0)
                first=false
            }
            if (! first) {
                state=currentProcess.newState()
                var i=0
                while (i < finalStates.length) {
                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
                    concatenation.setComment("Concatenation (sequentiality)")
                    currentProcess.addTransition(concatenation)
                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
                    i = i+1
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            finalStates = computeSTS(state, s)
            first=false
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Protocol (which is a sequence of ProtocolStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Protocol b){
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        for (s : b.statements) {
            // in a sequence, one has to add a transition with no action between two statements
            if (first && (s instanceof ProtocolAction) && startState==0 && state==0) {
                //System.out.println("Preparing empty transition, because sync is not allowed in first transition": from="+state+", to="+state)
                finalStates = newArrayList(0)
                first=false
            }
            if (! first) {
                state=currentProcess.newState()
                var i=0
                while (i < finalStates.length) {
                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
                    concatenation.setComment("Concatenation (sequentiality)")
                    currentProcess.addTransition(concatenation)
                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
                    i = i+1
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            finalStates = computeSTS(state, s)
            first=false
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Valuing statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Valuing v){
        val int final=currentProcess.newState()
        var IOstsTransition valuing = new IOstsTransition(startState,final)
        valuing.addStatement(v.compile.toString)
        valuing.setComment("Valuing")
        currentProcess.addTransition(valuing)
        //System.out.println("Added valuing transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Send/Receive Behavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Action a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        val IOstsGate gate=currentSystem.gatesMap.get(channel)
        if (gate == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared! Ignoring statement...")
        } else if (a.suite instanceof SendAction) {
            val parameter=currentProcess.newParameter()
            if (gate.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, gate.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput gates")
                }
                channel = channel.concat("_out")
            }
            if (! currentProcess.outputMap.containsKey(channel)) {
                currentProcess.addOutput(channel, gate.typeName)
                if (DEBUG2) System.out.println("Added channel '"+channel+"' to output gates")
            }
            action.setGuard(parameter+" = "+(a.suite as SendAction).expression.compile)
            action.setAction(channel+"!("+parameter+")")
            action.setComment("Send action")
            currentProcess.addParameter(parameter,gate.typeName)
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAction) {
            val variable=(a.suite as ReceiveAction).variable
            val parameter=variable+"_data"
            if (gate.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, gate.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput gates")
                }
                channel = channel.concat("_in")
            }
            if (! currentProcess.inputMap.containsKey(channel)) {
                currentProcess.addInput(channel, gate.typeName)
                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input gates")
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, gate.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, gate.typeName)
            }
            action.setAction(channel+"?("+parameter+")")
            action.addStatement(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }

    /*
     * - computeSTS for a Send/Receive Protocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ProtocolAction a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        val IOstsGate gate=currentSystem.gatesMap.get(channel)
        if (gate == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared! Ignoring statement...")
        } else if (a.suite instanceof SendProtocolAction) {
            val parameter=currentProcess.newParameter()
            if (gate.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, gate.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput gates")
                }
                channel = channel.concat("_out")
            }
            if (! currentProcess.inputMap.containsKey(channel)) {
                currentProcess.addOutput(channel, gate.typeName)
                if (DEBUG2) System.out.println("Added channel '"+channel+"' to output gates")
            }
            if ((a.suite as SendProtocolAction).expression.compile.toString == "any") {
                /* FIXME: send any:
                 * - option 1 "pas de if": ANY_typeConnection est une constante qui doit etre definie
                 *     action.setAction(channel+"!(ANY_typeConnection)")
                 *     currentProcess.addParameter(parameter,gate.typeName)
                 * - option 2 "avec if en affectant au parametre une constante ANY_typeConnection" (au hasard?)
                 *     action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                 *     action.setAction(channel+"!("+parameter+")")
                 *     currentProcess.addParameter(parameter,gate.typeName)
                 */
                // send any: no guard (thus not parameter) and send a random expression compatible with type of connection
                action.setGuard(parameter+" = 0  //FIXME: 0 should be an expression of parameter's type")
                action.setAction(channel+"!("+parameter+")")
                currentProcess.addParameter(parameter,gate.typeName)
                action.setComment("Send any action")
            } else {
                // send some expression
                action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                action.setAction(channel+"!("+parameter+")")
                currentProcess.addParameter(parameter,gate.typeName)
                action.setComment("Send action")
            }
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveProtocolAction) { 
            val variable=(a.suite as ReceiveProtocolAction).variable
            val parameter=variable+"_data"
            if (gate.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, gate.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput gates")
                }
                channel = channel.concat("_in")
            }
            if (! currentProcess.inputMap.containsKey(channel)) {
                currentProcess.addInput(channel, gate.typeName)
                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input gates")
            }
            
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, gate.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, gate.typeName)
            }
            action.setAction(channel+"?("+parameter+")")
            action.addStatement(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAnyProtocolAction) {
            val variable="any_s"+startState
            val parameter=variable+"_data"
            if (gate.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, gate.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput gates")
                }
                channel = channel.concat("_in")
            }
            if (! currentProcess.inputMap.containsKey(channel)) {
                currentProcess.addInput(channel, gate.typeName)
                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input gates")
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, gate.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, gate.typeName)
            }
            action.setAction(channel+"?("+parameter+")")
            action.addStatement(variable+" := "+parameter)
            action.setComment("Receive any action")
            //System.out.println("Added receive any transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment("IfThenElse (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment("IfThenElse (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }

    /*
     * - computeSTS for a IfThenElseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment("IfThenElse (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment("IfThenElse (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    
    /*
     * - computeSTS for a ChooseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseBehavior c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }

    /*
     * - computeSTS for a ChooseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseProtocol c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }
        
    /*
     * - computeSTS for a RepeatBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatBehavior r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        newArrayList(startState) 
    }

    /*
     * - computeSTS for a RepeatProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatProtocol r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        newArrayList(startState) 
    }
        
    /*
     * - computeSTS for a Assert statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Assert r){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition assert = new IOstsTransition(startState,final)
        assert.setComment("TODO! Assert")
        currentProcess.addTransition(assert)
        //System.out.println("Added fake assert transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a ForEachBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachBehavior r){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition foreach = new IOstsTransition(startState,final)
        foreach.setComment("TODO! ForEachBehavior")
        currentProcess.addTransition(foreach)
        //System.out.println("Added fake foreach transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a ForEachProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachProtocol r){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition foreach = new IOstsTransition(startState,final)
        foreach.setComment("TODO! ForEachProtocol")
        currentProcess.addTransition(foreach)
        //System.out.println("Added fake foreach transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a DoExpr statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, DoExpr r){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition doExpr = new IOstsTransition(startState,final)
        doExpr.setComment("TODO! DoExpr")
        currentProcess.addTransition(doExpr)
        //System.out.println("Added fake DoExpr transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for an AnyAction statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AnyAction a){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition anyAction = new IOstsTransition(startState,final)
        anyAction.setComment("TODO! AnyAction")
        currentProcess.addTransition(anyAction)
        //System.out.println("Added fake anyAction transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Done statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Done r){
        // do nothing!
        newArrayList(startState)
    }
    
    /*
     * - computeSTS for a RecursiveCall statement.
     *   same as Repeat of entire Behavior: loop to initial state
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RecursiveCall r){
        if (startState != 0) {
            var IOstsTransition t = new IOstsTransition(startState,0)
            t.setComment("Recursive call")
            currentProcess.addTransition(t)
            newArrayList(0) 
        }
    }
        
	def compile(ArchBehaviorDecl a)''''''
	
	def compile(Constituent c)''''''

    def compile(Binding b)''''''
    
    def compile(Relay r)''''''

	def compile(Unify u)''''''

	def compile(Quantify q)''''''
	
	def compile(ElementInConstituent e)''''''
	
	def getIOstsType(String name) {
	    if (currentSystem != null) {
            if (currentSystem.typesMap.containsKey(name)) {
                currentSystem.typesMap.get(name)
            } else {
                null
            }
        } else if (globalTypesMap.containsKey(name)) {
            globalTypesMap.get(name)
        } else {
            null
        }
	}
	
	def finalNameOfIOstsType(String name) {
	    val IOstsType t = getIOstsType(name)
	    val finalName = if (t == null) {
	        if (DEBUG2) System.err.println("Warning: type '"+name+"' not found! Assuming int...")
	        (new IOstsIntType()).toString
	    } else switch t {
	        IOstsIntType: t.toString
	        IOstsBoolType: t.toString
	        default: name
	    }
	    if (DEBUG2) System.out.println("Final type name '"+name+"' = '"+finalName+"'.")
	    finalName
	}
	
	def registerIOstsType(String name, IOstsType type) {
	    if (currentSystem != null) {
            if (currentSystem.typesMap.containsKey(name)) {
                if (DEBUG2) System.err.println("Warning: system type '"+name+"' already declared! Overriding...")
            }
            currentSystem.typesMap.put(name,type)
        } else {
            if (globalTypesMap.containsKey(name)) {
                if (DEBUG2) System.err.println("Warning: global type '"+name+"' already declared! Overriding...")
            }
            // the datatype declaration here occurs before the system/mediator/architecture declaration
            globalTypesMap.put(name,type)
        }
	}
	
	def nameOfIOstsType(IOstsType type) {
	    var name=""
	    if (currentSystem != null) {
            for (t:currentSystem.typesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
            if (name == "") {
                name=newIOstsTypeName()
                currentSystem.typesMap.put(name,type)
            }
        } else {
            for (t:globalTypesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
            if (name == "") {
                name=newIOstsTypeName()
                globalTypesMap.put(name,type)
            }
        }
        name
	}
	
	def dispatch IOstsType computeIOstsType(DataTypeDecl d) {
	    var IOstsType t = null
	    if (d.datatype == null)
	       t=new IOstsIntType()
        else
           t=computeIOstsType(d.datatype)
	    registerIOstsType(d.name, t)
	    t
	}
	
	
	def dispatch IOstsType computeIOstsType(DataType t) {
	    switch t {
	        IntegerType: computeIOstsType(t)
	        SequenceType: computeIOstsType(t)
	        TupleType: computeIOstsType(t)
	        RangeType: computeIOstsType(t)
	        NamedType: computeIOstsType(t)
	        default: {
	            System.err.println("BUG! computeIOstsType of this datatype '"+t.toString+"' is not implemented! Assuming 'int'...")
                new IOstsIntType()
	        }
	    }
	}
	
	
	def dispatch IOstsType computeIOstsType(IntegerType t) {
        new IOstsIntType()
    }
    
	def dispatch IOstsType computeIOstsType(SequenceType t) {
        // TODO: a relire et a tester !!!
        var LinkedHashMap<String,IOstsType> fieldsMap=newLinkedHashMap()
        var String typeName = nameOfIOstsType(computeIOstsType(t.type))
        var String arrayName="Array_Of_"+typeName
        fieldsMap.put("length", new IOstsIntType())
        registerIOstsType(arrayName, new IOstsArrayType(1000, new IOstsNamedType(typeName)))
        fieldsMap.put("content", new IOstsNamedType(arrayName))
        var IOstsType record = new IOstsRecordType(fieldsMap)
        record.setComment("sequence{"+typeName+"}")
        record
    }
	
	def dispatch IOstsType computeIOstsType(TupleType t) {
        var LinkedHashMap<String,IOstsType> fieldsMap=newLinkedHashMap()
        var comment="tuple{"
        var first=true
        for (f:(t as TupleType).fields) {
            val tn=f.type.compile.toString
            val _tt=computeIOstsType(f.type)
            val IOstsType tt = if (_tt instanceof IOstsIntType || _tt instanceof IOstsBoolType) _tt else new IOstsNamedType(tn)
            fieldsMap.put(f.name, tt)
            comment=comment.concat((if (first) "" else ",")+f.name+":"+tn)
            first=false
        }
        comment=comment.concat("}")
        var record=new IOstsRecordType(fieldsMap)
        record.setComment(comment)
        record
    }
    
    def dispatch IOstsType computeIOstsType(RangeType t) {
        //FIXME: min et max peuvent etre des constantes au lieu de nombres
        val int min=Integer.valueOf(t.vmin.compile.toString)
        val int max=Integer.valueOf(t.vmax.compile.toString)
        new IOstsRangeType(min, max)
    }
    
    def dispatch IOstsType computeIOstsType(NamedType t) {
        var IOstsType tt = if (currentSystem != null) currentSystem.typesMap.get(t.name)
                           else globalTypesMap.get(t.name)
        if (tt == null) {
            System.err.println("Warning! type '"+t.name+"' is not declared! Assuming 'int'...")
            tt=new IOstsIntType()
        }
        tt
    }
    
	
	def compile(DataTypeDecl d){
        var IOstsType t
        if (d.datatype == null) {
            if (DEBUG2) System.err.println("Warning! type definition of '"+d.name+"' null! Assuming 'int'...")
            t=new IOstsIntType()
        }
        else {
            t=computeIOstsType(d.datatype)
        }
        if (currentSystem != null) {
            currentSystem.typesMap.put(d.name,t)
        } else {
            // this datatype declaration occurs before the system/mediator/architecture declaration
            globalTypesMap.put(d.name,t)
        }
        ''''''
    }
    
	def CharSequence compile(DataType d)'''«
	IF d instanceof IntegerType»«
	  (d as IntegerType).compile»«
    ELSEIF d instanceof TupleType»«
      (d as TupleType).compile»«
    ELSEIF d instanceof SequenceType»«
      (d as SequenceType).compile»«
    ELSEIF d instanceof RangeType»range «(d as RangeType).vmin.compile»..«(d as RangeType).vmax.compile»«
    ELSEIF d instanceof ConnectionType»«
      (d as ConnectionType).mode.compile»{«(d as ConnectionType).type.compile»}«
    ELSEIF d instanceof NamedType»«
      (d as NamedType).compile»«
    ENDIF»'''
    /**/
	
	def compile(FunctionDecl f)'''
      function («f.dataName»:«f.dataTypeName»)::«f.name»(«f.parameters.map[compile].join(", ")»):«f.type.compile» is {
        «FOR v:f.valuing»
        «v.compile»
        «ENDFOR»
        return «f.expression.compile»
      }
	'''
	

	def compile(FormalParameter p)'''  «p.name» : «p.type.compile»'''
	
	def compile(IntegerType t)'''int'''
	
	def compile(TupleType t)'''record «t.fields.map[compile].join("; ")»; end'''
	
	def compile(FieldDecl f)'''«f.name»:«f.type.compile»'''
	
	// TODO! define the size of the array!
	def compile(SequenceType s)'''array [1000] of «s.type.compile»'''
	
	def compile(ModeType m)'''«m.literal»'''
	
	def compile(NamedType t) {
	    val type = if (currentSystem != null) currentSystem.typesMap.get(t.name)
                   else globalTypesMap.get(t.name)
	    '''«IF type == "int"»int3«ELSE»«t.name»«ENDIF»'''
	}

    def compile(ComplexName c)'''«IF c.name != null»«c.name.join("_")»«ENDIF»'''
    
	def compile(Valuing v){
	  if (v.type == null)
	      currentProcess.addVariable(v.variable)
	  else {
	      val type = computeIOstsType(v.type)
	      val typeName = nameOfIOstsType(type)
	      registerIOstsType(typeName, type)
	      currentProcess.addVariable(v.variable, finalNameOfIOstsType(typeName))  
	  }
	  '''«v.variable» := «v.expression.compile»'''
	}
	
	def compile(IntegerValue i)'''«i.absInt»'''
	
	def compile(Any a)'''any'''
	
	def compile(ConstructedValue c)'''«
      IF c instanceof Tuple»«
        (c as Tuple).compile»«
      ELSEIF c instanceof Sequence»«
        (c as Sequence).compile»«
      ENDIF»'''
	
	def compile(Tuple t)'''tuple{«t.elements.map[compile].join(", ")»}'''
	
	def compile(TupleElement t)'''«t.label»=«t.value.compile»'''
	
	def compile(Sequence s)'''sequence{«s.elements.map[compile].join(", ")»}'''

    def compile(Expression e)'''«
	IF e instanceof BinaryExpression»«(e as BinaryExpression).compile»«
	ELSEIF e instanceof UnaryExpression»«(e as UnaryExpression).compile»«
	ELSEIF e instanceof Binding»«(e as Binding).compile»«
	ELSEIF e instanceof CallExpression»«(e as CallExpression).compile»«
	ELSEIF e instanceof IdentExpression»«(e as IdentExpression).compile»«
	ELSEIF e instanceof UnobservableValue»«(e as UnobservableValue).compile»«
	ELSEIF e instanceof Any»«(e as Any).compile»«
    ELSEIF e instanceof Tuple»«(e as Tuple).compile»«
    ELSEIF e instanceof Sequence»«(e as Sequence).compile»«
    ELSEIF e instanceof IntegerValue»«(e as IntegerValue).compile»«
    ELSEIF e instanceof Field»«(e as Field).compile»«
    ELSEIF e instanceof Select»«(e as Select).compile»«
    ELSEIF e instanceof Map»«(e as Map).compile»«
    ELSEIF e instanceof MethodCall»«(e as MethodCall).compile»«
	ENDIF»'''
	
	def CharSequence compile(BinaryExpression e) {
        switch e.op {
            case "implies" : "not "+compileAndBracket(e.left)+" or "+compileAndBracket(e.right)
            case "xor" : "("+compileAndBracket(e.left)+" and not "+compileAndBracket(e.right)+") or (not "+compileAndBracket(e.left)+" and "+compileAndBracket(e.right)+")"
            case "div" : compileAndBracket(e.left)+" / "+compileAndBracket(e.right)
            case "mod" : compileAndBracket(e.left)+" % "+compileAndBracket(e.right)
            default: compileAndBracket(e.left)+e.op+compileAndBracket(e.right)
        }
    }
    
    def compileAndBracket(Expression e) {
        switch e {
            BinaryExpression: "("+e.compile+")"
            UnaryExpression: "("+e.compile+")"
            default: e.compile
        }
    }
    
    def compile(IdentExpression e)'''«e.ident»'''
    
    def compile(UnobservableValue u)'''unobservable'''
    
    def compile(Field e)'''«e.object.compile».«(e as Field).field»'''
	
	def compile(CallExpression e)'''«
	e.function»(«e.parameters.map[compile].join(", ")»)'''
	
	def compile(Select e)'''«
	e.object.compile».select(«e.variable» suchthat «e.condition.compile»)'''

	def compile(Map e)'''«
	e.object.compile».collect(«e.variable» suchthat «e.expression.compile»)'''

	def compile(MethodCall e)'''«
	e.object.compile».«e.method»(«e.parameters.map[compile].join(", ")»)'''
	
    def compile(UnaryExpression u)''' «u.op» «u.right.compile»'''
    
    /*
    def CharSequence compile(Assertion a)'''«
	IF a instanceof BinaryAssertion»«(a as BinaryAssertion).compile»«
	ELSEIF a instanceof UnaryAssertion» «(a as UnaryAssertion).op» «(a as UnaryAssertion).right.compile»«
	ELSEIF a instanceof Expression»«(a as Expression).compile»«
	ELSEIF a instanceof Always»«(a as Always).compile»«
	ELSEIF a instanceof Anynext»«(a as Anynext).compile»«
	ELSEIF a instanceof Action»«(a as Action).compile»«
	ENDIF»'''
	
	def CharSequence compile(BinaryAssertion a) {
	    switch a.op {
            case "implies" : "not ("+a.left.compile+") or ("+a.right.compile+")"
            case "xor" : "(("+a.left.compile+") and not ("+a.right.compile+")) or ((not "+a.left.compile+") and ("+a.right.compile+"))"
            case "div" : "("+a.left.compile+") / ("+a.right.compile+")"
            case "mod" : "("+a.left.compile+") % ("+a.right.compile+")"
            default: "("+a.left.compile+")"+a.op+"("+a.right.compile+")"
        }
	}
	
    def compile(UnaryAssertion u)'''«u.op»«u.right.compile»'''
    
    def compile(Always a)'''always(«a.expression.compile»)'''
    
    def compile(Anynext a)'''anynext(«a.expression.compile»)'''
    */
    
    /*
     * TypeName generator: returns a new unused type id
     */
    def String newIOstsTypeName() {
        this.lastIOstsTypeNum = this.lastIOstsTypeNum+1
        lastIOstsTypeName()
    }
    
    def String lastIOstsTypeName() {
        "Type_"+this.lastIOstsTypeNum
    }
}

//-------------- Types


    
/*
 * Type: is the superclass of all types.
 */
class IOstsType {
    var String comment=""
    
    def setComment(String comment) {
        this.comment = comment
    }
   
    def comment() {
        this.comment
    }
    
    def boolean equals (IOstsType other) {
        switch other {
            IOstsIntType: this.equals(other)
            IOstsBoolType: this.equals(other)
            IOstsRangeType: this.equals(other)
            IOstsRecordType: this.equals(other)
            IOstsArrayType: this.equals(other)
            IOstsNamedType: this.equals(other)
            default: this.equals(other)
        }
    }
}

class IOstsIntType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "int"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsIntType)
    }

}

class IOstsBoolType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "bool"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsBoolType)
    }
}

class IOstsRangeType extends IOstsType {
    
    int min
    int max
    
    // private thus inaccessible, because one cannot create range without min and max values
    private new() {
        min = 0
        max = 0
    }
    
    new(int min, int max) {
        this.min = min
        this.max = max
    }
    
    def min() {
        this.min
    }
    
    def max() {
        this.max
    }
    
    override def String toString() {
        "range "+min+".."+max
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsRangeType) {
            (other.min == min) && (other.max == max)
        } else {
            false
        }
    }
}


class IOstsRecordType extends IOstsType {
    
    public val LinkedHashMap<String,IOstsType> fieldsMap   // map of (name -> type)
    
    // private thus inaccessible, because one cannot create record without fields
    private new() {
        fieldsMap = newLinkedHashMap() 
    }
    
    new(LinkedHashMap<String,IOstsType> listOfFields) {
        fieldsMap = listOfFields
    }
    
    override def String toString() {
        var String inner=""
        for (f:fieldsMap.entrySet) {
            inner = inner.concat(f.key+":"+f.value.toString+"; ")
        }
        "record "+inner+" end"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsRecordType) {
            if (other.fieldsMap.size != fieldsMap.size)
                false
            else {
                var boolean ok1=true
                val size=this.fieldsMap.size
                val ArrayList<Entry<String,IOstsType>> fields1 = newArrayList(this.fieldsMap.entrySet)
                val ArrayList<Entry<String,IOstsType>> fields2 = newArrayList(other.fieldsMap.entrySet)
                var i=0
                while(i < size) {
                    val ok2 = ((fields1.get(i).key == fields2.get(i).key) && (fields1.get(i).value.equals(fields2.get(i).value)))
                    ok1 = (ok1 && ok2)
                    i = i+1
                }
                ok1
            }
        } else false
    }
}

class IOstsArrayType extends IOstsType {
    
    val int size
    val IOstsType type
    
    // private thus inaccessible, because one cannot create array without size
    private new() {
        size = 0
        type = new IOstsIntType()
    }
    
    new(int size, IOstsType type) {
        this.size = size
        this.type = type
    }
    
    override def String toString() {
        "array["+size+"] of "+type.toString
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsArrayType) {
            if (other.size != size) {
                false
            } else {
                other.type.equals(type)
            }
        } else {
            false
        }
    }
}

class IOstsNamedType extends IOstsType {
    
    val String name
    
    new(String name) {
        this.name = name
    }
    
    override def String toString() {
        name
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsNamedType) {
            other.name == name
        } else {
            false
        }
    }
}

//-------------- Gate, Transition, Process and IOstsSystem

/*
 * Gate
 * 
 * Notes:
 * - name, type, and mode are required at creation time, and immutable.
 * - a gate in IOSTS is a connection (not a *gate*) in SoS-ADL.
 * - the mode's gate in IOSTS can be 'in' or 'out'.
 * - if an SOS-ADL connection is 'inout', one has to implement two gates in IOSTS:
 *   one 'in', and one 'out'. 
 */
class IOstsGate {
    val String name
    val String typeName
    val String mode // FIXME! enum au lieu de string!
    
    new(String name, String typeName, String mode) {
        this.name=name
        this.typeName=typeName
        this.mode=mode
    }
    
    def name() {
        this.name
    }
    
    def typeName() {
        this.typeName 
    }
    
    def mode() {
        this.mode
    }
    
    override def String toString() {
        switch mode {
            case "in":
                "  "+name+"("+typeName+"); // "+mode+"\n"
            case "out":
                "  "+name+"("+typeName+"); // "+mode+"\n"
            case "inout":
                "  "+name+"_in("+typeName+");  // "+mode+"\n"+
                "  "+name+"_out("+typeName+"); // "+mode+"\n"
        } 
    }
    
}


/*
 * A IOstsTransition
 * 
 * Note:
 * - fromState and toState are immutable and must be set at creation time.
 * - guard and statements are optional, thus mutable.
 * - action is mutable thought it is required (tau by default):
 *   this is because it can be initialized after creation.
 *   Note: in the first transition, no sync is allowed.
 * - a comment helps to understand the transformation from SoDADL to IOSTS
 */
class IOstsTransition {
   val int fromState
   val int toState
   String comment=""
   String guard=""  // optional
   String action="tau"  // default action is tau
   List<String> statements = newArrayList  // optional
   
   new(int fromState, int toState, String action) {
       this.fromState=fromState
       this.toState=toState
       this.action=action
   }
   
   new(int fromState, int toState) {
       this.fromState=fromState
       this.toState=toState
   }
   
   def setComment(String comment) {
       this.comment = comment
   }
   
   def setGuard(String guard) {
       this.guard = guard
   }
   
   def setAction(String action) {
       this.action = action
   }
   
   def addStatement(String statement) {
       statements.add(statement)
   }
   
   override def String toString() {
     /*
      Shall we generate "sync" when fromState==0? 
      If not, replace:
        sync «action»
      with:
        «IF fromState != 0»
        sync «action»
        «ENDIF»
      */
     '''
     
       from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
         «IF !guard.empty»
         if «guard»
         «ENDIF»
         «IF fromState == 0 && toState == 1»
         //sync «action»  // STG doesn't accept sync in the first transition.
         «ELSE»
         sync «action»
         «ENDIF»
         «IF statements.length == 1»
         do «statements.get(0)»
         «ELSEIF statements.length > 1»
         do {
             «statements.join(" | ")»
         }
         «ENDIF»
       to s«toState»;
     '''
   }
}

/*
 * A IOstsProcess
 * 
 * Note:
 * - has an immutable name, which is required at creation time.
 * - inputMap, outputMap, and parametersMap are mutable maps of input, output of the Process.
 * - inoutputMap is a map that lives only during the translation from SoS-ADL to IOSTS
 *   because SOS-ADL has inout connections.
 * - parametersMap, and variablesMap are mutable maps containing parameters and variables of the process.
 * - transitions is the mutable list of the transitions.
 * - lastState is an int used internally to assign names to states.
 * - lastParameterNumber is an int used internally to assign names to parameters.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 */
class IOstsProcess{
    val String name
    var String comment=""
    public var inputMap = newLinkedHashMap()    // map of (in connection -> type name)
    public var outputMap = newLinkedHashMap()   // map of (out connection -> type name)
    public var inoutputMap = newLinkedHashMap() // map of (inout connection -> type name)
    public var parametersMap = newLinkedHashMap()  // map of (received variable -> type name)
    public var variablesMap = newLinkedHashMap()  // map of (variable -> type name) 
    public var List<IOstsTransition> transitions = newArrayList()
    var int lastState = 0 // number of the last state, starting at 0.
    var int lastParameterNumber = 0  // number of the last generated parameter

    new(String name) {
        this.name=name
    }
    
    def String name() {
        this.name
    }
    
    def setComment(String comment) {
        this.comment = comment
    }
    
    def addInput(String name, String typeName) {
        this.inputMap.put(name, typeName)
    }
    
    def addOutput(String name, String typeName) {
        this.outputMap.put(name, typeName)
    }
    
    def addInoutput(String name, String typeName) {
        this.inoutputMap.put(name, typeName)
    }
    
    def addParameter(String name, String typeName) {
        this.parametersMap.put(name, typeName)
    }
    
    def addVariable(String name, String typeName) {
        this.variablesMap.put(name, typeName)
    }
    
    def addVariable(String name) {
        addVariable(name, new IOstsIntType().toString)
    }
    
    def addTransition(IOstsTransition transition) {
        this.transitions.add(transition)
    }
    
    /*
     * Returns a new unused state id 
     */
    def int newState() {
        this.lastState = this.lastState+1
        this.lastState
    }
    
    def lastState() {
        this.lastState
    }
    
    /*
     * Returns a new unused parameter name
     */
    def newParameter() {
        this.lastParameterNumber = this.lastParameterNumber+1
        this.lastParameter()
    }
    
    def lastParameter() {
        this.name+"_p"+this.lastParameterNumber
    }
    
    /*
     * Returns the text of the IOSTS Process
     */
    override def String toString()'''
    process «name»;
    «IF !inputMap.empty»
    
    input  
      «inputMap.keySet.join(",\n")»;
    «ENDIF»
    «IF !outputMap.empty»
    
    output
      «outputMap.keySet.join(",\n")»;
    «ENDIF»
      
    internal
      tau;
    «IF !parametersMap.empty»
    
    parameters // stg says they have already been declared!
      «FOR p:parametersMap.keySet»
      //«p» : «parametersMap.get(p)»; 
      «ENDFOR»
    «ENDIF»
    «IF !variablesMap.empty»
    
    variables
      «FOR v:variablesMap.entrySet»
      «v.key» : «v.value»;
      «ENDFOR»
    «ENDIF»
    
    state
      init: s0;
      «FOR s:1..lastState»
      s«s»;
      «ENDFOR»  
    
    transition
    «FOR t:transitions»
    «t.toString»
    «ENDFOR»
    '''
}

/*
 * IOstsSystem
 * 
 * Notes:
 * - has an immutable name, which is required at creation time.
 * - fileName is the name of the file to be sqved.
 * - constantSection is not used at this time.
 * - typesMap is a mutable map containing the declaration of all types used in this system.
 * - gatesMap is the mutable map of gates (called connections in SoS-ADL).
 * - processesMap is the map of processes of this system.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 */
class IOstsSystem{
    val String name
    var String fileName=""
    var String comment=""
    var String behaviorName="UNDEFINED"
    public var LinkedHashMap<String,String> constantsMap = newLinkedHashMap()     // map of (name -> value as tring)
    public var LinkedHashMap<String,IOstsType> typesMap = newLinkedHashMap()     // map of (name -> iosts type)
    public var LinkedHashMap<String,IOstsGate> gatesMap = newLinkedHashMap()  // map of (gate name -> Gate)
    public var LinkedHashMap<String,IOstsProcess> processesMap = newLinkedHashMap()  // map of (process name -> Process)
    
    new(String name) {
       this.name=name
    }
    
    def setFileName(String fileName) {
       this.fileName = fileName
    }
    
    def fileName() {
        fileName
    }
    
    def setComment(String comment) {
       this.comment = comment
    }
    
    def addGate(IOstsGate gate) {
        this.gatesMap.put(gate.name, gate)
    }
    
    def addProcess(IOstsProcess process) {
        // Sometimes, for example when "behavior{done}", the sts is empty.
        // In those cases, do not add the process, because it is invalid! 
        if (process.transitions.empty) {
            System.err.println("Warning! Process '"+process.name+"' is empty! Ignoring...")
        } else {
            if (process.name.contains("_behavior")) {
                behaviorName=process.name
            }
            this.processesMap.put(process.name, process)
        }
    }
    
    /*
     * empty returns true if no process has been generated.
     */
    def empty() {
        processesMap.empty
    }
    
    override def String toString() {
        // generate something only if there is at least one process
        if (empty) {
            System.err.println("Warning! System '"+name+"' defines no process! Ignoring...")
            ""
        } else {     
    '''
    /*
    Generated by org.archware.sosadl.generator.SosADL2IOSTSGenerator
    
    WARNING #1: The generator is a work in progress! This IOSTS file may not be complete!
    WARNING #2: The generator assumes the SoSADL source is correct.
                Otherwise, STG may not compile this IOSTS file. 

    Run it with:
      «IF processesMap.size == 1 && behaviorName != "UNDEFINED"»
        stg «fileName» -test_name «behaviorName»
      «ELSE»
        «FOR p:processesMap.values»
        «IF p.name.endsWith("_protocol")»
        stg «fileName» -test_name «behaviorName» -test_purpose_name «p.name»
        «ENDIF»
        «ENDFOR»
      «ENDIF»
    */
    
    system «name»;
    «IF !constantsMap.empty»
    
    constant
      «FOR c:constantsMap.entrySet»
        «c.key» = «c.value»
      «ENDFOR»
    «ENDIF»
    «IF !typesMap.empty»
    
    type
      «FOR t:typesMap.entrySet»
        «val tk = t.key»
        «val tv = t.value»
        «IF tv.toString == "int"»
          // «tk» = int;
        «ELSE»
          «tk» = «tv»;
        «ENDIF»
      «ENDFOR»
    «ENDIF»
    
    gate
    «FOR g:gatesMap.values»
    «g.toString»
    «ENDFOR»
    «FOR p:processesMap.values»
    
    //--------------------------------------------------
    «p.toString»
    «ENDFOR»
    '''}
    }
}
