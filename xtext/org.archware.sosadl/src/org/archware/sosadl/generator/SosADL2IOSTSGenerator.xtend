/*
 * generated by Xtext
 */
package org.archware.sosadl.generator

import org.eclipse.emf.ecore.resource.Resource
/* 
import org.eclipse.core.resources.IFolder
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.resources.IContainer
*/
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.archware.sosadl.sosADL.*
import org.archware.sosadl.SosADLStandaloneSetupGenerated
//import org.eclipse.emf.common.util.URI
//import org.archware.sosadl.SosADLComparator
//import org.eclipse.xtext.parser.IParser
//import java.io.StringReader
import java.util.LinkedHashMap
import java.util.Map.Entry
import java.util.ArrayList
import java.util.List
import java.lang.System
//import org.archware.sosadl.services.SosADLGrammarAccess.ValuingElements
//import org.archware.sosadl.sosADL.impl.ValuingImpl
import org.archware.sosadl.sosADL.SosADLFactory
import org.archware.sosadl.sosADL.impl.SosADLFactoryImpl
import com.google.inject.Guice
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.common.util.URI
import org.archware.sosadl.SosADLRuntimeModule
import org.archware.sosadl.sosADL.impl.ValuingImpl
import com.google.inject.Injector
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.resource.XtextResource
/* 
import org.eclipse.core.resources.IResource
import org.eclipse.core.resources.IFolder
import org.eclipse.xtext.resource.IResourceServiceProvider
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.resource.IResourceDescription.Manager
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.parser.IEncodingProvider
import org.eclipse.xtext.naming.IQualifiedNameConverter
*/
//import org.archware.iosts.ui.contentassist.AbstractIoSTSProposalProvider

/**
 * Generates IOSTS code from the given SosADL model files on save.
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 * 
 * The SosADL2IOSTSGenerator inherits most of its compile methods from the SosADLPrettyPrinterGenerator
 * and overrides/adds methods for the STS generation.  
 */
class SosADL2IOSTSGenerator extends SosADLPrettyPrinterGenerator implements IGenerator {
    
    val DEBUG=false
    val DEBUG2=false
    val DEBUG3=false
    
    // global variables making the generation much easier
    // librariesMap contains all known libraries
    var LinkedHashMap<String,IOstsLibrary> librariesMap = newLinkedHashMap()  // map of (name -> library)
    // importedMap contains all libraries to import in the current file
    var LinkedHashMap<String,IOstsLibrary> importedMap = newLinkedHashMap()  // map of (name -> library)
    var IOstsType currentType = null           // type currently generated
    var LinkedHashMap<String,IOstsType> currentTypesMap = null // map of (types -> typeDecl) currently generated
    var IOstsListOfFunctions currentListOfFunctions = null // list of functions currently generated
    var IOstsLibrary currentLibrary = null     // library currently generated
    var IOstsSystem currentSystem = null       // system currently generated
    var IOstsProcess currentProcess = null     // process currently generated
    var LinkedHashMap<String,IOstsConnection> currentConnectionsMap = newLinkedHashMap()  // current connection map
    var lastIOstsTypeNum = 0
    var lastDoExprResultNumber=0
    var lastForEachVarNumber=0
    
    //FIXME: these two global variables should be avoided!
    var String globalFolderName = null 
    var IFileSystemAccess globalFsa = null
    var Resource globalResource = null
    
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		librariesMap = newLinkedHashMap()
		
		globalFolderName = resource.URI.path.substring(0,resource.URI.path.lastIndexOf('/'))
		globalResource = resource
		globalFsa = fsa
		
		for (e : resource.allContents.toIterable.filter(SosADL)) {
			doGenerateOne(e)
		}
	}
	
	def void doGenerateOne(SosADL sfile) {
		// save the context of the previous compilation
		val LinkedHashMap<String,IOstsLibrary> _saved_importedMap = importedMap
		val IOstsType _saved_currentType = currentType
		val LinkedHashMap<String,IOstsType> _saved_currentTypesMap = currentTypesMap
		val IOstsSystem _saved_currentSystem = currentSystem
    	val IOstsProcess _saved_currentProcess = currentProcess
   	 	val LinkedHashMap<String,IOstsConnection> _saved_currentConnectionsMap = currentConnectionsMap
		// ok: generate the iosts!
        var String resourceFilename = sfile.eResource.URI.trimFileExtension.lastSegment
        var String iostsFileName = resourceFilename+".iosts"
        System.out.print("Transforming '"+sfile.eResource.URI.lastSegment+"' into '"+iostsFileName+"'")
        importedMap = newLinkedHashMap()
        globalFsa.generateFile(iostsFileName, sfile.compile)
        // restore the context of the previous compilation
        importedMap = _saved_importedMap
        currentType = _saved_currentType
        currentTypesMap = _saved_currentTypesMap
        currentSystem = _saved_currentSystem
        currentProcess = _saved_currentProcess
        currentConnectionsMap = _saved_currentConnectionsMap
	}
	 
	/* A REVOIR !!!! Comment recuperer la resource SosADL a partir d'un IFile ?
	//cet import pose probleme : import org.eclipse.core.resources.IProject 
	def SosADL loadSosADLLibrary(String resourceName) {
		var SosADL result = null
		/ * 
		var Injector injector = new SosADLStandaloneSetupGenerated().createInjector//AndDoEMFRegistration()
		var XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet) as XtextResourceSet
		//var URI uri = URI.createURI("platform:"+globalFolderName+'/'+resourceName+".sosadl")
    	resourceSet.addLoadOption(XtextResource.RESOURCE__URI, uri)
    	//var String platformString = resourceSet.getURI().toPlatformString(true)
    	var java.net.URI uri = new java.net.URI(globalResource.URI.toString)
    	var IFile myFile = new IFile(uri)//.toPlatformString(true); getProject() .getFile(new Path(platformString))
		var IProject proj = myFile.getProject()
		var IFile linkedFile = proj.getFile(value)
		* /
		//var String platformString = globalResource.getURI().toPlatformString(true)
		var IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(globalFolderName)//.getFile(resourceName+".sosadl")
		var IFolder folder = project.getFolder("src")
		var IFile zefile = folder.getFile(resourceName+".sosadl")
		result
		result
		//
		/ *
		var IFolder folder = IProject.getFolder("src")
		var IResource[]	members = folder.members()
		for (IResource member : members) {
			if (member instanceof IFile && member.getFileExtension().equalsIgnoreCase("sosadl"){
				var file = member as IFile
			}
		}
		* /
	}
	*/
  
   	def SosADL loadSosADLResource1(String resourceName) {
		var SosADL result
		var Injector injector = new SosADLStandaloneSetupGenerated().createInjector//AndDoEMFRegistration()
		var XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet) as XtextResourceSet
		//var URI uri = URI.createURI("platform:/resource/${project-name}/src/")
		var URI uri = URI.createURI("platform:"+globalFolderName+'/'+resourceName+".sosadl")
    	//resourceSet.addLoadOption(XtextResource.RESOURCE__URI, uri)
    	resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE)
    	//var Resource resource = resourceSet.getResource(uri,true)
    	var results = resourceSet.allContents.toIterable.filter(SosADL)//.filter([eResource.URI.trimFileExtension.lastSegment.equals(resourceName)])
    	System.err.println("List of resource(s) found at URI='"+uri+"':")
		for (e : results) {
			System.err.println("- '"+e.eResource.URI+"'")
		}
		System.err.println("End of list.")
		if (results.empty) {
			System.err.println("Warning! Library '"+resourceName+"' not found!")
		} else {
			result = results.head as SosADL
			if (result.eResource.URI.trimFileExtension.lastSegment.equals(resourceName)) {
				System.err.println("Found library '"+resourceName+"'. ok.")
			} else {
				System.err.println("Found library '"+resourceName+"'? resource = '"+result.eResource.URI.trimFileExtension.lastSegment+"'")
			}
		}
		result
	}
	
	def SosADL loadSosADLResource(String resourceName) {
		var SosADL result
		var Injector injector = new SosADLStandaloneSetupGenerated().createInjector//AndDoEMFRegistration()
		var XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet) as XtextResourceSet
		// We don't want all resources! we just one the resource for resourceName!
		//resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE)
		var URI uri = URI.createURI("platform:"+globalFolderName+'/'+resourceName+".sosadl")
    	resourceSet.addLoadOption(XtextResource.RESOURCE__URI, uri.toString)
		try {
			var Resource resource = resourceSet.getResource(uri, true) // FIXME! bizarre!
			if (resource.getContents().empty) {
				if(DEBUG) System.err.println("Library '"+resourceName+"' at URI='"+resource.URI+"' is empty!")
    			result = null
    		} else {
    			if(DEBUG) System.err.println("Found library '"+resourceName+"' at URI='"+resource.URI+"'. ok.")
    			result = (resource.getContents().get(0) as SosADL)
    		}  		
    	} catch (Exception e) {
    		System.err.println("Warning! Library '"+resourceName+"' not found at uri '"+uri.path()+"'!")
    		result = null
    	}
		result
	}
	
	//=========================== model transformations
	
	/*
	 * Create a new NamedType EObject with given name
	 */
	def NamedType newNamedType(String name) {
		//val SosADLFactory factory = SosADLFactoryImpl.init()
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createNamedType()  // will create a NamedTypeImpl!
		result.setName(name)
		// since result is really a NamedTypeImpl, cast to a NamedType!
		(result as NamedType)
	}
	
	/*
	 * Transform a DoExpr into a Valuing EObject.
	 * From the AST of 'do Expression', we generate the AST for 'value _doExprResult# is dataType = Expression'
	 * where:
	 * - _doExprResult# is a unique variable name
	 * - dataType is the type of Expression
	 */
	def Valuing newValuingFromDoExpr(DoExpr doExpr) {
		// generate a new dumb variable
		lastDoExprResultNumber++
		val String dumbVarName="_doExprResult"+lastDoExprResultNumber
		// retrieve the type of Expression
		val DataType datatype = newNamedType("integer")
		// create a Valuing
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createValuing()  // will create a ValuingImpl!
		result.setType(datatype)
		result.setVariable(dumbVarName)
		result.setExpression(doExpr.expression)
		// since result is really a ValuingImpl, cast to a Valuing!
		(result as Valuing)
	}
	
	/*
	 * Create a ComplexName out of the name of a IOstsConnection
	 * Since the name of a connection is already the concatenation of the elements of the ComplexName,
	 * one has to split this name and remove the added '::' to get each element of the ComplexName.
	 * Example: gate::connection has to be splitted in ComplexName(Name('gate'),Name('connection')) 
	 */
	def ComplexName newComplexNameFromString(String name) {
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createComplexName()  // will create a ComplexNameImpl?
		var complexname = name.split("::")
		for (n : complexname) {
			result.getName().add(n)
		}
		result
	}
	
	/*
	 * Create an ChooseProtocol (choose {action1} or {action2} ...)
	 * out of the given list of connections.
	 * From the list of declared connections in the current gate/duty, 
	 * we generate the AST for 'choose {action1} or {action2}'
	 * where:
	 * - each declared connection <c> gives one or two actions.
	 * - if one connection <c.name> has mode 'in', the generated action is 'via <c.name> receive any'. 
	 * - if one connection <c.name> has mode 'out', the generated action is 'via <c.name> send any'. 
	 * - if one connection <c.name> has mode 'inout', two actions are gerenated:
	 *   'via <c.name> receive any' and 'via <c.name> send any'. 
	 */
	def ChooseProtocol newChooseProtocolActionFromConnections(LinkedHashMap<String,IOstsConnection> connectionsMap) {
		// create a Valuing
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createChooseProtocol()  // will create a ChooseProtocolImpl!
		for (c : connectionsMap.values) {
			// create the appropriate(s) action(s) and make it a new branch
			if (c.mode == 'in' || c.mode == 'inout') {
				// connection mode is 'in' or 'inout': create a branch with 'via <c.name> receive any'
				// make a ComplexName out of the name of the connection
				var ComplexName conectionName=newComplexNameFromString(c.name)
				// create a new ReceiveAnyProtocolAction which is a ProtocolActionSuite
				var actionSuite = factory.createReceiveAnyProtocolAction()
				// create a new ProtocolAction
				var action = factory.createProtocolAction()
				action.setComplexName(conectionName)
				action.setSuite(actionSuite)
				// create a new Branch of the ChooseProtocol, and add the action to it
			    var branch = factory.createProtocol()
			    branch.getStatements().add(action)
			    // add the branch to the ChooseProtocol
			    result.getBranches().add(branch)
			}
			if (c.mode == 'out' || c.mode == 'inout') {
				// connection mode is 'out' or 'inout': create a branch with 'via <c.name> send any'
				// make a ComplexName out of the name of the connection
				var ComplexName conectionName=newComplexNameFromString(c.name)
				// create a FinalExpression Any ('any')
				var anyExpression = factory.createAny()
				// create a new ReceiveAnyProtocolAction which is a ProtocolActionSuite
				var actionSuite = factory.createSendProtocolAction()
				actionSuite.setExpression(anyExpression)
				// create a new ProtocolAction
				var action = factory.createProtocolAction()
				action.setComplexName(conectionName)
				action.setSuite(actionSuite)
			    // create a new Branch of the ChooseProtocol, and add the action to it
			    var branch = factory.createProtocol()
			    branch.getStatements().add(action)
			    // add the branch to the ChooseProtocol
			    result.getBranches().add(branch)
			}
		}
		result
	}
	
	/* Create an IfThenElseBehavior 'if (Expression) then {BehaviorStatement*}'
	 * out of the given list of BehaviorStatements where:
	 * - the ask statement which is the AskAssertion, containing the condition=Expression of if(condition)
	 * - the next statements, if any, are the BehaviorStatement to be put inside 'then{}' 
	 * The SoSADL grammar does not allow a Behavior without statements.
	 * Thus, in case the ifThenStatements is empty, a Done statement is added to it.
	 * 
	 * Note: unused since we do not use anymore this model transformation to translate AskAssertion
	 *       into an IoSTS transition.
	 */
	def IfThenElseBehavior newIfThenElseBehaviorFromAskAssertionAndBehaviorStatements(AskAssertion ask, ArrayList<BehaviorStatement> ifThenStatements) {
		// create a Behavior which will contain the ifThenStatements
		val factory = SosADLFactory.eINSTANCE
		var ifTrueBehavior = factory.createBehavior()
		if (ifThenStatements.empty) {
			val done = factory.createDone()
			ifThenStatements.add(done)
		}
		ifTrueBehavior.getStatements().addAll(ifThenStatements)
		// create an IfThenElseBehavior
		var result = factory.createIfThenElseBehavior() // will create a IfThenElseBehaviorImpl!
		result.setCondition(ask.expression)
		result.setIfTrue(ifTrueBehavior)
		result
	}
	
	/* Create an IfThenElseProtocol 'if (Expression) then {ProtocolStatement*}'
	 * out of the given list of ProtocolStatements where:
	 * - the ask statement which is the AskAssertion, containing the condition=Expression of if(condition)
	 * - the next statements, if any, are the ProtocolStatement to be put inside 'then{}' 
	 * The SoSADL grammar does not allow a Protocol without statements.
	 * Thus, in case the ifThenStatements is empty, a Done statement is added to it.
	 * 
	 * Note: unused since we do not use anymore this model transformation to translate AskAssertion
	 *       into an IoSTS transition.
	 */
	def IfThenElseProtocol newIfThenElseProtocolFromAskAssertionAndProtocolStatements(AskAssertion ask, ArrayList<ProtocolStatement> ifThenStatements) {
		// create a Protocol which will contain the ifThenStatements
		val factory = SosADLFactory.eINSTANCE
		var ifTrueProtocol = factory.createProtocol()
		if (ifThenStatements.empty) {
			val done = factory.createDone()
			ifThenStatements.add(done)
		}
		ifTrueProtocol.getStatements().addAll(ifThenStatements)
		// create an IfThenElseProtocol
		var result = factory.createIfThenElseProtocol() // will create a IfThenElseProtocolImpl!
		result.setCondition(ask.expression)
		result.setIfTrue(ifTrueProtocol)
		result
	}
	
    
    //=========================== compilation
	
    /* Pour memoire 
	
	//---------------- parts of SosADL2IOSTSv1Generator : pour memoire
	def compile(SystemDecl s){
	  currentSystem = new IOstsSystem(s.name)
	  currentSystem.constantsMap.putAll(globalConstantsMap)
	  currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+s.name+".iosts")
	  s.parameters.map[compile]
	  for (d : s.datatypes) {
        d.compile
      }
      for (g : s.connections) {
        g.compile
      }
      //if (s.assertion != null) {s.assertion.compile}  // not a protocol?
      s.behavior.compile
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }

	def compile(ArchitectureDecl a){
	  currentSystem = new IOstsSystem(a.name)
      currentSystem.constantsMap.putAll(globalConstantsMap)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+a.name+".iosts")
      a.parameters.map[compile]
      for (d : a.datatypes) {d.compile}
      for (g : a.connections) {g.compile}
      a.behavior.compile
      //if (a.assertion != null) {a.assertion.compile} // not a protocol?
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }

    def compile(MediatorDecl m){
      currentSystem = new IOstsSystem(m.name)
      currentSystem.constantsMap.putAll(globalConstantsMap)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+m.name+".iosts")
      m.parameters.map[compile]
      for (d : m.datatypes) {
        d.compile
      }
      for (d : m.duties) {
        d.compile
      }
      //if (m.assertion != null) {m.assertion.compile}  // not a protocol?
      m.behavior.compile
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }
	
	def compile(GateDecl g){
	    for (c : g.connections) {
	        val name=g.name+"_"+c.name
	        val IOstsType type = computeIOstsType(c.valueType)
	        val typeName = nameOfIOstsType(type)
	        registerIOstsType(typeName, type)
	        val finalTypeName = finalNameOfIOstsType(typeName)
	        //currentSystem.addConnection(new IOstsConnection(name, computeIOstsType(c.valueType), c.mode.toString))
	        currentSystem.addConnection(new IOstsConnection(name, finalTypeName, c.mode.toString))
	    }
	    '''«g.protocol.compile»'''
	}

	
	def compile(DutyDecl d){
        for (c : d.connections) {
            val name=d.name+"_"+c.name
            val IOstsType type = computeIOstsType(c.valueType)
            val typeName = nameOfIOstsType(type)
            registerIOstsType(typeName, type)
            val finalTypeName = finalNameOfIOstsType(typeName)
            //currentSystem.addConnection(new IOstsConnection(name, computeIOstsType(c.valueType), c.mode.toString))
            currentSystem.addConnection(new IOstsConnection(name, finalTypeName, c.mode.toString))
        }
        '''«d.protocol.compile»'''
    }
    
    */
    
    override def compile(Import i) {
    	var IOstsLibrary library = null
    	if (librariesMap.containsKey(i.importedLibrary)) {
    		if(DEBUG) System.err.println("Library '"+i.importedLibrary+"' already compiled, and imported. ok.")
    		library = librariesMap.get(i.importedLibrary)
     	} else if (i.importedLibrary.toLowerCase.equals("base")) {
			// FIXME!
			if(DEBUG) System.err.println("TODO: Define 'predefined' library '"+i.importedLibrary+"'!")
	    	library = null
    	} else {
    		val SosADL sresource=loadSosADLResource(i.importedLibrary)
    		if (sresource == null) {
    			System.err.println("Warning! Cannot import '"+i.importedLibrary+"': source file not found!")
    		} else {
    			if(DEBUG) System.err.println("Importing library '"+i.importedLibrary+"'...")
    			doGenerateOne(sresource)
    			if (librariesMap.containsKey(i.importedLibrary)) {
    				if(DEBUG) System.err.println("Library '"+i.importedLibrary+"' compiled, and imported. ok.")
    			} else {
    				System.err.println("Warning! Library '"+i.importedLibrary+"' compiled, but not imported!")
    			}
    			library = librariesMap.get(i.importedLibrary)
    		}
    	}
    	if (library != null) {
    		importedMap.put(i.importedLibrary, library)
    	}
    	super.compile(i)
    }
	
	override def compile(Library l) {
		currentLibrary = new IOstsLibrary(l.name)
		currentLibrary.importedMap.putAll(importedMap)
		val result = super.compile(l)
		if (currentLibrary != null) {
			librariesMap.put(l.name, currentLibrary)
		}
		currentLibrary = null
		result
	}
	
	override def compile(SoS s) {
		currentLibrary = new IOstsLibrary(s.name)
		val result = super.compile(s)
		if (currentLibrary != null) {
			importedMap.put(s.name, currentLibrary)
		}
		currentLibrary = null
		result
	}
	
	override def compile(EntityBlock e) {
		currentSystem = null
		
		currentTypesMap = new LinkedHashMap()
		var String datatypes =
		'''
		«IF !e.datatypes.empty»
		«FOR d : e.datatypes»
      		«d.compile»
    	«ENDFOR»
    	
    	«ENDIF»
    	'''
    	currentLibrary.typesMap.putAll(currentTypesMap)
    	
		currentListOfFunctions = new IOstsListOfFunctions()
		var String functions =
		'''
		«IF !e.functions.empty»
      	«FOR f : e.functions»
      		«f.compile»
    	«ENDFOR»
    	
    	«ENDIF»
    	'''
	    currentLibrary.functions.addAll(currentListOfFunctions)
	    
        currentListOfFunctions = null
        currentTypesMap=null
        
    	'''
		«datatypes»
		«functions»
		
        «FOR s : e.systems»
      		«s.compile»
    	«ENDFOR»
    	«FOR m : e.mediators»
      		«m.compile»
    	«ENDFOR»
    	«FOR a : e.architectures»
      		«a.compile»
    	«ENDFOR»
    	'''
	}
	
	override def compile(DataTypeDecl d) {
		var IOstsType t
		if (d.datatype == null) {
			if(DEBUG2) System.err.println("Warning! type definition of '" + d.name + "' null! Assuming 'integer'...")
			t = new IOstsIntType()
		} else {
			t = computeIOstsType(d.datatype)
		}
		// put this type in currentTypesMap allow function declarations to get it  
		currentTypesMap.put(d.name, t)
		// get list of functions
		currentListOfFunctions = new IOstsListOfFunctions()
		var result = super.compile(d)
		t.functions.addAll(currentListOfFunctions)
		currentListOfFunctions = null
		// now that the type is completed with functions, put the type again in currentTypesMap
		currentTypesMap.put(d.name, t)
		result
	}
    
    override def compile(FunctionDecl f) {
    	var iof = new IOstsFunction(f.name.toString)
    	iof.setData(f.dataName, computeIOstsType(f.dataTypeName))
    	for (p : f.parameters) {
    		iof.addFormalParameter(p.name, computeIOstsType(p.type))
    	}
    	iof.returnType = computeIOstsType(f.type)
    	for (v : f.valuing) {
    		iof.addValuing(v)
    	}
    	iof.returnExpression = f.expression
    	currentListOfFunctions.add(iof)
    	super.compile(f)
    }
	
	override def compile(SystemDecl s) {
		currentSystem = new IOstsSystem(s.name)
		//currentSystem.setFileName(resourceFilename + ".iosts")

		/*
	  	s.parameters.map[compile]
	  	for (d : s.datatypes) {
        	d.compile
      	}
      	for (g : s.connections) {
        	g.compile
      	}
	    //if (s.assertion != null) {s.assertion.compile}  // not a protocol?
      	s.behavior.compile
      	*/
      	currentTypesMap = new LinkedHashMap()
		val result = super.compile(s)
		currentSystem.typesMap.putAll(currentTypesMap)
		currentTypesMap = null

		// add system if it's not empty
		if (! currentSystem.empty) {
			currentLibrary.addSystem(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(MediatorDecl m) {
		currentSystem = new IOstsSystem(m.name)
		//currentSystem.setFileName(resourceFilename + "_" + m.name + ".iosts")

		/*
      	m.parameters.map[compile]
      	for (d : m.datatypes) {
        	d.compile
      	}
      	for (d : m.duties) {
        	d.compile
      	}
      	//if (m.assertion != null) {m.assertion.compile}  // not a protocol?
      	m.behavior.compile
      	*/
      	currentTypesMap = new LinkedHashMap()
		val result = super.compile(m)
		currentSystem.typesMap.putAll(currentTypesMap)
		currentTypesMap = null

		// add system if it's not empty
		if (! currentSystem.empty) {
			currentLibrary.addSystem(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(ArchitectureDecl a) {
		currentSystem = new IOstsSystem(a.name)
		//currentSystem.setFileName(resourceFilename + "_" + a.name + ".iosts")

		/*
      	a.parameters.map[compile]
      	for (d : a.datatypes) {d.compile}
      	for (g : a.connections) {g.compile}
      	a.behavior.compile
      	//if (a.assertion != null) {a.assertion.compile} // not a protocol?
      	*/
		currentTypesMap = new LinkedHashMap()
		val result = super.compile(a)
		currentSystem.typesMap.putAll(currentTypesMap)
		currentTypesMap = null

		// add system if it's not empty
		if (! currentSystem.empty) {
			currentLibrary.addSystem(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(GateDecl g){
    	currentConnectionsMap = newLinkedHashMap()
	    for (c : g.connections) {
	        val name=g.name+"::"+c.name
	        val IOstsType type = computeIOstsType(c.valueType)
	        val typeName = nameOfIOstsType(type)
	        val finalTypeName = finalNameOfIOstsType(typeName)
	        currentConnectionsMap.put(name, new IOstsConnection(name, finalTypeName, c.mode.toString))
	    }
	    super.compile(g)
	}

	
	override def compile(DutyDecl d){
		currentConnectionsMap = newLinkedHashMap()
        for (c : d.connections) {
            val name=d.name+"::"+c.name
            val IOstsType type = computeIOstsType(c.valueType)
            val typeName = nameOfIOstsType(type)
            val finalTypeName = finalNameOfIOstsType(typeName)
            currentConnectionsMap.put(name, new IOstsConnection(name, finalTypeName, c.mode.toString))
        }
        super.compile(d)
    }
    
    //---------------- Compilation of Protocol and Behavior is special
    
    override def compile(ProtocolDecl p) {
        var IOstsTransition firstTransition = initTransition("true")
        firstTransition.setComment("FIXME: system/mediator/architecture parameters may change this guard!")
        currentProcess = new IOstsProcess(p.name)
        currentProcess.addAllConnections(currentConnectionsMap)
        currentProcess.addTransition(firstTransition)
        computeSTS(firstTransition.toState(),p.body)
        currentSystem.addProcess(currentProcess)
        '''protocol «p.name» is «currentProcess»'''
    }
    
    override def compile(BehaviorDecl b){
        var IOstsTransition firstTransition = initTransition("true")
        firstTransition.setComment("FIXME: system/mediator/architecture parameters may change this guard!")
        currentProcess = new IOstsProcess(b.name)
        currentProcess.addAllConnections(currentConnectionsMap)
        currentProcess.addTransition(firstTransition)
        computeSTS(firstTransition.toState(),b.body)
        currentSystem.addProcess(currentProcess)
        '''behavior «b.name» is «currentProcess»'''
    }
    
    /* TODO! Generate the STS in place of the architecture behavior
	def compile(ArchBehaviorDecl a)'''
    behavior «a.name» is compose {
      «FOR c:a.constituents»
        «c.compile»
      «ENDFOR»
    } binding {
      «a.bindings.compile»
    }
	'''
	*/
	
	// get and register type of value
	override def compile(Valuing v){
	  registerValuing(v)
	  super.compile(v)
	}
	
	// register name and type of Valuing
	def registerValuing(Valuing v) {
		if (v.type == null)
			currentProcess.addVariable(v.variable)
		else {
			val type = computeIOstsType(v.type)
			val typeName = nameOfIOstsType(type)
			currentProcess.addVariable(v.variable, finalNameOfIOstsType(typeName))
		}
	}
	
    
    //=========================== Generation of the STS
    
    /*
     * Returns an init transition: from 0 to 1, with given guard.
     * Shall be added before any other in a Behavior or Protocol.
     * The first transition has no action, not assignments.
     * A default comment is added, but can be changed. 
     */
    def IOstsTransition initTransition(String guard) {
    	var IOstsTransition firstTransition = new IOstsTransition(0,1)
    	firstTransition.setInit(true)
    	firstTransition.setGuard(guard)
    	firstTransition.setComment("first transition") // default comment, can be changed later
	    firstTransition
    }
    
    /*
     * All computeSTS() functions return the final states of the STS
     * according to the behavior starting at startState.
     */
    /*
     * - computeSTS for a Behavior (which is a sequence of BehaviorStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Behavior b) {
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        var boolean previousIsValuing=false
        var int previousStartState=0
        var int istatement=0
        var int nstatements=b.statements.length
        while(istatement < nstatements) {
        	var s=b.statements.get(istatement)
            if (! first) { // && finalStates.length >= 2) {
            	// NEW version: concatenation for sequentiality is generated between two statements
            	// ONLY when the first statement ends with at least 2 final states.
            	if (finalStates.length == 1) {
            		state=finalStates.get(0)
           		} else { // finalStates.length >= 2
                	state=currentProcess.newState()
	                var i=0
	                while (i < finalStates.length) {
	                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
	                    concatenation.setComment("Concatenation (sequentiality)")
	                    currentProcess.addTransition(concatenation)
	                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
	                    i = i+1
	                }
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            if (s instanceof Valuing) {
            	if (previousIsValuing) {
            		// adding a assignment to transition from state to finalStates.get(0)
            		// instead of creating a new transition
            		state = previousStartState
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, final(0)="+finalStates.get(0)+")")}
            		finalStates = computeSTS(state, s, finalStates.get(0), "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	} else {
               		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, 0)")}
            		finalStates = computeSTS(state, s, 0, "Valuing")
               		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	}
            	previousIsValuing = true
            } else {
            	previousIsValuing = false
            	/* OLD version with model transformation of AskAssertion into IfThenElseBehavior
            	if (s instanceof AskAssertion) {
            		// an AskAssertion is transformed into an IfThenElseBehavior statement
            		// where:
            		// - the AskAssertion expression becomes the condition of the IfThenElseBehavior
            		// - all remaining statements following the AskAssertion become the IfThen statements
            		var ArrayList<BehaviorStatement> remaining=newArrayList()
            		istatement++
            		while (istatement < nstatements) {
            			remaining.add(b.statements.get(istatement))
            			istatement++
            		}
            		var ifthen=newIfThenElseBehaviorFromAskAssertionAndBehaviorStatements(s, remaining)
            		finalStates = computeSTS(state, ifthen, "AskAssertion transformed into IfThenElseBehavior")
            	} else {
            		finalStates = computeSTS(state, s)	
            	}
            	*/
            	finalStates = computeSTS(state, s)
           	}
            first=false
            previousStartState=state
            if (DEBUG3) {System.err.println("END LOOP: state="+state+", previousStartState="+previousStartState+", final(0)="+finalStates.get(0))}
            istatement++
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Protocol (which is a sequence of ProtocolStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Protocol b){
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        var boolean previousIsValuing=false
        var int previousStartState=0
        var int istatement=0
        var int nstatements=b.statements.length
        while(istatement < nstatements) {
        	var s=b.statements.get(istatement)
        	if (! first) {
            	// NEW version: concatenation for sequentiality is generated between two statements
            	// ONLY when the first statement ends with at least 2 final states.
            	if (finalStates.length == 1) {
            		state=finalStates.get(0)
           		} else { // finalStates.length >= 2
                	state=currentProcess.newState()
	                var i=0
	                while (i < finalStates.length) {
	                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
	                    concatenation.setComment("Concatenation (sequentiality)")
	                    currentProcess.addTransition(concatenation)
	                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
	                    i = i+1
	                }
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            if (s instanceof Valuing) {
            	if (previousIsValuing) {
            		// adding a assignment to transition from state to finalStates.get(0)
            		// instead of creating a new transition
            		state = previousStartState
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, final(0)="+finalStates.get(0)+")")}
            		finalStates = computeSTS(state, s, finalStates.get(0), "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	} else {
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, 0)")}
            		finalStates = computeSTS(state, s, "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	}
            	previousIsValuing = true
            } else {
            	previousIsValuing = false
            	/* OLD version with model transformation of AskAssertion into IfThenElseProtocol
            	if (s instanceof AskAssertion) {
            		// an AskAssertion is transformed into an IfThenElseProtocol statement
            		// where:
            		// - the AskAssertion expression becomes the condition of the IfThenElseProtocol
            		// - all remaining statements following the AskAssertion become the IfThen statements
            		var ArrayList<ProtocolStatement> remaining=newArrayList()
            		istatement++
            		while (istatement < nstatements) {
            			remaining.add(b.statements.get(istatement))
            			istatement++
            		}
            		var ifthen=newIfThenElseProtocolFromAskAssertionAndProtocolStatements(s, remaining)
            		finalStates = computeSTS(state, ifthen, "AskAssertion transformed into IfThenElseProtocol")
            	} else {
            		finalStates = computeSTS(state, s)	
            	}
            	*/
            	finalStates = computeSTS(state, s)
           	}
            first=false
            previousStartState=state
            if (DEBUG3) {System.err.println("END LOOP: state="+state+", previousStartState="+previousStartState+", final(0)="+finalStates.get(0))}
            istatement++
        }
        finalStates
    }
    
    /*
     * - computeSTS for a DoExpr statement: transform to a Valuing!
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, DoExpr r){
    	val Valuing v = newValuingFromDoExpr(r)
    	computeSTS(startState, v, "DoExpr")
    }
    
    /*
     * - computeSTS for a Valuing statement, not following a previous Valuing
     */
    def ArrayList<Integer> computeSTS(int startState, Valuing v, String comment){
    	computeSTS(startState, v, 0, comment)
    }
    
    /*
     * - computeSTS for a Valuing statement, may be following a Valuing statement.
     */
    def ArrayList<Integer> computeSTS(int startState, Valuing v, int finalState, String comment){
    	var int final
    	var IOstsTransition valuing
    	if (finalState == 0) {
    		final=currentProcess.newState()
        	valuing = new IOstsTransition(startState,final)
        } else {
        	final=finalState
        	if (DEBUG3) {
        		System.err.println("CALLING getTransition(startState="+startState+", final="+final+")")
        	}
        	valuing = currentProcess.getTransition(startState,final)
        	if (valuing == null) {
        		System.err.println("ERROR! Transition from="+startState+" to="+final+" not found!")
        	}
        }
        //valuing.addAssignment(v.compile.toString) // v.compile.toString hields SosADL syntax
        registerValuing(v)
        valuing.addAssignment(v.variable+" := "+v.expression.compile)
        valuing.setComment(comment)
        currentProcess.addTransition(valuing)
        //System.out.println("Added valuing transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Send/Receive Behavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Action a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        val IOstsConnection connection=currentSystem.getConnection(channel)
        if (connection == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared! Ignoring statement...")
        } else if (a.suite instanceof SendAction) {
            val parameter=currentProcess.newParameter()
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_out")
            }
            else if (connection.mode == "out") {
            	if (! currentProcess.outputMap.containsKey(channel)) {
                	currentProcess.addOutput(channel, connection.typeName)
                	if (DEBUG2) System.out.println("Added channel '"+channel+"' to output connections")
            	}           
            }
            action.setGuard(parameter+" = "+(a.suite as SendAction).expression.compile)
            action.setAction("via "+channel+" send "+parameter)
            action.setComment("Send action")
            currentProcess.addParameter(parameter,connection.typeName)
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAction) {
            val variable=(a.suite as ReceiveAction).variable
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_in")
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }

    /*
     * - computeSTS for a Send/Receive Protocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ProtocolAction a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        val IOstsConnection connection=currentProcess.getConnection(channel)
        if (connection == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared! Ignoring statement...")
        } else if (a.suite instanceof SendProtocolAction) {
            val parameter=currentProcess.newParameter()
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_out")
            }
            else if (connection.mode == "out") {
	            if (! currentProcess.outputMap.containsKey(channel)) {
	                currentProcess.addOutput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to output connections")
	            }
            }
            if ((a.suite as SendProtocolAction).expression.compile.toString == "any") {
                /* FIXME: send any:
                 * - option 1 "pas de if": ANY_typeConnection est une constante qui doit etre definie
                 *     action.setAction(channel+"!(ANY_typeConnection)")
                 *     currentProcess.addParameter(parameter,connection.typeName)
                 * - option 2 "avec if en affectant au parametre une constante ANY_typeConnection" (au hasard?)
                 *     action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                 *     action.setAction(channel+"!("+parameter+")")
                 *     currentProcess.addParameter(parameter,connection.typeName)
                 */
                // send any: no guard (thus not parameter) and send a random expression compatible with type of connection
                //action.setGuard(parameter+" = 0  /*FIXME: 0 should be an expression of parameter's type*/")
                action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                action.setAction("via "+channel+" send "+parameter)
                currentProcess.addParameter(parameter,connection.typeName)
                action.setComment("Send any action. Note: any is a random value")
            } else {
                // send some expression
                action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                action.setAction("via "+channel+" send "+parameter)
                currentProcess.addParameter(parameter,connection.typeName)
                action.setComment("Send action")
            }
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveProtocolAction) { 
            val variable=(a.suite as ReceiveProtocolAction).variable
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_in")
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAnyProtocolAction) {
            val variable="any_s"+startState
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_in")
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive any action")
            //System.out.println("Added receive any transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }

    /*
     * - computeSTS for a IfThenElseBehavior statement, without comment
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i){
    	computeSTS(startState, i, "IfThenElseBehavior")
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement, with comment
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i, String comment){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment(comment+" (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment(comment+" (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement, without comment
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i){
    	computeSTS(startState, i, "IfThenElseProtocol")
    }

    /*
     * - computeSTS for a IfThenElseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i, String comment){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment(comment+" (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment(comment+" (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    
    /*
     * - computeSTS for a ChooseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseBehavior c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }

    /*
     * - computeSTS for a ChooseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseProtocol c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }
        
    /*
     * - computeSTS for a RepeatBehavior statement.
     * 
     * OBSOLETE: RepeatBehavior is not allowed anymore!
     *
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatBehavior r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        // add a transition with guard "false" and action "tau" from startState
        // to avoid bypassing or exiting the repeat loop.
        val int ifFalseAfterRepeat=currentProcess.newState()
        var IOstsTransition ifFalse = new IOstsTransition(startState,ifFalseAfterRepeat)
        ifFalse.setGuard("false")
        ifFalse.setComment("IfFalse avoids exit from Repeat")
        currentProcess.addTransition(ifFalse)
        //System.out.println("Added ifFalse transition after Repeat: from="+startState+", to="+ifFalseAfterRepeat)
        newArrayList(ifFalseAfterRepeat)
    }
    */

    /*
     * - computeSTS for a RepeatProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatProtocol r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        newArrayList(startState) 
    }
        
    /*
     * - computeSTS for a Assert statement:
     *   useless and never called, because the case Assert is handled differently:
     *   -- if Assert is an AskAssertion, see computeSTS(int,AskAssertion)
     *   -- if Assert is a  TellAssertion, see computeSTS(int,TellAssertion)
     *
    def dispatch ArrayList<Integer> computeSTS(int startState, Assert r){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition assert = new IOstsTransition(startState,final)
        assert.setComment("TODO! Assert")
        currentProcess.addTransition(assert)
        //System.out.println("Added fake assert transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    */
    
    /*
     * - computeSTS for a AskAssertion statement:
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AskAssertion r){
    	val final=currentProcess.newState()
        var IOstsTransition ask = new IOstsTransition(startState,final)
        ask.setGuard(r.expression.compile.toString)
        ask.setComment("AskAssertion")
        currentProcess.addTransition(ask)
        newArrayList(final)
    }
    
    
    /*
     * - computeSTS for a TellAssertion statement
     * 
     *   FIXME: For the moment, we only allow expression in the form "var = expr"
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, TellAssertion r){
    	val final=currentProcess.newState()
        var IOstsTransition tell = new IOstsTransition(startState,final)
        tell.setGuard(r.expression.compile.toString)
        tell.setComment("TellAssertion")
        // Now the tricky part! At the moment, we only recognize and handle this case:
        // - case1: the expression is "envvar = expr"
        // else, the assignment is left empty!
        if (r.expression instanceof BinaryExpression) {
        	val BinaryExpression e = (r.expression as BinaryExpression)
        	if (e.getLeft instanceof IdentExpression) {
        		val String varName = e.getLeft.compile.toString
        	    if (e.op == '=') {
        	    	// case 1
        			tell.addAssignment(varName+" := "+e.getRight().compile)
        			// register the varName as a global variable
        			var String typeName = "integer /* FIXME! should be type of assigned expression! */"
        			currentProcess.addGlobal(varName, typeName)
        		}
        	}
        }
        currentProcess.addTransition(tell)
        newArrayList(final)
    }
    
    
    /*
     * - computeSTS for a ForEachBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachBehavior r){
        lastForEachVarNumber++
        val String iName = "i"+lastForEachVarNumber+"_"
        val String setOfValues = r.setOfValues.compile.toString
        val String variable = r.variable
        currentProcess.addVariable(iName)
        // transition: initialize i
        val finalInit=currentProcess.newState()
        var IOstsTransition init = new IOstsTransition(startState,finalInit)
        init.setComment("ForEachBehavior: init "+iName)
        init.addAssignment(iName+" := "+0)
        currentProcess.addTransition(init)
        // transition: if (i < sizeof(setOfValues))
        val finalIfInf=currentProcess.newState()
        var IOstsTransition ifInf = new IOstsTransition(finalInit, finalIfInf)
        ifInf.setComment("ForEachBehavior: begin loop")
        ifInf.setGuard(iName+" <= "+setOfValues+"::size()")
        ifInf.addAssignment(variable+" := "+setOfValues+"::element("+iName+")")
        currentProcess.addTransition(ifInf)
        // transitions of the Behavior inside the ForEachBehavior
        var ArrayList<Integer> endOfLoop = newArrayList()
        endOfLoop.addAll(computeSTS(finalIfInf, r.repeated))
        // transition(s) from end(s) of Behavior inside the ForEachBehavior to init
        /* alt1 */
        for (e : endOfLoop) {
        	var IOstsTransition increment = new IOstsTransition(e,finalInit)
        	increment.addAssignment(iName+" := "+iName+"+1")
        	increment.setComment("ForEachBehavior: end loop with increment")
        	currentProcess.addTransition(increment)
        }
        // end of alt1
        /* alt2
 		// add a concatenation if body ends with multiple states
        var int finalEndOfLoop
        if (endOfLoop.length > 1) {
        	finalEndOfLoop = currentProcess.newState()
        	// adding concatenations to get a unique final state for the body of ForEach
        	for (e : endOfLoop) {
	        	var IOstsTransition concatenation = new IOstsTransition(e,finalEndOfLoop)
	        	concatenation.setComment("ForEachBehavior: concatenation before increment")
	        	currentProcess.addTransition(concatenation)
	        }
        } else {
        	finalEndOfLoop = endOfLoop.get(0)
        }
        // increment
        var IOstsTransition increment = new IOstsTransition(finalEndOfLoop,finalInit)
        increment.addAssignment(iName+" := "+iName+"+1")
        increment.setComment("ForEachBehavior: end loop increment")
        currentProcess.addTransition(increment)
        // end of alt2
        */
        // transition: if (i > sizeof(setOfValues))
        val finalIfSup=currentProcess.newState()
        var IOstsTransition ifSup = new IOstsTransition(finalInit, finalIfSup)
        ifSup.setComment("ForEachBehavior: after foreach loop")
        ifSup.setGuard(iName+" > "+setOfValues+"::size()")
        currentProcess.addTransition(ifSup)
    	newArrayList(finalIfSup)
    }
    
    /*
     * - computeSTS for a ForEachProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachProtocol r){
		lastForEachVarNumber++
        val String iName = "i"+lastForEachVarNumber+"_"
        val String setOfValues = r.setOfValues.compile.toString
        val String variable = r.variable
        currentProcess.addVariable(iName)
        // transition: initialize i
        val finalInit=currentProcess.newState()
        var IOstsTransition init = new IOstsTransition(startState,finalInit)
        init.setComment("ForEachProtocol: init "+iName)
        init.addAssignment(iName+" := "+0)
        currentProcess.addTransition(init)
        // transition: if (i < sizeof(setOfValues))
        val finalIfInf=currentProcess.newState()
        var IOstsTransition ifInf = new IOstsTransition(finalInit, finalIfInf)
        ifInf.setComment("ForEachProtocol: begin loop")
        ifInf.setGuard(iName+" <= "+setOfValues+"::size()")
        ifInf.addAssignment(variable+" := "+setOfValues+"::element("+iName+")")
        currentProcess.addTransition(ifInf)
        // transitions of the Behavior inside the ForEachProtocol
        var ArrayList<Integer> endOfLoop = newArrayList()
        endOfLoop.addAll(computeSTS(finalIfInf, r.repeated))
        // transition(s) from end(s) of Behavior inside the ForEachBehavior to init
        /* alt1 */
        for (e : endOfLoop) {
        	var IOstsTransition increment = new IOstsTransition(e,finalInit)
        	increment.addAssignment(iName+" := "+iName+"+1")
        	increment.setComment("ForEachProtocol: end loop with increment")
        	currentProcess.addTransition(increment)
        }
        // end of alt1
        /* alt2
 		// add a concatenation if body ends with multiple states
        var int finalEndOfLoop
        if (endOfLoop.length > 1) {
        	finalEndOfLoop = currentProcess.newState()
        	// adding concatenations to get a unique final state for the body of ForEach
        	for (e : endOfLoop) {
	        	var IOstsTransition concatenation = new IOstsTransition(e,finalEndOfLoop)
	        	concatenation.setComment("ForEachProtocol: concatenation before increment")
	        	currentProcess.addTransition(concatenation)
	        }
        } else {
        	finalEndOfLoop = endOfLoop.get(0)
        }
        // increment
        var IOstsTransition increment = new IOstsTransition(finalEndOfLoop,finalInit)
        increment.addAssignment(iName+" := "+iName+"+1")
        increment.setComment("ForEachProtocol: end loop increment")
        currentProcess.addTransition(increment)
        // end of alt2
        */
        // transition: if (i > sizeof(setOfValues))
        val finalIfSup=currentProcess.newState()
        var IOstsTransition ifSup = new IOstsTransition(finalInit, finalIfSup)
        ifSup.setComment("ForEachProtocol: after foreach loop")
        ifSup.setGuard(iName+" > "+setOfValues+"::size()")
        currentProcess.addTransition(ifSup)
    	newArrayList(finalIfSup)
    }
    
    /*
     * - computeSTS for an AnyAction statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AnyAction a){
        val choose = newChooseProtocolActionFromConnections(currentProcess.connectionsMap)
        computeSTS(startState, choose)
    }
    
    /*
     * - computeSTS for a Done statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Done r){
        // do nothing!
        newArrayList(startState)
    }
    
    /*
     * - computeSTS for a RecursiveCall statement.
     *   same as Repeat of entire Behavior: loop to initial state
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RecursiveCall r){
        if (startState != 0) {
            var IOstsTransition t = new IOstsTransition(startState,0)
            t.setComment("Recursive call")
            currentProcess.addTransition(t)
            newArrayList(0) 
        }
    }    

    
    //=========================== Utility functions for handling IoSTS types
    
    def getIOstsType(String name) {
    	var IOstsType result = null
    	if (name == 'integer') {
    		result = new IOstsIntType()
    		if (result != null && DEBUG) {
    			System.err.println("getIOstsType: type '"+name+"' found: predefined.")
    		}
    	}
    	if (result == null && currentTypesMap != null) {
    		result = currentTypesMap.get(name)
    		if (result != null && DEBUG) {
    			System.err.println("getIOstsType: type '"+name+"' found in currentTypesMap.")	
    		}
    	}
	    if (result == null && currentSystem != null) {
            if (currentSystem.typesMap.containsKey(name)) {
                result = currentSystem.typesMap.get(name)
    			if (result != null && DEBUG) {
    				System.err.println("getIOstsType: type '"+name+"' found in currentSystem.typesMap.")
    			}
            }
        }
        if (result == null) {
        	result = getIOstsType(name, currentLibrary)
        	// If found, put it in currentLibrary.typesMap to accelerate further searches
        	if (result != null && !currentLibrary.typesMap.containsKey(name)) {
        		currentLibrary.addType(name, result)
        	}
        }
        result
	}
	
	/*
	 * Returns the name's IOstsType if found in the given library.
	 * The search is recursive, which means imported libraries are also checked.
	 */
	def IOstsType getIOstsType(String name, IOstsLibrary library) {
		var IOstsType result = null
		if (library.typesMap.containsKey(name)) {
            result = library.typesMap.get(name)
    		if (result != null && DEBUG) {
    			System.err.println("getIOstsType: type '"+name+"' found in library '"+library.name+"'.typesMap.")
    		}
        }
        if (result == null) {
        	for (lib : library.importedMap.values) {
        		if (result == null) {
        			result = getIOstsType(name, lib)
        		}
        	}
        }
        result
	}
	
	def finalNameOfIOstsType(String name) {
	    val IOstsType t = getIOstsType(name)
	    val finalName = if (t == null) {
	        if (DEBUG2) System.err.println("Warning: Type '"+name+"' not found! Assuming integer...")
	        (new IOstsIntType()).toString
	    } else switch t {
	        IOstsIntType: t.toString
	        IOstsBoolType: t.toString
	        default: name
	    }
	    if (DEBUG2) System.out.println("Final type name '"+name+"' = '"+finalName+"'.")
	    finalName
	}
	
	def nameOfIOstsType(IOstsType type) {
		var name=""
		if (currentTypesMap != null) {
			for (t : currentTypesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
    	}
	    if (name == "" && currentSystem != null) {
            for (t : currentSystem.typesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
        }
        if (name == "") {
        	for (t : currentLibrary.typesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            } 
        }
        if (name == "") {
        	for (lib : currentLibrary.importedMap.values) {
        		for (t : lib.typesMap.entrySet) {
	                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
	                if (t.value.equals(type)) {
	                    name=t.key
	                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
	                } else {
	                    if (DEBUG2) System.out.println("KO.")
	                }
            	}	
        	}
        }
        if (name == "") {
            name=type.toString()    
        }
        name
	}
	
	def dispatch IOstsType computeIOstsType(DataType t) {
	    switch t {
	        IntegerType: computeIOstsType(t)
	        SequenceType: computeIOstsType(t)
	        TupleType: computeIOstsType(t)
	        RangeType: computeIOstsType(t)
	        NamedType: computeIOstsType(t)
	        default: {
	            System.err.println("BUG! computeIOstsType of this datatype '"+t.toString+"' is not implemented! Assuming 'integer'...")
                new IOstsIntType()
	        }
	    }
	}
	
	
	def dispatch IOstsType computeIOstsType(IntegerType t) {
        new IOstsIntType()
    }
    
	def dispatch IOstsType computeIOstsType(SequenceType t) {
        // TODO: a relire et a tester !!!
        var String typeName = nameOfIOstsType(computeIOstsType(t.type))
        var IOstsType sequence = new IOstsSequenceType(new IOstsNamedType(typeName))
        sequence.setComment("sequence{"+typeName+"}")
        sequence
    }
	
	def dispatch IOstsType computeIOstsType(TupleType t) {
        var LinkedHashMap<String,IOstsType> fieldsMap=newLinkedHashMap()
        var comment="tuple{"
        var first=true
        for (f:(t as TupleType).fields) {
            val tn=f.type.compile.toString
            val _tt=computeIOstsType(f.type)
            val IOstsType tt = if (_tt instanceof IOstsIntType || _tt instanceof IOstsBoolType) _tt else new IOstsNamedType(tn)
            fieldsMap.put(f.name, tt)
            comment=comment.concat((if (first) "" else ",")+f.name+":"+tn)
            first=false
        }
        comment=comment.concat("}")
        var tuple=new IOstsTupleType(fieldsMap)
        tuple.setComment(comment)
        tuple
    }
    
    def dispatch IOstsType computeIOstsType(RangeType t) {
        //FIXME: min et max peuvent etre des constantes au lieu de nombres
        val int min=Integer.valueOf(t.vmin.compile.toString)
        val int max=Integer.valueOf(t.vmax.compile.toString)
        new IOstsRangeType(min, max)
    }
    
    def dispatch IOstsType computeIOstsType(NamedType t) {
    	computeIOstsType(t.name as String)
    }
    
    def dispatch IOstsType computeIOstsType(String t) {
    	var result1 = getIOstsType(t)
    	if (result1 == null) {
    		System.err.println("Warning! Type '"+t+"' is not declared! Assuming 'integer'...")
            result1=new IOstsIntType()
        } else {
        	if (DEBUG) System.err.println("Type '"+t+"' found. ok.")
    	}
    	result1
    }
    
    /*
     * TypeName generator: returns a new unused type id: BAD IDEA!
     *
    def String newIOstsTypeName() {
        this.lastIOstsTypeNum = this.lastIOstsTypeNum+1
        lastIOstsTypeName()
    }
    
    def String lastIOstsTypeName() {
        "$Type_"+this.lastIOstsTypeNum
    }
    */
}

//-------------- 
// IoSTS classes
//-------------- 

//-------------- IoSTS types and functions

/*
 * Function, has:
 * 
 * - name
 * - type: the return type
 * - dataName: name of data to which the function applies
 * - dataTypeName: name's type of data to which the function applies
 * - list of formal parameters
 * - a list of Valuing
 * - a return expression
 */
class IOstsFunction {
	val String name
	var String dataName = ""
	var IOstsType dataType = null
	var LinkedHashMap<String,IOstsType> formalParameters = newLinkedHashMap()
	var ArrayList<Valuing> valuings = newArrayList()
	var Expression returnExpression = null
	var IOstsType returnType = null
	
	// private thus inaccessible, because one cannot create function without name
    private new() {
    	name = ""
    }
    
	// constructor and name
	new(String name) {
		this.name = name
	}

	def name() {
		this.name
	}
	
	// data on which the function applies
	def setData(String name, IOstsType type) {
		this.dataName = name
		this.dataType = type
	}
	
	def getDataName() {
		this.dataName
	}
	
	def getDataType() {
		this.dataType
	}
	
	// formal parameters
	def addFormalParameter(String name, IOstsType type) {
		this.formalParameters.put(name, type)
	}
	
	def formalParameter() {
		this.formalParameters
	}
	
	def getFormalParameterType(String name) {
		this.formalParameters.get(name)
	}
	
	// list of valuings
	def addValuing(Valuing v) {
		this.valuings.add(v)
	}
	
	def valuings() {
		this.valuings
	}
	
	// return type and expression
	def setReturnType(IOstsType type) {
		this.returnType = type
	}
	
	def returnType() {
		this.returnType
	}
	
	def setReturnExpression(Expression e) {
		this.returnExpression = e
	}
	
	def returnExpression() {
		this.returnExpression
	}
}

/*
 * List of IOstsFunctions
 */
class IOstsListOfFunctions extends ArrayList<IOstsFunction> {
	
	new() {
		super()
	}
	
	def addFunction(IOstsFunction f) {
    	this.add(f)
    }
    
    def getFunction(String name) {
    	var IOstsFunction result=null
    	var i=0
    	while (i < this.length && result==null) {
    		if (this.get(i).name.equals(name)) {
    			result = this.get(i)
    		}
    	}
    	result
    }
}

/*
 * Type: is the superclass of all types.
 */
class IOstsType {
    var String comment=""
    var IOstsListOfFunctions functions = new IOstsListOfFunctions()
    
    def setComment(String comment) {
        this.comment = comment
    }
   
    def comment() {
        this.comment
    }
    
    def functions() {
    	this.functions
    }
    
    def boolean equals (IOstsType other) {
        switch other {
            IOstsIntType: this.equals(other)
            IOstsBoolType: this.equals(other)
            IOstsRangeType: this.equals(other)
            IOstsTupleType: this.equals(other)
            IOstsSequenceType: this.equals(other)
            IOstsNamedType: this.equals(other)
            default: this.equals(other)
        }
    }
}

class IOstsIntType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "integer"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsIntType)
    }
}

class IOstsBoolType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "boolean"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsBoolType)
    }
}

class IOstsRangeType extends IOstsType {
    
    int min
    int max
    
    // private thus inaccessible, because one cannot create range without min and max values
    private new() {
        min = 0
        max = 0
    }
    
    new(int min, int max) {
        this.min = min
        this.max = max
    }
    
    def min() {
        this.min
    }
    
    def max() {
        this.max
    }
    
    override def String toString() {
        "range{"+min+".."+max+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsRangeType) {
            (other.min == min) && (other.max == max)
        } else {
            false
        }
    }
}

class IOstsTupleType extends IOstsType {
    
    public val LinkedHashMap<String,IOstsType> fieldsMap   // map of (name -> type)
    
    // private thus inaccessible, because one cannot create tuple without fields
    private new() {
        fieldsMap = newLinkedHashMap() 
    }
    
    new(LinkedHashMap<String,IOstsType> listOfFields) {
        fieldsMap = listOfFields
    }
    
    override def String toString() {
        var String inner=""
        for (f:fieldsMap.entrySet) {
            inner = inner.concat(f.key+":"+f.value.toString+",")
        }
        "tuple{"+inner+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsTupleType) {
            if (other.fieldsMap.size != fieldsMap.size)
                false
            else {
                var boolean ok1=true
                val size=this.fieldsMap.size
                val ArrayList<Entry<String,IOstsType>> fields1 = newArrayList(this.fieldsMap.entrySet)
                val ArrayList<Entry<String,IOstsType>> fields2 = newArrayList(other.fieldsMap.entrySet)
                var i=0
                while(i < size) {
                    val ok2 = ((fields1.get(i).key == fields2.get(i).key) && (fields1.get(i).value.equals(fields2.get(i).value)))
                    ok1 = (ok1 && ok2)
                    i = i+1
                }
                ok1
            }
        } else false
    }
}

class IOstsSequenceType extends IOstsType {
    
    val IOstsType type
    
    // private thus inaccessible, because one cannot create array without size
    private new() {
        type = new IOstsIntType()
    }
    
    new(IOstsType type) {
        this.type = type
    }
    
    override def String toString() {
        "sequence{"+type.toString+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsSequenceType) {
            other.type.equals(type)
        } else {
            false
        }
    }
}


/*
class IOstsArrayType extends IOstsType {
    
    val int size
    val IOstsType type
    
    // private thus inaccessible, because one cannot create array without size
    private new() {
        size = 0
        type = new IOstsIntType()
    }
    
    new(int size, IOstsType type) {
        this.size = size
        this.type = type
    }
    
    override def String toString() {
        "array["+size+"] of "+type.toString
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsArrayType) {
            if (other.size != size) {
                false
            } else {
                other.type.equals(type)
            }
        } else {
            false
        }
    }
}
*/

class IOstsNamedType extends IOstsType {
    
    val String name
    
    new(String name) {
        this.name = name
    }
    
    override def String toString() {
        name
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsNamedType) {
            other.name == name
        } else {
            false
        }
    }
}

//-------------- Connection, Transition, Process and IOstsSystem

/*
 * Connection
 * 
 * Notes:
 * - name, type, and mode are required at creation time, and immutable.
 * - connections in IOSTS and in SoS-ADL are identical.
 * - now, the mode of IoSTS's connection are the same as in SoSADL: 'in', 'out', 'inout'.
 */
class IOstsConnection {
    val String name
    val String typeName
    val String mode // FIXME! enum au lieu de string!
    
    new(String name, String typeName, String mode) {
        this.name=name
        this.typeName=typeName
        this.mode=mode
    }
    
    def name() {
        this.name
    }
    
    def typeName() {
        this.typeName 
    }
    
    def mode() {
        this.mode
    }
    
    override def String toString() {
        switch mode {
            case "in":
                "  "+name+"("+typeName+");\n"
            case "out":
                "  "+name+"("+typeName+");\n"
            case "inout":
                "  "+name+"("+typeName+");\n"+
                "  "+name+"("+typeName+");\n"
        } 
    }
    
}


/*
 * A IOstsTransition
 * 
 * Note:
 * - fromState and toState are immutable and must be set at creation time.
 * - guard and assignments are optional, thus mutable.
 * - action is mutable thought it is required (tau by default):
 *   this is because it can be initialized after creation.
 *   Note: in the first transition, no sync is allowed.
 * - a comment helps to understand the transformation from SoDADL to IOSTS
 */
class IOstsTransition {
	val int fromState
	val int toState
	var boolean init
	String comment=""
	String guard = "" // optional
	String action = "unobservable" // default action is unobservable
	List<String> assignments = newArrayList // optional

	/* never used!
	new(int fromState, int toState, String action) {
		this.fromState = fromState
		this.toState = toState
		this.action = action
		this.init = false
	}
	*/

	new(int fromState, int toState) {
		this.fromState = fromState
		this.toState = toState
		this.init = false
	}

	def setInit(boolean init) {
		this.init = init
		if (init && guard.empty) {
			guard = "true" // default value for the init transition
		}
	}
	
	def fromState() {
		fromState
	}
	
	def toState() {
		toState
	}

	def setComment(String comment) {
		this.comment = comment
	}

	def setGuard(String guard) {
		this.guard = guard
	}

	def setAction(String action) {
		if (init) {
			System.err.println("Warning! Init transition does not admit action! Ignoring action...")
		} else {
			this.action = action
		}
	}

	def addAssignment(String statement) {
		if (init) {
			System.err.println("Warning! Init transition does not admit statement! Ignoring action...")
		} else {
			assignments.add(statement)
		}
		
	}

	override def String toString() {
		if (init) {
		'''
			from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
			    guard {
			    	«guard»
			    }
			to s«toState»
		'''
		} else {
		'''
			from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
			    «IF !guard.empty»
			    guard {
			    	«guard»
			    }
			    «ENDIF»
			  	action {
			  		«action»
			  	}
			  	«IF assignments.length > 0»
			  	assignments {
			  	    «assignments.join(",\n")»
			  	}
			  	«ENDIF»
			to s«toState»
		'''
		}
	}
}

/*
 * A IOstsProcess
 * 
 * Note:
 * - has an immutable name, which is required at creation time.
 * - connectionsMap: map of connexions declared for this specific process (protocol of gate or duty, behavior)
 * - inputMap, outputMap, and parametersMap are mutable maps of input, output of the Process.
 * - inoutputMap is a map that lives only during the translation from SoS-ADL to IOSTS
 *   because SOS-ADL has inout connections.
 * - parametersMap, and variablesMap are mutable maps containing parameters and variables of the process.
 * - globalsMap is a mutable map containing global variables used in the process.
 * - transitions is the mutable list of the transitions.
 * - lastState is an int used internally to assign names to states.
 * - lastParameterNumber is an int used internally to assign names to parameters.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 */
class IOstsProcess{
    val String name
    var String comment=""
    var boolean first = true 
    public var LinkedHashMap<String,IOstsConnection> connectionsMap = newLinkedHashMap()  // map of (connection name -> Connection)
    public var inputMap = newLinkedHashMap()    // map of (in connection -> type name)
    public var outputMap = newLinkedHashMap()   // map of (out connection -> type name)
    public var inoutputMap = newLinkedHashMap() // map of (inout connection -> type name)
    public var parametersMap = newLinkedHashMap()  // map of (received variable -> type name)
    public var globalsMap = newLinkedHashMap()  // map of (global variable -> type name) 
    public var variablesMap = newLinkedHashMap()  // map of (variable -> type name) 
    public var List<IOstsTransition> transitions = newArrayList()
    var int lastState = 0 // number of the last state, starting at 0.
    var int lastParameterNumber = 0  // number of the last generated parameter

    new(String name) {
        this.name=name
    }
    
    def String name() {
        this.name
    }
    
    def setComment(String comment) {
        this.comment = comment
    }
    
    def addAllConnections(LinkedHashMap<String,IOstsConnection> connectionsMap) {
    	this.connectionsMap.putAll(connectionsMap)
    }
    
    /*
    def addConnection(IOstsConnection connection) {
        this.connectionsMap.put(connection.name, connection)
    }
    */
    
    def getConnection(String name) {
    	connectionsMap.get(name)
    }
    
    def addInput(String name, String typeName) {
        this.inputMap.put(name, typeName)
    }
    
    def addOutput(String name, String typeName) {
        this.outputMap.put(name, typeName)
    }
    
    def addInoutput(String name, String typeName) {
        this.inoutputMap.put(name, typeName)
    }
    
    def addParameter(String name, String typeName) {
        this.parametersMap.put(name, typeName)
    }
    
    def addGlobal(String name, String typeName) {
    	if (this.variablesMap.containsKey(name)) {
    		System.err.println("Warning! Global var '"+name+"' is already declared as local variable! Ignoring...")
        }
        else if (this.globalsMap.containsKey(name)) {
    		if (! this.globalsMap.get(name).equals(typeName)) {
    			System.err.println("Warning! Global var '"+name+"' is already declared with type '"+this.globalsMap.get(name)+"'! Ignoring...")
    		} // else: global variable 'name' is already declared with same type: ok.
    	} else {
    		this.globalsMap.put(name, typeName)	
    	}
    }
    
    def addGlobal(String name) {
        addGlobal(name, new IOstsIntType().toString)
    }
    
    def addVariable(String name, String typeName) {
        this.variablesMap.put(name, typeName)
    }
    
    def addVariable(String name) {
        addVariable(name, new IOstsIntType().toString)
    }
    
    /*
     * addTransition(transition):
     * - if a transition with same fromState and toState exists, then remove it from the transitions.
     * - adds transition to the list of transitions.
     * - updates lastState with fromState (resp. finalState) in case lastState < fromState (resp. finalState)
     */
    def addTransition(IOstsTransition transition) {
    	if (this.transitions.empty) {
    		transition.setInit(true)
    	}
    	if (this.transitions.exists[fromState() == transition.fromState() && toState() == transition.toState()]) {
    		val t = this.transitions.findFirst[fromState() == transition.fromState() && toState() == transition.toState()]
    		this.transitions.remove(t)
    	}
    	this.transitions.add(transition)	
    	if (this.lastState < transition.fromState()) {
    		this.lastState = transition.fromState()
    	}
    	if (this.lastState < transition.toState()) {
    		this.lastState = transition.toState()
    	}
    }
    
    def getTransition(int startState, int finalState) {
    	this.transitions.findFirst[fromState() == startState && toState() == finalState]
    }
    
    /*
     * Returns a new unused state id 
     */
    def int newState() {
        this.lastState = this.lastState+1
        this.lastState
    }
    
    def lastState() {
        this.lastState
    }
    
    /*
     * Returns a new unused parameter name
     */
    def newParameter() {
        this.lastParameterNumber = this.lastParameterNumber+1
        this.lastParameter()
    }
    
    def lastParameter() {
        this.name+"_p"+this.lastParameterNumber
    }
    
    /*
     * Returns the text of the IOSTS Process
     *
     * OLD version:
    override def String toString()'''
    process «name»;
    «IF !inputMap.empty»
    
    input  
      «inputMap.keySet.join(",\n")»;
    «ENDIF»
    «IF !outputMap.empty»
    
    output
      «outputMap.keySet.join(",\n")»;
    «ENDIF»
      
    internal
      tau;
    «IF !parametersMap.empty»
    
    parameters // stg says they have already been declared!
      «FOR p:parametersMap.keySet»
      //«p» : «parametersMap.get(p)»; 
      «ENDFOR»
    «ENDIF»
    «IF !variablesMap.empty»
    
    variables
      «FOR v:variablesMap.entrySet»
      «v.key» : «v.value»;
      «ENDFOR»
    «ENDIF»
    
    state
      init: s0;
      «FOR s:1..lastState»
      s«s»;
      «ENDFOR»  
    
    transition
    «FOR t:transitions»
    «t.toString»
    «ENDFOR»
    '''
    */
    
    override def String toString()'''
    {
    	«IF !parametersMap.empty»
    	messages {
    		«FOR p:parametersMap.keySet»
    		«p» is «parametersMap.get(p)» 
    		«ENDFOR»
    	}
    	«ENDIF»
    	«IF !globalsMap.empty»
    	globals {
    		«FOR g:globalsMap.entrySet»
    		«g.key» is «g.value»
    		«ENDFOR»
    	}
    	«ENDIF»
    	«IF !variablesMap.empty»
    	variables {
    		«FOR v:variablesMap.entrySet»
    		«v.key» is «v.value»
    		«ENDFOR»
    	}
    	«ENDIF»
    	states {
    		init{s0}«FOR s:1..lastState» s«s»«ENDFOR»
    	}
    	transitions {
    		«FOR t:transitions»
    		«t.toString»
    		
    		«ENDFOR»
    	}
    }
    '''
}

/*
 * IOstsSystem
 * 
 * Notes:
 * - has an immutable name, which is required at creation time.
 * - fileName is the name of the file to be saved.
 * - constantsMap is not used at this time.
 * - typesMap is a mutable map containing the declaration of all types used in this system.
 * - processesMap is the map of processes of this system.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 * It is possible to get allConnections declared inside gate/duty of this system. 
 */
class IOstsSystem{
    val String name
    var String comment=""
    //OLD version: not needed anymore: var String behaviorName="UNDEFINED"
    public var LinkedHashMap<String,String> constantsMap = newLinkedHashMap()     // map of (name -> value as tring)
    public var LinkedHashMap<String,IOstsType> typesMap = newLinkedHashMap()     // map of (name -> iosts type)
    public var LinkedHashMap<String,IOstsProcess> processesMap = newLinkedHashMap()  // map of (process name -> Process)
    
    new(String name) {
       this.name=name
    }
    
    def getName() {
    	this.name
    }
    
    def setComment(String comment) {
       this.comment = comment
    }
    
    // Returns all connections known to this system.
    // These connections are declared in local gate/duty or behavior
    def LinkedHashMap<String,IOstsConnection> allConnections() {
    	var allConnections = newLinkedHashMap()
    	for (p : processesMap.entrySet) {
    		allConnections.putAll(p.value.connectionsMap)
    	}
    	allConnections
    }
    
    def getConnection(String name) {
    	val allConnections = allConnections()
    	allConnections.get(name)
    }
    
    def addProcess(IOstsProcess process) {
        // Sometimes, for example when "behavior{done}", the sts is empty.
        // In those cases, do not add the process, because it is invalid! 
        if (process.transitions.empty) {
            System.err.println("Warning! Process '"+process.name+"' is empty! Ignoring...")
        } else {
            /* OLD version: now, there is no need anymore to distinguish protocol process from behavior process.
            if (process.name.contains("_behavior")) {
                behaviorName=process.name
            }
            */
            this.processesMap.put(process.name, process)
        }
    }
    
    /*
     * empty returns true if no process has been generated.
     */
    def empty() {
        processesMap.empty
    }
    
    // OLD version: IOstsSystem.toString is never called.
    /*
    override def String toString() {
        // generate something only if there is at least one process
        if (empty) {
            System.err.println("Warning! System '"+name+"' defines no process! Ignoring...")
            ""
        } else {     
    '''
    / *
    Generated by org.archware.sosadl.generator.SosADL2IOSTSGenerator
    
    WARNING #1: The generator is a work in progress! This IOSTS file may not be complete!
    WARNING #2: The generator assumes the SoSADL source is correct.
                Otherwise, STG may not compile this IOSTS file. 

    Run it with:
      «IF processesMap.size == 1 && behaviorName != "UNDEFINED"»
        stg «fileName» -test_name «behaviorName»
      «ELSE»
        «FOR p:processesMap.values»
        «IF p.name.endsWith("_protocol")»
        stg «fileName» -test_name «behaviorName» -test_purpose_name «p.name»
        «ENDIF»
        «ENDFOR»
      «ENDIF»
    * /
    
    system «name»;
    «IF !constantsMap.empty»
    
    constant
      «FOR c:constantsMap.entrySet»
        «c.key» = «c.value»
      «ENDFOR»
    «ENDIF»
    «IF !typesMap.empty»
    
    type
      «FOR t:typesMap.entrySet»
        «val tk = t.key»
        «val tv = t.value»
        «IF tv.toString == "int"»
          // «tk» = int;
        «ELSE»
          «tk» = «tv»;
        «ENDIF»
      «ENDFOR»
    «ENDIF»
    
    gate
    «FOR g:connectionsMap.values»
    «g.toString»
    «ENDFOR»
    «FOR p:processesMap.values»
    
    //--------------------------------------------------
    «p.toString»
    «ENDFOR»
    '''}
    }
    */
}

/*
 * IOstsLibrary
 * 
 * Notes:
 * - has an immutable name, which is required at creation time.
 * - fileName is the name of the file to be saved.
 * - importedMap is a mutable map containing the list of imported libraries
 * - typesMap is a mutable map containing the locally declared types
 * - systemsMap is a mutable map containing the locally declared systems
 * 
 * In SoSADL, SoS and Library declare the same elements (an EntityBlock).
 * Thus, after translated in IoSTS, we use an IOstsLibrary instance to store
 * all iosts types and systems coming from either an SoS or a Library.
 */
class IOstsLibrary{
    val String name
    var String fileName=""
	public var LinkedHashMap<String,IOstsLibrary> importedMap = newLinkedHashMap()  // map of (name -> imported iosts library)
    public var LinkedHashMap<String,IOstsType> typesMap = newLinkedHashMap()     // map of (name -> iosts type)
    public var IOstsListOfFunctions functions = new IOstsListOfFunctions()       // list of declared functions
    public var LinkedHashMap<String,IOstsSystem> systemsMap = newLinkedHashMap()  // map of (name -> iosts system)
    
    new(String name) {
       this.name=name
    }
    
    def name() {
    	this.name
    }
    
    def setFileName(String fileName) {
       this.fileName = fileName
    }
    
    def fileName() {
        fileName
    }
    
    // Returns all iosts imported library
    def LinkedHashMap<String,IOstsLibrary> importedLibraries() {
    	this.importedMap
    }
    
    def getImportedLibrary(String name) {
    	this.importedMap.get(name)
    }
    
    def addImportedLibrary(IOstsLibrary library) {
        this.importedMap.put(library.name, library)
    }
    
    // Returns all locally declared types
    def LinkedHashMap<String,IOstsType> types() {
    	this.typesMap
    }
    
    def getType(String name) {
    	this.typesMap.get(name)
    }
    
    def addType(String name, IOstsType type) {
        this.typesMap.put(name, type)
    }
    
    // Returns all locally declared functions
    def functions() {
    	this.functions
    }
    
    // Returns all iosts systems declared in this library
    def LinkedHashMap<String,IOstsSystem> systems() {
    	this.systemsMap
    }
    
    def getSystem(String name) {
    	this.systemsMap.get(name)
    }
    
    def addSystem(IOstsSystem system) {
        this.systemsMap.put(system.name, system)
    }
}
