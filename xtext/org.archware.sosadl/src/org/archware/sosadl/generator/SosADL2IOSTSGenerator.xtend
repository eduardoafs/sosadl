/*
 * generated by Xtext
 */
package org.archware.sosadl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.archware.sosadl.sosADL.*
import org.archware.sosadl.SosADLStandaloneSetupGenerated
import org.eclipse.emf.common.util.URI
import org.archware.sosadl.SosADLComparator
import org.eclipse.xtext.parser.IParser
import java.io.StringReader
import java.util.LinkedHashMap
import java.util.ArrayList
import java.util.List

//import org.archware.iosts.ui.contentassist.AbstractIoSTSProposalProvider

/**
 * Generates IOSTS code from the given SosADL model files on save.
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class SosADL2IOSTSGenerator implements IGenerator {
    
    // global variables making the generation much easier
    val DEBUG=false
    var String resourceFilename = null          // current SoSADL file name to be transformed
    var globalTypesMap = newLinkedHashMap()     // map of (types -> typeDecl)
    var List<IoSTS_System> systems = null       // list of generated systems from one SoSADL file
    var IoSTS_System currentSystem = null       // system currently generated
    var Process currentProcess = null           // process currently generated
    
    
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		for (e : resource.allContents.toIterable.filter(SosADL)) {
		    var first=true
		    resourceFilename = e.eResource.URI.trimFileExtension.lastSegment
            System.out.print("Transforming '"+e.eResource.URI.lastSegment+"'")
            systems = newLinkedList()
            e.compile
            if (DEBUG) System.out.println("--------- "+e.eResource.URI.lastSegment+" (starts) ----")
            for (s:systems) {
                if (DEBUG) {
                    System.out.println("----> "+s.fileName+" (starts) ----")
                    System.out.println(s.toString)
                }
                else {
                    System.out.print((if (first) " into: " else ", ")+"'"+s.fileName+"'")
                    first=false
                }
                fsa.generateFile(s.fileName, s.toString)
                if (DEBUG) System.out.println("----> "+s.fileName+" (ends) ------")
            }
            if (DEBUG) System.out.println("--------- "+e.eResource.URI.lastSegment+" (ends) ------")
            System.out.println(". done.")
		}
	}
    
	def compile(SosADL s) {
	globalTypesMap = newLinkedHashMap()
	'''
    «FOR i : s.imports»
      «i.compile»
    «ENDFOR»

    «IF s.content instanceof Library»
      «(s.content as Library).compile»
    «ELSEIF s.content instanceof SoS»
      «(s.content as SoS).compile»
    «ENDIF»
	'''
	}
	

	def compile(Import i)'''
	'''

	def compile(Library l)'''
    «l.decls.compile»
    '''

	def compile(SoS s)'''
    «s.decls.compile»
    '''

	def compile(EntityBlock e)'''
    «FOR d : e.datatypes»
      «d.compile»
    «ENDFOR»
    «FOR f : e.functions»
      «f.compile»
    «ENDFOR»
    
    «FOR s : e.systems»
      «s.compile»
    «ENDFOR»
    «FOR m : e.mediators»
      «m.compile»
    «ENDFOR»
    «FOR a : e.architectures»
      «a.compile»
    «ENDFOR»
	'''

	def compile(SystemDecl s){
	  currentSystem = new IoSTS_System(s.name)
	  currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+s.name+".iosts")
	  s.parameters.map[compile]
	  for (d : s.datatypes) {
        d.compile
      }
      for (g : s.gates) {
        g.compile
      }
      s.behavior.compile
      systems.add(currentSystem)
      currentSystem=null
    }

	def compile(ArchitectureDecl a){
	  currentSystem = new IoSTS_System(a.name)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+a.name+".iosts")
      a.parameters.map[compile]
      for (d : a.datatypes) {d.compile}
      for (g : a.gates) {g.compile}
      if (a.assertion != null) {a.assertion.compile}
      a.behavior.compile
      systems.add(currentSystem)
      currentSystem=null
    }

    def compile(MediatorDecl m){
      currentSystem = new IoSTS_System(m.name)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+m.name+".iosts")
      m.parameters.map[compile]
      for (d : m.datatypes) {
        d.compile
      }
      for (d : m.duties) {
        d.compile
      }
      m.behavior.compile
      systems.add(currentSystem)
      currentSystem=null
    }
	
	def compile(GateDecl g){
	    for (c : g.connections) {
	        val name=g.name+"_"+c.name
	        currentSystem.addGate(new Gate(name, c.valueType.compile.toString, c.mode.toString))
	    }
	    '''«g.protocol.compile»'''
	}

	
	def compile(DutyDecl d){
        for (c : d.connections) {
            val name=d.name+"_"+c.name
            currentSystem.addGate(new Gate(name, c.valueType.compile.toString, c.mode.toString))
        }
        '''«d.protocol.compile»'''
    }
	
	def compile(Connection c)'''«IF c.environment»environment «ENDIF»connection «c.name» is «c.mode»{«c.valueType.compile»}'''
	
	def compile(AssertionDecl a)''''''
    
    def compile(ProtocolDecl p) {
        currentProcess = new Process(p.name+"_protocol")
        computeSTS(0,p.body)
        currentSystem.addProcess(currentProcess)
        '''«p.toString»'''
    }
    
    def CharSequence compile(Protocol p)''''''
	
	def compile(ProtocolStatement p)''''''
	
	def compile(IfThenElseProtocol i)''''''
	
	def compile(ChooseProtocol c)''''''
	
	def compile(ForEachProtocol f)''''''
	
	def compile(DoExpr d)'''
    do «d.expression.compile»
	'''
	
	def compile(RepeatProtocol r)'''''' 
	
	def compile(Done d)''''''  // nothing = no STS to be generated
	    
    def compile(ProtocolAction p)''''''
    
    def compile(SendProtocolAction s)''''''
    
    def compile(ReceiveAnyProtocolAction r)''''''
    
    def compile(ReceiveProtocolAction r)''''''
    
    def compile(AnyAction a)''''''
    
    def compile(BehaviorDecl b){
        //if (currentProcess != null) currentSystem.addProcess(currentProcess)
        currentProcess = new Process(b.name+"_behavior")
        computeSTS(0,b.body)
        currentSystem.addProcess(currentProcess)
        ''''''
    }
    
    /*
     * All computeSTS() functions return the final states of the STS
     * according to the behavior starting at startState.
     */
    /*
     * - computeSTS for a Behavior (which is a sequence of BehaviorStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Behavior b) {
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        for (s : b.statements) {
            // in a sequence, one has to add a transition with no action between two statements
            if ((s instanceof Action) && startState==0 && state==0) {
                state=currentProcess.newState()
                var Transition concatenation = new Transition(startState,state) //tau
                concatenation.setComment("Empty transition, because sync is not allowed in first transition")
                currentProcess.addTransition(concatenation)
                //System.out.println("Added empty transition, because sync is not allowed in first transition": from="+state+", to="+state)
            } else if (! first) {
                state=currentProcess.newState()
                var Transition concatenation = new Transition(finalStates.get(0),state) //tau
                concatenation.setComment("Concatenation (sequentiality)")
                currentProcess.addTransition(concatenation)
                //System.out.println("Added concatenation transition: from="+finalStates.get(0)+", to="+state)
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            finalStates = computeSTS(state, s)
            first=false
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Protocol (which is a sequence of ProtocolStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Protocol b){
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        for (s : b.statements) {
            // in a sequence, one has to add a transition with no action between two statements
            if ((s instanceof ProtocolAction) && startState==0 && state==0) {
                state=currentProcess.newState()
                var Transition concatenation = new Transition(startState,state) //tau
                concatenation.setComment("Empty transition, because sync is not allowed in first transition")
                currentProcess.addTransition(concatenation)
                //System.out.println("Added empty transition, because sync is not allowed in first transition": from="+state+", to="+state)
            } else if (! first) {
                state=currentProcess.newState()
                var Transition concatenation = new Transition(finalStates.get(0),state) //tau
                concatenation.setComment("Concatenation (sequentiality)")
                currentProcess.addTransition(concatenation)
                //System.out.println("Added concatenation transition: from="+finalStates.get(0)+", to="+state)
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            finalStates = computeSTS(state, s)
            first=false
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Valuing statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Valuing v){
        val int final=currentProcess.newState()
        var Transition valuing = new Transition(startState,final)
        valuing.addStatement(v.compile.toString)
        valuing.setComment("Valuing")
        currentProcess.addTransition(valuing)
        //System.out.println("Added valuing transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Send/Receive Behavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Action a){
        val int final=currentProcess.newState()
        var Transition action = new Transition(startState,final)
        var String channel=a.complexName.compile.toString
        if (a.suite instanceof SendAction) {
            val parameter=currentProcess.newParameter()
            val Gate gate=currentSystem.gatesMap.get(channel)
            if (! currentProcess.outputMap.containsKey(channel) && ! currentProcess.inoutputMap.containsKey(channel)) {
                if (gate.mode == "out") {
                    currentProcess.addOutput(channel, gate.type)
                } else { // gate.mode == "inout"
                    currentProcess.addInoutput(channel, gate.type)
                    channel = channel.concat("_out")
                    currentProcess.addOutput(channel, gate.type)
                }
            }
            action.setGuard(parameter+" = "+(a.suite as SendAction).expression.compile)
            action.setAction(channel+"!("+parameter+")")
            action.setComment("Send action")
            currentProcess.addParameter(parameter,gate.type)
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAction) {
            val variable=(a.suite as ReceiveAction).variable
            val parameter=variable+"_data"
            val Gate gate=currentSystem.gatesMap.get(channel)
            if (! currentProcess.inputMap.containsKey(channel) && ! currentProcess.inoutputMap.containsKey(channel)) {
                if (gate.mode == "in") {
                    currentProcess.addInput(channel, gate.type)
                } else { // gate.mode == "inout"
                    currentProcess.addInoutput(channel, gate.type)
                    channel = channel.concat("_in")
                    currentProcess.addInput(channel, gate.type)
                }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, gate.type)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, gate.type)
            }
            action.setAction(channel+"?("+parameter+")")
            action.addStatement(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }

    /*
     * - computeSTS for a Send/Receive Protocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ProtocolAction a){
        val int final=currentProcess.newState()
        var Transition action = new Transition(startState,final)
        var String channel=a.complexName.compile.toString
        if (a.suite instanceof SendProtocolAction) {
            val parameter=currentProcess.newParameter()
            val Gate gate=currentSystem.gatesMap.get(channel)
            if (! currentProcess.outputMap.containsKey(channel) && ! currentProcess.inoutputMap.containsKey(channel)) {
                if (gate.mode == "out") {
                    currentProcess.addOutput(channel, gate.type)
                } else { // gate.mode == "inout"
                    currentProcess.addInoutput(channel, gate.type)
                    channel = channel.concat("_out")
                    currentProcess.addOutput(channel, gate.type)
                }
            }
            action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
            action.setAction(channel+"!("+parameter+")")
            action.setComment("Send action")
            currentProcess.addParameter(parameter,gate.type)
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveProtocolAction) { 
            val variable=(a.suite as ReceiveProtocolAction).variable
            val parameter=variable+"_data"
            val Gate gate=currentSystem.gatesMap.get(channel)
            if (! currentProcess.inputMap.containsKey(channel) && ! currentProcess.inoutputMap.containsKey(channel)) {
                if (gate.mode == "in") {
                    currentProcess.addInput(channel, gate.type)
                } else { // gate.mode == "inout"
                    currentProcess.addInoutput(channel, gate.type)
                    channel = channel.concat("_in")
                    currentProcess.addInput(channel, gate.type)
                }
            }
            
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, gate.type)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, gate.type)
            }
            action.setAction(channel+"?("+parameter+")")
            action.addStatement(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAnyProtocolAction) {
            val variable="any_s"+startState
            val parameter=variable+"_data"
            val Gate gate=currentSystem.gatesMap.get(channel)
            if (! currentProcess.inputMap.containsKey(channel) && ! currentProcess.inoutputMap.containsKey(channel)) {
                if (gate.mode == "in") {
                    currentProcess.addInput(channel, gate.type)
                } else { // gate.mode == "inout"
                    currentProcess.addInoutput(channel, gate.type)
                    channel = channel.concat("_in")
                    currentProcess.addInput(channel, gate.type)
                }
            }
            
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, gate.type)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, gate.type)
            }
            action.setAction(channel+"?("+parameter+")")
            action.addStatement(variable+" := "+parameter)
            action.setComment("Receive any action")
            //System.out.println("Added receive any transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var Transition ifTrue = new Transition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment("IfThenElse (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var Transition ifFalse = new Transition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment("IfThenElse (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }

    /*
     * - computeSTS for a IfThenElseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var Transition ifTrue = new Transition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment("IfThenElse (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var Transition ifFalse = new Transition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment("IfThenElse (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    /*
     * - computeSTS for a ChooseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseBehavior c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            val final=currentProcess.newState()
            var Transition t = new Transition(startState,final)
            t.setComment("Choose case")
            currentProcess.addTransition(t)
            //System.out.println("Added choose transition: from="+startState+", to="+final)
            finalStates.addAll(computeSTS(final, b))
        }
        finalStates
    }

    /*
     * - computeSTS for a ChooseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseProtocol c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            val final=currentProcess.newState()
            var Transition t = new Transition(startState,final)
            t.setComment("Choose case")
            currentProcess.addTransition(t)
            //System.out.println("Added choose transition: from="+startState+", to="+final)
            finalStates.addAll(computeSTS(final, b))
        }
        finalStates
    }
        
    /*
     * - computeSTS for a RepeatBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatBehavior r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            var Transition t = new Transition(final,startState)
            t.setComment("Repeat loop")
            currentProcess.addTransition(t)
            //System.out.println("Added repeat transition: from="+final+", to="+startState)
        }
        newArrayList(startState) 
    }

    /*
     * - computeSTS for a RepeatProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatProtocol r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            var Transition t = new Transition(final,startState)
            t.setComment("Repeat loop")
            currentProcess.addTransition(t)
            //System.out.println("Added repeat transition: from="+final+", to="+startState)
        }
        newArrayList(startState) 
    }
        
    /*
     * - computeSTS for a Assert statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Assert r){
        // TODO!
        val int final=currentProcess.newState()
        var Transition assert = new Transition(startState,final)
        assert.setComment("TODO! Assert")
        currentProcess.addTransition(assert)
        //System.out.println("Added fake assert transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a ForEachBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachBehavior r){
        // TODO!
        val int final=currentProcess.newState()
        var Transition foreach = new Transition(startState,final)
        foreach.setComment("TODO! ForEachBehavior")
        currentProcess.addTransition(foreach)
        //System.out.println("Added fake foreach transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a ForEachProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachProtocol r){
        // TODO!
        val int final=currentProcess.newState()
        var Transition foreach = new Transition(startState,final)
        foreach.setComment("TODO! ForEachProtocol")
        currentProcess.addTransition(foreach)
        //System.out.println("Added fake foreach transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a DoExpr statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, DoExpr r){
        // TODO!
        val int final=currentProcess.newState()
        var Transition doExpr = new Transition(startState,final)
        doExpr.setComment("TODO! DoExpr")
        currentProcess.addTransition(doExpr)
        //System.out.println("Added fake DoExpr transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for an AnyAction statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AnyAction a){
        // TODO!
        val int final=currentProcess.newState()
        var Transition anyAction = new Transition(startState,final)
        anyAction.setComment("TODO! AnyAction")
        currentProcess.addTransition(anyAction)
        //System.out.println("Added fake anyAction transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Done statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Done r){
        // do nothing!
        newArrayList(startState)
    }
    
    /*
     * - computeSTS for a RecursiveCall statement.
     *   same as Repeat of entire Behavior: loop to initial state
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RecursiveCall r){
        var Transition t = new Transition(startState,0)
        t.setComment("Recursive call")
        currentProcess.addTransition(t)
        newArrayList(0) 
    }
        
	def compile(ArchBehaviorDecl a)''''''
	
	def compile(Constituent c)''''''

    def compile(Binding b)''''''
    
    def compile(Relay r)''''''

	def compile(Unify u)''''''

	def compile(Quantify q)''''''
	
	def compile(ElementInConstituent e)''''''
	
	def compile(DataTypeDecl d){
	   if (currentSystem != null) {
	       currentSystem.typesMap.put(d.name,if (d.datatype != null) d.datatype.compile else "int")
	   } else {
	       // the datatype declaration here occurs before the system/mediator/architecture declaration
	       globalTypesMap.put(d.name,if (d.datatype != null) d.datatype.compile else "int")
	   }
	''''''
	}
	
	def CharSequence compile(DataType d)'''«
	IF d instanceof IntegerType»«
	  (d as IntegerType).compile»«
    ELSEIF d instanceof TupleType»«
      (d as TupleType).compile»«
    ELSEIF d instanceof SequenceType»«
      (d as SequenceType).compile»«
    ELSEIF d instanceof RangeType»range «(d as RangeType).vmin.compile»..«(d as RangeType).vmax.compile»«
    ELSEIF d instanceof ConnectionType»«
      (d as ConnectionType).mode.compile»{«(d as ConnectionType).type.compile»}«
    ELSEIF d instanceof NamedType»«
      (d as NamedType).compile»«
    ENDIF»'''
	
	def compile(FunctionDecl f)'''
      function («f.dataName»:«f.dataTypeName»)::«f.name»(«f.parameters.map[compile].join(", ")»):«f.type.compile» is {
        «FOR v:f.valuing»
        «v.compile»
        «ENDFOR»
        return «f.expression.compile»
      }
	'''

	def compile(FormalParameter p)'''  «p.name» : «p.type.compile»'''

	def compile(IntegerType t)'''int'''
	
	def compile(TupleType t)'''record «t.fields.map[compile].join("; ")»; end'''
	
	def compile(FieldDecl f)'''«f.name»:«f.type.compile»'''
	
	// TODO! define the size of the array!
	def compile(SequenceType s)'''array [1000] of «s.type.compile»'''
	
	def compile(ModeType m)'''«m.literal»'''
	
	def compile(NamedType t) {
	    val type = if (currentSystem != null) currentSystem.typesMap.get(t.name)
                   else globalTypesMap.get(t.name)
	    '''«IF type == "int"»int«ELSE»«t.name»«ENDIF»'''
	}

    def compile(ComplexName c)'''«IF c.name != null»«c.name.join("_")»«ENDIF»'''
    
	def compile(Valuing v){
	  if (v.type == null)
	    currentProcess.addVariable(v.variable)
	  else
	    currentProcess.addVariable(v.variable, v.type.compile.toString)  
	  '''«v.variable» := «v.expression.compile»'''
	}
	
	def compile(IntegerValue i)'''«i.absInt»'''
	
	def compile(Any a)'''any'''
	
	def compile(ConstructedValue c)'''«
      IF c instanceof Tuple»«
        (c as Tuple).compile»«
      ELSEIF c instanceof Sequence»«
        (c as Sequence).compile»«
      ENDIF»'''
	
	def compile(Tuple t)'''tuple{«t.elements.map[compile].join(", ")»}'''
	
	def compile(TupleElement t)'''«t.label»=«t.value.compile»'''
	
	def compile(Sequence s)'''sequence{«s.elements.map[compile].join(", ")»}'''

    def CharSequence compile(Expression e)'''«
	IF e instanceof BinaryExpression»«(e as BinaryExpression).compile»«
	ELSEIF e instanceof UnaryExpression» «(e as UnaryExpression).op» «(e as UnaryExpression).right.compile»«
	ELSEIF e instanceof Binding»«(e as Binding).compile»«
	ELSEIF e instanceof CallExpression»«(e as CallExpression).compile»«
	ELSEIF e instanceof IdentExpression»«(e as IdentExpression).ident»«
	ELSEIF e instanceof UnobservableValue»unobservable«
	ELSEIF e instanceof Any»any«
    ELSEIF e instanceof Tuple»«(e as Tuple).compile»«
    ELSEIF e instanceof Sequence»«(e as Sequence).compile»«
    ELSEIF e instanceof IntegerValue»«(e as IntegerValue).compile»«
    ELSEIF e instanceof Field»«(e as Field).object.compile».«(e as Field).field»«
    ELSEIF e instanceof Select»«(e as Select).compile»«
    ELSEIF e instanceof Map»«(e as Map).compile»«
    ELSEIF e instanceof MethodCall»«(e as MethodCall).compile»«
	ENDIF»'''
	
	def CharSequence compile(BinaryExpression e) {
        switch e.op {
            case "implies" : "not "+compileAndBracket(e.left)+" or "+compileAndBracket(e.right)
            case "xor" : "("+compileAndBracket(e.left)+" and not "+compileAndBracket(e.right)+") or (not "+compileAndBracket(e.left)+" and "+compileAndBracket(e.right)+")"
            case "div" : compileAndBracket(e.left)+" / "+compileAndBracket(e.right)
            case "mod" : compileAndBracket(e.left)+" % "+compileAndBracket(e.right)
            default: compileAndBracket(e.left)+e.op+compileAndBracket(e.right)
        }
    }
    
    def compileAndBracket(Expression e) {
        switch e {
            BinaryExpression: "("+e.compile+")"
            UnaryExpression: "("+e.compile+")"
            default: e.compile
        }
    }
	
	def compile(CallExpression e)'''«
	e.function»(«e.parameters.map[compile].join(", ")»)'''
	
	def compile(Select e)'''«
	e.object.compile».select(«e.variable» suchthat «e.condition.compile»)'''

	def compile(Map e)'''«
	e.object.compile».map(«e.variable» to «e.expression.compile»)'''

	def compile(MethodCall e)'''«
	e.object.compile».«e.method»(«e.parameters.map[compile].join(", ")»)'''
	
    def compile(UnaryExpression u)'''«u.op» «u.right.compile»'''
    
    def CharSequence compile(Assertion a)'''«
	IF a instanceof BinaryAssertion»«(a as BinaryAssertion).compile»«
	ELSEIF a instanceof UnaryAssertion» «(a as UnaryAssertion).op» «(a as UnaryAssertion).right.compile»«
	ELSEIF a instanceof Expression»«(a as Expression).compile»«
	ELSEIF a instanceof Always»«(a as Always).compile»«
	ELSEIF a instanceof Anynext»«(a as Anynext).compile»«
	ELSEIF a instanceof Action»«(a as Action).compile»«
	ENDIF»'''
	
	def CharSequence compile(BinaryAssertion a) {
	    switch a.op {
            case "implies" : "not ("+a.left.compile+") or ("+a.right.compile+")"
            case "xor" : "(("+a.left.compile+") and not ("+a.right.compile+")) or ((not "+a.left.compile+") and ("+a.right.compile+"))"
            case "div" : "("+a.left.compile+") / ("+a.right.compile+")"
            case "mod" : "("+a.left.compile+") % ("+a.right.compile+")"
            default: "("+a.left.compile+")"+a.op+"("+a.right.compile+")"
        }
	}
	
    def compile(UnaryAssertion u)'''«u.op»«u.right.compile»'''
    
    def compile(Always a)'''always(«a.expression.compile»)'''
    
    def compile(Anynext a)'''anynext(«a.expression.compile»)'''
}

class Gate {
    val String name
    String type
    String mode // TODO! enum au lieu de string!
    
    new(String name, String type, String mode) {
       this.name=name
       this.type=type
       this.mode=mode
    }
    
    def name() {
       this.name
    }
    
    def type() {
       this.type
    }
    
    def mode() {
       this.mode
    }
    
    override def String toString() {
        switch mode {
            case "in":
                "  "+name+"("+type+"); // "+mode+"\n"
            case "out":
                "  "+name+"("+type+"); // "+mode+"\n"
            case "inout":
                "  "+name+"_in("+type+"); // "+mode+"\n"+
                "  "+name+"_out("+type+"); // "+mode+"\n"
        } 
    }
    
}


/*
 * A Transition
 * 
 * Note:
 * - guard and statements are optional.
 * - one action is required (tau by default), and can be initialized after creation
 *   but if fromState is the init state, then sync tau is not allowed.
 * - the comment helps to understand the transformation from SoDADL to IOSTS
 */
class Transition {
   val int fromState
   val int toState
   String comment=""
   String guard=""  // optional
   String action="tau"  // default action is tau
   List<String> statements = newArrayList  // optional
   
   new(int fromState, int toState, String action) {
       this.fromState=fromState
       this.toState=toState
       this.action=action
   }
   
   new(int fromState, int toState) {
       this.fromState=fromState
       this.toState=toState
   }
   
   def setComment(String comment) {
       this.comment = comment
   }
   
   def setGuard(String guard) {
       this.guard = guard
   }
   
   def setAction(String action) {
       this.action = action
   }
   
   def addStatement(String statement) {
       statements.add(statement)
   }
   
   override def String toString() {
     /*
      Shall we generate "sync" when fromState==0? 
      If not, replace:
        sync «action»
      with:
        «IF fromState != 0»
        sync «action»
        «ENDIF»
      */
     '''
     
       from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
         «IF !guard.empty»
         if «guard»
         «ENDIF»
         «IF fromState == 0 && toState == 1»
         //sync «action»  // STG doesn't accept sync in the first transition.
         «ELSE»
         sync «action»
         «ENDIF»
         «IF statements.length == 1»
         do «statements.get(0)»
         «ELSEIF statements.length > 1»
         do {
             «statements.join(" | ")»
         }
         «ENDIF»
       to s«toState»;
     '''
   }
}

class Process{
    val String name
    var String comment=""
    public var inputMap = newLinkedHashMap()    // map of (in connection -> datatype)
    public var outputMap = newLinkedHashMap()   // map of (out connection -> datatype)
    public var inoutputMap = newLinkedHashMap() // map of (inout connection -> datatype)
    public var parametersMap = newLinkedHashMap()  // map of (received variable -> datatype)
    public var variablesMap = newLinkedHashMap()  // map of (variable -> datatype) 
    public var List<Transition> transitions = newArrayList()
    var int lastState = 0 // number of the last state, starting at 0.
    var int lastParameterNumber = 0  // number of the last generated parameter

    new(String name) {
        this.name=name
    }
    
    def String name() {
        this.name
    }
    
    def setComment(String comment) {
        this.comment = comment
    }
    
    def addInput(String name, String type) {
        this.inputMap.put(name, type)
    }
    
    def addOutput(String name, String type) {
        this.outputMap.put(name, type)
    }
    
    def addInoutput(String name, String type) {
        this.inoutputMap.put(name, type)
    }
    
    def addParameter(String name, String type) {
        this.parametersMap.put(name, type)
    }
    
    def addVariable(String name, String type) {
        this.variablesMap.put(name, type)
    }
    
    def addVariable(String name) {
        addVariable(name, "int")
    }
    
    def addTransition(Transition transition) {
        this.transitions.add(transition)
    }
    
    /*
     * Returns a new unused state id 
     */
    def int newState() {
        this.lastState = this.lastState+1
        this.lastState
    }
    
    def lastState() {
        this.lastState
    }
    
    /*
     * Returns a new unused parameter name
     */
    def newParameter() {
        this.lastParameterNumber = this.lastParameterNumber+1
        this.lastParameter()
    }
    
    def lastParameter() {
        this.name+"_p"+this.lastParameterNumber
    }
    
    /*
     * Returns the text of the IOSTS Process
     */
    override def String toString()'''
    process «name»;
    «IF !inputMap.empty»
    
    input  
      «inputMap.keySet.join(",\n")»;
    «ENDIF»
    «IF !outputMap.empty»
    
    output
      «outputMap.keySet.join(",\n")»;
    «ENDIF»
      
    internal
      tau;
    «IF !parametersMap.empty»
    
    //parameters // stg says they have already been declared!
      «FOR p:parametersMap.keySet»
      //«p» : «parametersMap.get(p)»; 
      «ENDFOR»
    «ENDIF»
    «IF !variablesMap.empty»
    
    variables
      «FOR v:variablesMap.keySet»
      «v» : «variablesMap.get(v)»;
      «ENDFOR»
    «ENDIF»
    
    state
      init: s0;
      «FOR s:1..lastState»
      s«s»;
      «ENDFOR»  
    
    transition
    «FOR t:transitions»
    «t.toString»
    «ENDFOR»
    '''
}

class IoSTS_System{
    val String name
    var String fileName=""
    var String comment=""
    var String constantSection=""
    public var typesMap = newLinkedHashMap()     // map of (types -> typeDecl)
    public var LinkedHashMap<String,Gate> gatesMap = newLinkedHashMap()  // map of (gate name -> Gate)
    public var LinkedHashMap<String,Process> processesMap = newLinkedHashMap()  // map of (process name -> Process)
    
    new(String name) {
       this.name=name
    }
    
    def setFileName(String fileName) {
       this.fileName = fileName
    }
    
    def fileName() {
        fileName
    }
    
    def setComment(String comment) {
       this.comment = comment
    }
    
    def addGate(Gate gate) {
        this.gatesMap.put(gate.name, gate)
    }
    
    def addProcess(Process process) {
        this.processesMap.put(process.name, process)
    }
    
    override def String toString() '''
    /*
    Generated by org.archware.sosadl.generator.SosADL2IOSTSGenerator
    
    WARNING #1: The generator is a work in progress! This IOSTS file may not be complete!
    WARNING #2: The generator assumes the SoSADL source is correct.
                Otherwise, STG may not compile this IOSTS file. 

    Run it with:
        «FOR p:processesMap.values»
        stg «fileName» -test_name «p.name» -test_purpose_name «p.name»
        «ENDFOR»
    */
    
    system «name»;
    «IF !constantSection.empty»
    
    constant
    «constantSection»
    «ENDIF»
    «IF !typesMap.empty»
    
    type
      «FOR t:typesMap.keySet»
        «val tt = typesMap.get(t)»
        «IF tt == "int"»
          // «t» = int;
        «ELSE»
          «t» = «tt»;
        «ENDIF»
      «ENDFOR»
    «ENDIF»
    
    gate
    «FOR g:gatesMap.values»
    «g.toString»
    «ENDFOR»
    «FOR p:processesMap.values»
    
    //--------------------------------------------------
    «p.toString»
    «ENDFOR»
    '''
}
