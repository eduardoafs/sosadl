/*
 * generated by Xtext
 */
package org.archware.sosadl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.archware.sosadl.sosADL.*
//import org.archware.sosadl.SosADLStandaloneSetupGenerated
//import org.eclipse.emf.common.util.URI
//import org.archware.sosadl.SosADLComparator
//import org.eclipse.xtext.parser.IParser
//import java.io.StringReader
import java.util.LinkedHashMap
import java.util.Map.Entry
import java.util.ArrayList
import java.util.List
import java.lang.System
//import org.archware.sosadl.services.SosADLGrammarAccess.ValuingElements
//import org.archware.sosadl.sosADL.impl.ValuingImpl
import org.archware.sosadl.sosADL.SosADLFactory
import org.archware.sosadl.sosADL.impl.SosADLFactoryImpl
import com.google.inject.Guice
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.common.util.URI
import org.archware.sosadl.SosADLRuntimeModule
import org.archware.sosadl.sosADL.impl.ValuingImpl

//import org.archware.iosts.ui.contentassist.AbstractIoSTSProposalProvider

/**
 * Generates IOSTS code from the given SosADL model files on save.
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 * 
 * The SosADL2IOSTSGenerator inherits most of its compile methods from the SosADLPrettyPrinterGenerator
 * and overrides/adds methods for the STS generation.  
 */
class SosADL2IOSTSGenerator extends SosADLPrettyPrinterGenerator implements IGenerator {
    
    val DEBUG=false
    val DEBUG2=false
    val DEBUG3=false
    
    // global variables making the generation much easier
    var String resourceFilename = null          // current SoSADL file name to be transformed
    var String iostsFileName = null             // current IoSTS file name to generate
    var LinkedHashMap<String,String> globalConstantsMap = newLinkedHashMap()
    var LinkedHashMap<String,IOstsType> globalTypesMap = newLinkedHashMap()     // map of (types -> typeDecl)
    var List<IOstsSystem> systems = null       // list of generated systems from one SoSADL file
    var IOstsSystem currentSystem = null       // system currently generated
    var IOstsProcess currentProcess = null     // process currently generated
    var LinkedHashMap<String,IOstsConnection> currentConnectionsMap = newLinkedHashMap()  // current connection map
    var lastIOstsTypeNum = 0
    var lastDoExprResultNumber=0
    var lastForEachVarNumber=0
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		for (e : resource.allContents.toIterable.filter(SosADL)) {
		    var first=true
		    resourceFilename = e.eResource.URI.trimFileExtension.lastSegment
		    iostsFileName = resourceFilename+".iosts"
            System.out.print("Transforming '"+e.eResource.URI.lastSegment+"' into '"+iostsFileName+"'")
            systems = newLinkedList()
            fsa.generateFile(iostsFileName, e.compile)
		}
	}
	
	//=========================== model transformations
	
	/*
	 * Create a new NamedType EObject with given name
	 */
	def NamedType newNamedType(String name) {
		//val SosADLFactory factory = SosADLFactoryImpl.init()
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createNamedType()  // will create a NamedTypeImpl!
		result.setName(name)
		// since result is really a NamedTypeImpl, cast to a NamedType!
		(result as NamedType)
	}
	
	/*
	 * Transform a DoExpr into a Valuing EObject.
	 * From the AST of 'do Expression', we generate the AST for 'value _doExprResult# is dataType = Expression'
	 * where:
	 * - _doExprResult# is a unique variable name
	 * - dataType is the type of Expression
	 */
	def Valuing newValuingFromDoExpr(DoExpr doExpr) {
		// generate a new dumb variable
		lastDoExprResultNumber++
		val String dumbVarName="_doExprResult"+lastDoExprResultNumber
		// retrieve the type of Expression
		val DataType datatype = newNamedType("integer")
		// create a Valuing
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createValuing()  // will create a ValuingImpl!
		result.setType(datatype)
		result.setVariable(dumbVarName)
		result.setExpression(doExpr.expression)
		// since result is really a ValuingImpl, cast to a Valuing!
		(result as Valuing)
	}
    
    //=========================== compilation
	
    /* Pour memoire 
	
	//---------------- parts of SosADL2IOSTSv1Generator : pour memoire
	def compile(SystemDecl s){
	  currentSystem = new IOstsSystem(s.name)
	  currentSystem.constantsMap.putAll(globalConstantsMap)
	  currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+s.name+".iosts")
	  s.parameters.map[compile]
	  for (d : s.datatypes) {
        d.compile
      }
      for (g : s.connections) {
        g.compile
      }
      //if (s.assertion != null) {s.assertion.compile}  // not a protocol?
      s.behavior.compile
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }

	def compile(ArchitectureDecl a){
	  currentSystem = new IOstsSystem(a.name)
      currentSystem.constantsMap.putAll(globalConstantsMap)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+a.name+".iosts")
      a.parameters.map[compile]
      for (d : a.datatypes) {d.compile}
      for (g : a.connections) {g.compile}
      a.behavior.compile
      //if (a.assertion != null) {a.assertion.compile} // not a protocol?
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }

    def compile(MediatorDecl m){
      currentSystem = new IOstsSystem(m.name)
      currentSystem.constantsMap.putAll(globalConstantsMap)
      currentSystem.typesMap.putAll(globalTypesMap)
      currentSystem.setFileName(resourceFilename+"_"+m.name+".iosts")
      m.parameters.map[compile]
      for (d : m.datatypes) {
        d.compile
      }
      for (d : m.duties) {
        d.compile
      }
      //if (m.assertion != null) {m.assertion.compile}  // not a protocol?
      m.behavior.compile
      // add system if it's not empty
      if (! currentSystem.empty) {
        systems.add(currentSystem)
      }
      currentSystem=null
    }
	
	def compile(GateDecl g){
	    for (c : g.connections) {
	        val name=g.name+"_"+c.name
	        val IOstsType type = computeIOstsType(c.valueType)
	        val typeName = nameOfIOstsType(type)
	        registerIOstsType(typeName, type)
	        val finalTypeName = finalNameOfIOstsType(typeName)
	        //currentSystem.addConnection(new IOstsConnection(name, computeIOstsType(c.valueType), c.mode.toString))
	        currentSystem.addConnection(new IOstsConnection(name, finalTypeName, c.mode.toString))
	    }
	    '''«g.protocol.compile»'''
	}

	
	def compile(DutyDecl d){
        for (c : d.connections) {
            val name=d.name+"_"+c.name
            val IOstsType type = computeIOstsType(c.valueType)
            val typeName = nameOfIOstsType(type)
            registerIOstsType(typeName, type)
            val finalTypeName = finalNameOfIOstsType(typeName)
            //currentSystem.addConnection(new IOstsConnection(name, computeIOstsType(c.valueType), c.mode.toString))
            currentSystem.addConnection(new IOstsConnection(name, finalTypeName, c.mode.toString))
        }
        '''«d.protocol.compile»'''
    }
    
    */
	
	override def compile(SystemDecl s) {
		currentSystem = new IOstsSystem(s.name)
		currentSystem.constantsMap.putAll(globalConstantsMap)
		currentSystem.typesMap.putAll(globalTypesMap)
		currentSystem.setFileName(resourceFilename + ".iosts")

		/*
	  	s.parameters.map[compile]
	  	for (d : s.datatypes) {
        	d.compile
      	}
      	for (g : s.connections) {
        	g.compile
      	}
	    //if (s.assertion != null) {s.assertion.compile}  // not a protocol?
      	s.behavior.compile
      	*/
		val result = super.compile(s)

		// add system if it's not empty
		if (! currentSystem.empty) {
			systems.add(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(MediatorDecl m) {
		currentSystem = new IOstsSystem(m.name)
		currentSystem.constantsMap.putAll(globalConstantsMap)
		currentSystem.typesMap.putAll(globalTypesMap)
		currentSystem.setFileName(resourceFilename + "_" + m.name + ".iosts")

		/*
      	m.parameters.map[compile]
      	for (d : m.datatypes) {
        	d.compile
      	}
      	for (d : m.duties) {
        	d.compile
      	}
      	//if (m.assertion != null) {m.assertion.compile}  // not a protocol?
      	m.behavior.compile
      	*/
		val result = super.compile(m)

		// add system if it's not empty
		if (! currentSystem.empty) {
			systems.add(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(ArchitectureDecl a) {
		currentSystem = new IOstsSystem(a.name)
		currentSystem.constantsMap.putAll(globalConstantsMap)
		currentSystem.typesMap.putAll(globalTypesMap)
		currentSystem.setFileName(resourceFilename + "_" + a.name + ".iosts")

		/*
      	a.parameters.map[compile]
      	for (d : a.datatypes) {d.compile}
      	for (g : a.connections) {g.compile}
      	a.behavior.compile
      	//if (a.assertion != null) {a.assertion.compile} // not a protocol?
      	*/
		val result = super.compile(a)

		// add system if it's not empty
		if (! currentSystem.empty) {
			systems.add(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(GateDecl g){
    	currentConnectionsMap = newLinkedHashMap()
	    for (c : g.connections) {
	        val name=g.name+"::"+c.name
	        val IOstsType type = computeIOstsType(c.valueType)
	        val typeName = nameOfIOstsType(type)
	        registerIOstsType(typeName, type)
	        val finalTypeName = finalNameOfIOstsType(typeName)
	        //currentSystem.addConnection(new IOstsConnection(name, computeIOstsType(c.valueType), c.mode.toString))
	        currentConnectionsMap.put(name, new IOstsConnection(name, finalTypeName, c.mode.toString))
	    }
	    super.compile(g)
	}

	
	override def compile(DutyDecl d){
		currentConnectionsMap = newLinkedHashMap()
        for (c : d.connections) {
            val name=d.name+"::"+c.name
            val IOstsType type = computeIOstsType(c.valueType)
            val typeName = nameOfIOstsType(type)
            registerIOstsType(typeName, type)
            val finalTypeName = finalNameOfIOstsType(typeName)
            //currentSystem.addConnection(new IOstsConnection(name, computeIOstsType(c.valueType), c.mode.toString))
            currentConnectionsMap.put(name, new IOstsConnection(name, finalTypeName, c.mode.toString))
        }
        super.compile(d)
    }
    
    override def compile(DataTypeDecl d) {
		var IOstsType t
		if (d.datatype == null) {
			if(DEBUG2) System.err.println("Warning! type definition of '" + d.name + "' null! Assuming 'integer'...")
			t = new IOstsIntType()
		} else {
			t = computeIOstsType(d.datatype)
		}
		if (currentSystem != null) {
			currentSystem.typesMap.put(d.name, t)
		} else {
			// this datatype declaration occurs before the system/mediator/architecture declaration
			globalTypesMap.put(d.name, t)
		}
		super.compile(d)
	}
    
    //---------------- Compilation of Protocol and Behavior is special
    
    override def compile(ProtocolDecl p) {
        var IOstsTransition firstTransition = initTransition("true")
        firstTransition.setComment("FIXME: system/mediator/architecture parameters may change this guard!")
        currentProcess = new IOstsProcess(p.name)
        currentProcess.addAllConnections(currentConnectionsMap)
        currentProcess.addTransition(firstTransition)
        computeSTS(firstTransition.toState(),p.body)
        currentSystem.addProcess(currentProcess)
        '''protocol «p.name» is «currentProcess»'''
    }
    
    override def compile(BehaviorDecl b){
        //if (currentProcess != null) currentSystem.addProcess(currentProcess)
        var IOstsTransition firstTransition = initTransition("true")
        firstTransition.setComment("FIXME: system/mediator/architecture parameters may change this guard!")
        currentProcess = new IOstsProcess(b.name)
        currentProcess.addAllConnections(currentConnectionsMap)
        currentProcess.addTransition(firstTransition)
        computeSTS(firstTransition.toState(),b.body)
        currentSystem.addProcess(currentProcess)
        '''behavior «b.name» is «currentProcess»'''
    }
    
    /* TODO! Generate the STS in place of the architecture behavior
	def compile(ArchBehaviorDecl a)'''
    behavior «a.name» is compose {
      «FOR c:a.constituents»
        «c.compile»
      «ENDFOR»
    } binding {
      «a.bindings.compile»
    }
	'''
	*/
	
	// get and register type of value
	override def compile(Valuing v){
	  registerValuing(v)
	  super.compile(v)
	}
	
	// register name and type of Valuing
	def registerValuing(Valuing v) {
		if (v.type == null)
			currentProcess.addVariable(v.variable)
		else {
			val type = computeIOstsType(v.type)
			val typeName = nameOfIOstsType(type)
			registerIOstsType(typeName, type)
			currentProcess.addVariable(v.variable, finalNameOfIOstsType(typeName))
		}
	}
    
    //=========================== Generation of the STS
    
    /*
     * Returns an init transition: from 0 to 1, with given guard.
     * Shall be added before any other in a Behavior or Protocol.
     * The first transition has no action, not assignments.
     * A default comment is added, but can be changed. 
     */
    def IOstsTransition initTransition(String guard) {
    	var IOstsTransition firstTransition = new IOstsTransition(0,1)
    	firstTransition.setInit(true)
    	firstTransition.setGuard(guard)
    	firstTransition.setComment("first transition") // default comment, can be changed later
	    firstTransition
    }
    
    /*
     * All computeSTS() functions return the final states of the STS
     * according to the behavior starting at startState.
     */
    /*
     * - computeSTS for a Behavior (which is a sequence of BehaviorStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Behavior b) {
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        var boolean previousIsValuing=false
        var int previousStartState=0
        for (s : b.statements) {
            /* OLD version: obsolete since initTransition()
            if (first && (s instanceof Action) && startState==0 && state==0) {
                //System.out.println("Preparing empty transition, because sync is not allowed in first transition": from="+state+", to="+state)
                finalStates = newArrayList(0)
                first=false
            }
            */
            if (! first) { // && finalStates.length >= 2) {
            	// NEW version: concatenation for sequentiality is generated between two statements
            	// ONLY when the first statement ends with at least 2 final states.
            	if (finalStates.length == 1) {
            		state=finalStates.get(0)
           		} else { // finalStates.length >= 2
                	state=currentProcess.newState()
	                var i=0
	                while (i < finalStates.length) {
	                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
	                    concatenation.setComment("Concatenation (sequentiality)")
	                    currentProcess.addTransition(concatenation)
	                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
	                    i = i+1
	                }
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            if (s instanceof Valuing) {
            	if (previousIsValuing) {
            		// adding a assignment to transition from state to finalStates.get(0)
            		// instead of creating a new transition
            		state = previousStartState
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, final(0)="+finalStates.get(0)+")")}
            		finalStates = computeSTS(state, s, finalStates.get(0), "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	} else {
               		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, 0)")}
            		finalStates = computeSTS(state, s, 0, "Valuing")
               		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	}
            	previousIsValuing = true
            } else {
            	finalStates = computeSTS(state, s)
            	previousIsValuing = false
           	}
            first=false
            previousStartState=state
            if (DEBUG3) {System.err.println("END LOOP: state="+state+", previousStartState="+previousStartState+", final(0)="+finalStates.get(0))}
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Protocol (which is a sequence of ProtocolStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Protocol b){
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        var boolean previousIsValuing=false
        var int previousStartState=0
        for (s : b.statements) {
        	/* OLD version: obsolete since initTransition()
            if (first && (s instanceof ProtocolAction) && startState==0 && state==0) {
                //System.out.println("Preparing empty transition, because sync is not allowed in first transition": from="+state+", to="+state)
                finalStates = newArrayList(0)
                first=false
            }
            */
            if (! first) {
            	// NEW version: concatenation for sequentiality is generated between two statements
            	// ONLY when the first statement ends with at least 2 final states.
            	if (finalStates.length == 1) {
            		state=finalStates.get(0)
           		} else { // finalStates.length >= 2
                	state=currentProcess.newState()
	                var i=0
	                while (i < finalStates.length) {
	                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
	                    concatenation.setComment("Concatenation (sequentiality)")
	                    currentProcess.addTransition(concatenation)
	                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
	                    i = i+1
	                }
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            if (s instanceof Valuing) {
            	if (previousIsValuing) {
            		// adding a assignment to transition from state to finalStates.get(0)
            		// instead of creating a new transition
            		state = previousStartState
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, final(0)="+finalStates.get(0)+")")}
            		finalStates = computeSTS(state, s, finalStates.get(0), "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	} else {
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, 0)")}
            		finalStates = computeSTS(state, s, "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	}
            	previousIsValuing = true
            } else {
            	finalStates = computeSTS(state, s)
            	previousIsValuing = false
           	}
            first=false
            previousStartState=state
            if (DEBUG3) {System.err.println("END LOOP: state="+state+", previousStartState="+previousStartState+", final(0)="+finalStates.get(0))}
        }
        finalStates
    }
    
    /*
     * - computeSTS for a DoExpr statement: transform to a Valuing!
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, DoExpr r){
    	val Valuing v = newValuingFromDoExpr(r)
    	computeSTS(startState, v, "DoExpr")
    }
    
    /*
     * - computeSTS for a Valuing statement, not following a previous Valuing
     */
    def ArrayList<Integer> computeSTS(int startState, Valuing v, String comment){
    	computeSTS(startState, v, 0, comment)
    }
    
    /*
     * - computeSTS for a Valuing statement, may be following a Valuing statement.
     */
    def ArrayList<Integer> computeSTS(int startState, Valuing v, int finalState, String comment){
    	var int final
    	var IOstsTransition valuing
    	if (finalState == 0) {
    		final=currentProcess.newState()
        	valuing = new IOstsTransition(startState,final)
        } else {
        	final=finalState
        	if (DEBUG3) {
        		System.err.println("CALLING getTransition(startState="+startState+", final="+final+")")
        	}
        	valuing = currentProcess.getTransition(startState,final)
        	if (valuing == null) {
        		System.err.println("ERROR! Transition from="+startState+" to="+final+" not found!")
        	}
        }
        //valuing.addAssignment(v.compile.toString) // v.compile.toString hields SosADL syntax
        registerValuing(v)
        valuing.addAssignment(v.variable+" := "+v.expression.compile)
        valuing.setComment(comment)
        currentProcess.addTransition(valuing)
        //System.out.println("Added valuing transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Send/Receive Behavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Action a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        val IOstsConnection connection=currentSystem.getConnection(channel)
        if (connection == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared! Ignoring statement...")
        } else if (a.suite instanceof SendAction) {
            val parameter=currentProcess.newParameter()
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_out")
            }
            else if (connection.mode == "out") {
            	if (! currentProcess.outputMap.containsKey(channel)) {
                	currentProcess.addOutput(channel, connection.typeName)
                	if (DEBUG2) System.out.println("Added channel '"+channel+"' to output connections")
            	}           
            }
            action.setGuard(parameter+" = "+(a.suite as SendAction).expression.compile)
            action.setAction("via "+channel+" send "+parameter)
            action.setComment("Send action")
            currentProcess.addParameter(parameter,connection.typeName)
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAction) {
            val variable=(a.suite as ReceiveAction).variable
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_in")
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }

    /*
     * - computeSTS for a Send/Receive Protocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ProtocolAction a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        val IOstsConnection connection=currentProcess.getConnection(channel)
        if (connection == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared! Ignoring statement...")
        } else if (a.suite instanceof SendProtocolAction) {
            val parameter=currentProcess.newParameter()
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_out")
            }
            else if (connection.mode == "out") {
	            if (! currentProcess.outputMap.containsKey(channel)) {
	                currentProcess.addOutput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to output connections")
	            }
            }
            if ((a.suite as SendProtocolAction).expression.compile.toString == "any") {
                /* FIXME: send any:
                 * - option 1 "pas de if": ANY_typeConnection est une constante qui doit etre definie
                 *     action.setAction(channel+"!(ANY_typeConnection)")
                 *     currentProcess.addParameter(parameter,connection.typeName)
                 * - option 2 "avec if en affectant au parametre une constante ANY_typeConnection" (au hasard?)
                 *     action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                 *     action.setAction(channel+"!("+parameter+")")
                 *     currentProcess.addParameter(parameter,connection.typeName)
                 */
                // send any: no guard (thus not parameter) and send a random expression compatible with type of connection
                action.setGuard(parameter+" = 0  /*FIXME: 0 should be an expression of parameter's type*/")
                action.setAction("via "+channel+" send "+parameter)
                currentProcess.addParameter(parameter,connection.typeName)
                action.setComment("Send any action")
            } else {
                // send some expression
                action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                action.setAction("via "+channel+" send "+parameter)
                currentProcess.addParameter(parameter,connection.typeName)
                action.setComment("Send action")
            }
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveProtocolAction) { 
            val variable=(a.suite as ReceiveProtocolAction).variable
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_in")
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAnyProtocolAction) {
            val variable="any_s"+startState
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
                //OLD version: channel = channel.concat("_in")
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive any action")
            //System.out.println("Added receive any transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment("IfThenElse (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment("IfThenElse (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }

    /*
     * - computeSTS for a IfThenElseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment("IfThenElse (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment("IfThenElse (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    
    /*
     * - computeSTS for a ChooseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseBehavior c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }

    /*
     * - computeSTS for a ChooseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseProtocol c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }
        
    /*
     * - computeSTS for a RepeatBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatBehavior r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        // add a transition with guard "false" and action "tau" from startState
        // to avoid bypassing or exiting the repeat loop.
        val int ifFalseAfterRepeat=currentProcess.newState()
        var IOstsTransition ifFalse = new IOstsTransition(startState,ifFalseAfterRepeat)
        ifFalse.setGuard("false")
        ifFalse.setComment("IfFalse avoids exit from Repeat")
        currentProcess.addTransition(ifFalse)
        //System.out.println("Added ifFalse transition after Repeat: from="+startState+", to="+ifFalseAfterRepeat)
        newArrayList(ifFalseAfterRepeat)
    }

    /*
     * - computeSTS for a RepeatProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatProtocol r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        newArrayList(startState) 
    }
        
    /*
     * - computeSTS for a Assert statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Assert r){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition assert = new IOstsTransition(startState,final)
        assert.setComment("TODO! Assert")
        currentProcess.addTransition(assert)
        //System.out.println("Added fake assert transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a ForEachBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachBehavior r){
        lastForEachVarNumber++
        val String iName = "i"+lastForEachVarNumber+"_"
        val String setOfValues = r.setOfValues.compile.toString
        val String variable = r.variable
        currentProcess.addVariable(iName)
        // transition: initialize i
        val finalInit=currentProcess.newState()
        var IOstsTransition init = new IOstsTransition(startState,finalInit)
        init.setComment("ForEachBehavior: init "+iName)
        init.addAssignment(iName+" := "+0)
        currentProcess.addTransition(init)
        // transition: if (i < sizeof(setOfValues))
        val finalIfInf=currentProcess.newState()
        var IOstsTransition ifInf = new IOstsTransition(finalInit, finalIfInf)
        ifInf.setComment("ForEachBehavior: begin loop")
        ifInf.setGuard(iName+" <= "+setOfValues+"::size()")
        ifInf.addAssignment(variable+" := "+setOfValues+"::element("+iName+")")
        currentProcess.addTransition(ifInf)
        // transitions of the Behavior inside the ForEachBehavior
        var ArrayList<Integer> endOfLoop = newArrayList()
        endOfLoop.addAll(computeSTS(finalIfInf, r.repeated))
        // transition(s) from end(s) of Behavior inside the ForEachBehavior to init
        /* alt1 */
        for (e : endOfLoop) {
        	var IOstsTransition increment = new IOstsTransition(e,finalInit)
        	increment.addAssignment(iName+" := "+iName+"+1")
        	increment.setComment("ForEachBehavior: end loop with increment")
        	currentProcess.addTransition(increment)
        }
        // end of alt1
        /* alt2
 		// add a concatenation if body ends with multiple states
        var int finalEndOfLoop
        if (endOfLoop.length > 1) {
        	finalEndOfLoop = currentProcess.newState()
        	// adding concatenations to get a unique final state for the body of ForEach
        	for (e : endOfLoop) {
	        	var IOstsTransition concatenation = new IOstsTransition(e,finalEndOfLoop)
	        	concatenation.setComment("ForEachBehavior: concatenation before increment")
	        	currentProcess.addTransition(concatenation)
	        }
        } else {
        	finalEndOfLoop = endOfLoop.get(0)
        }
        // increment
        var IOstsTransition increment = new IOstsTransition(finalEndOfLoop,finalInit)
        increment.addAssignment(iName+" := "+iName+"+1")
        increment.setComment("ForEachBehavior: end loop increment")
        currentProcess.addTransition(increment)
        // end of alt2
        */
        // transition: if (i > sizeof(setOfValues))
        val finalIfSup=currentProcess.newState()
        var IOstsTransition ifSup = new IOstsTransition(finalInit, finalIfSup)
        ifSup.setComment("ForEachBehavior: after foreach loop")
        ifSup.setGuard(iName+" > "+setOfValues+"::size()")
        currentProcess.addTransition(ifSup)
    	newArrayList(finalIfSup)
    }
    
    /*
     * - computeSTS for a ForEachProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachProtocol r){
		lastForEachVarNumber++
        val String iName = "i"+lastForEachVarNumber+"_"
        val String setOfValues = r.setOfValues.compile.toString
        val String variable = r.variable
        currentProcess.addVariable(iName)
        // transition: initialize i
        val finalInit=currentProcess.newState()
        var IOstsTransition init = new IOstsTransition(startState,finalInit)
        init.setComment("ForEachProtocol: init "+iName)
        init.addAssignment(iName+" := "+0)
        currentProcess.addTransition(init)
        // transition: if (i < sizeof(setOfValues))
        val finalIfInf=currentProcess.newState()
        var IOstsTransition ifInf = new IOstsTransition(finalInit, finalIfInf)
        ifInf.setComment("ForEachProtocol: begin loop")
        ifInf.setGuard(iName+" <= "+setOfValues+"::size()")
        ifInf.addAssignment(variable+" := "+setOfValues+"::element("+iName+")")
        currentProcess.addTransition(ifInf)
        // transitions of the Behavior inside the ForEachProtocol
        var ArrayList<Integer> endOfLoop = newArrayList()
        endOfLoop.addAll(computeSTS(finalIfInf, r.repeated))
        // transition(s) from end(s) of Behavior inside the ForEachBehavior to init
        /* alt1 */
        for (e : endOfLoop) {
        	var IOstsTransition increment = new IOstsTransition(e,finalInit)
        	increment.addAssignment(iName+" := "+iName+"+1")
        	increment.setComment("ForEachProtocol: end loop with increment")
        	currentProcess.addTransition(increment)
        }
        // end of alt1
        /* alt2
 		// add a concatenation if body ends with multiple states
        var int finalEndOfLoop
        if (endOfLoop.length > 1) {
        	finalEndOfLoop = currentProcess.newState()
        	// adding concatenations to get a unique final state for the body of ForEach
        	for (e : endOfLoop) {
	        	var IOstsTransition concatenation = new IOstsTransition(e,finalEndOfLoop)
	        	concatenation.setComment("ForEachProtocol: concatenation before increment")
	        	currentProcess.addTransition(concatenation)
	        }
        } else {
        	finalEndOfLoop = endOfLoop.get(0)
        }
        // increment
        var IOstsTransition increment = new IOstsTransition(finalEndOfLoop,finalInit)
        increment.addAssignment(iName+" := "+iName+"+1")
        increment.setComment("ForEachProtocol: end loop increment")
        currentProcess.addTransition(increment)
        // end of alt2
        */
        // transition: if (i > sizeof(setOfValues))
        val finalIfSup=currentProcess.newState()
        var IOstsTransition ifSup = new IOstsTransition(finalInit, finalIfSup)
        ifSup.setComment("ForEachProtocol: after foreach loop")
        ifSup.setGuard(iName+" > "+setOfValues+"::size()")
        currentProcess.addTransition(ifSup)
    	newArrayList(finalIfSup)
    }
    
    /*
     * - computeSTS for an AnyAction statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AnyAction a){
        // TODO!
        val int final=currentProcess.newState()
        var IOstsTransition anyAction = new IOstsTransition(startState,final)
        anyAction.setComment("TODO! AnyAction")
        currentProcess.addTransition(anyAction)
        //System.out.println("Added fake anyAction transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Done statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Done r){
        // do nothing!
        newArrayList(startState)
    }
    
    /*
     * - computeSTS for a RecursiveCall statement.
     *   same as Repeat of entire Behavior: loop to initial state
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RecursiveCall r){
        if (startState != 0) {
            var IOstsTransition t = new IOstsTransition(startState,0)
            t.setComment("Recursive call")
            currentProcess.addTransition(t)
            newArrayList(0) 
        }
    }    

    
    //=========================== Utility functions for handling IoSTS types
    
    def getIOstsType(String name) {
	    if (currentSystem != null) {
            if (currentSystem.typesMap.containsKey(name)) {
                currentSystem.typesMap.get(name)
            } else {
                null
            }
        } else if (globalTypesMap.containsKey(name)) {
            globalTypesMap.get(name)
        } else {
            null
        }
	}
	
	def finalNameOfIOstsType(String name) {
	    val IOstsType t = getIOstsType(name)
	    val finalName = if (t == null) {
	        if (DEBUG2) System.err.println("Warning: type '"+name+"' not found! Assuming integer...")
	        (new IOstsIntType()).toString
	    } else switch t {
	        IOstsIntType: t.toString
	        IOstsBoolType: t.toString
	        default: name
	    }
	    if (DEBUG2) System.out.println("Final type name '"+name+"' = '"+finalName+"'.")
	    finalName
	}
	
	def registerIOstsType(String name, IOstsType type) {
	    if (currentSystem != null) {
            if (currentSystem.typesMap.containsKey(name)) {
                if (DEBUG2) System.err.println("Warning: system type '"+name+"' already declared! Overriding...")
            }
            currentSystem.typesMap.put(name,type)
        } else {
            if (globalTypesMap.containsKey(name)) {
                if (DEBUG2) System.err.println("Warning: global type '"+name+"' already declared! Overriding...")
            }
            // the datatype declaration here occurs before the system/mediator/architecture declaration
            globalTypesMap.put(name,type)
        }
	}
	
	def nameOfIOstsType(IOstsType type) {
	    var name=""
	    if (currentSystem != null) {
            for (t:currentSystem.typesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
            if (name == "") {
                name=type.toString
                currentSystem.typesMap.put(name,type)
            }
        } else {
            for (t:globalTypesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
            if (name == "") {
                name=type.toString
                globalTypesMap.put(name,type)
            }
        }
        name
	}
	
	def dispatch IOstsType computeIOstsType(DataTypeDecl d) {
	    var IOstsType t = null
	    if (d.datatype == null)
	       t=new IOstsIntType()
        else
           t=computeIOstsType(d.datatype)
	    registerIOstsType(d.name, t)
	    t
	}
	
	
	def dispatch IOstsType computeIOstsType(DataType t) {
	    switch t {
	        IntegerType: computeIOstsType(t)
	        SequenceType: computeIOstsType(t)
	        TupleType: computeIOstsType(t)
	        RangeType: computeIOstsType(t)
	        NamedType: computeIOstsType(t)
	        default: {
	            System.err.println("BUG! computeIOstsType of this datatype '"+t.toString+"' is not implemented! Assuming 'integer'...")
                new IOstsIntType()
	        }
	    }
	}
	
	
	def dispatch IOstsType computeIOstsType(IntegerType t) {
        new IOstsIntType()
    }
    
	def dispatch IOstsType computeIOstsType(SequenceType t) {
        // TODO: a relire et a tester !!!
        var String typeName = nameOfIOstsType(computeIOstsType(t.type))
        var IOstsType sequence = new IOstsSequenceType(new IOstsNamedType(typeName))
        sequence.setComment("sequence{"+typeName+"}")
        sequence
    }
	
	def dispatch IOstsType computeIOstsType(TupleType t) {
        var LinkedHashMap<String,IOstsType> fieldsMap=newLinkedHashMap()
        var comment="tuple{"
        var first=true
        for (f:(t as TupleType).fields) {
            val tn=f.type.compile.toString
            val _tt=computeIOstsType(f.type)
            val IOstsType tt = if (_tt instanceof IOstsIntType || _tt instanceof IOstsBoolType) _tt else new IOstsNamedType(tn)
            fieldsMap.put(f.name, tt)
            comment=comment.concat((if (first) "" else ",")+f.name+":"+tn)
            first=false
        }
        comment=comment.concat("}")
        var tuple=new IOstsTupleType(fieldsMap)
        tuple.setComment(comment)
        tuple
    }
    
    def dispatch IOstsType computeIOstsType(RangeType t) {
        //FIXME: min et max peuvent etre des constantes au lieu de nombres
        val int min=Integer.valueOf(t.vmin.compile.toString)
        val int max=Integer.valueOf(t.vmax.compile.toString)
        new IOstsRangeType(min, max)
    }
    
    def dispatch IOstsType computeIOstsType(NamedType t) {
        var IOstsType tt = if (currentSystem != null) currentSystem.typesMap.get(t.name)
                           else globalTypesMap.get(t.name)
        if (tt == null) {
            System.err.println("Warning! type '"+t.name+"' is not declared! Assuming 'integer'...")
            tt=new IOstsIntType()
        }
        tt
    }
    /*
     * TypeName generator: returns a new unused type id: BAD IDEA!
     *
    def String newIOstsTypeName() {
        this.lastIOstsTypeNum = this.lastIOstsTypeNum+1
        lastIOstsTypeName()
    }
    
    def String lastIOstsTypeName() {
        "$Type_"+this.lastIOstsTypeNum
    }
    */
}

//-------------- 
// IoSTS classes
//-------------- 

//-------------- IoSTS types

/*
 * Type: is the superclass of all types.
 */
class IOstsType {
    var String comment=""
    
    def setComment(String comment) {
        this.comment = comment
    }
   
    def comment() {
        this.comment
    }
    
    def boolean equals (IOstsType other) {
        switch other {
            IOstsIntType: this.equals(other)
            IOstsBoolType: this.equals(other)
            IOstsRangeType: this.equals(other)
            IOstsTupleType: this.equals(other)
            IOstsSequenceType: this.equals(other)
            IOstsNamedType: this.equals(other)
            default: this.equals(other)
        }
    }
}

class IOstsIntType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "integer"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsIntType)
    }

}

class IOstsBoolType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "boolean"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsBoolType)
    }
}

class IOstsRangeType extends IOstsType {
    
    int min
    int max
    
    // private thus inaccessible, because one cannot create range without min and max values
    private new() {
        min = 0
        max = 0
    }
    
    new(int min, int max) {
        this.min = min
        this.max = max
    }
    
    def min() {
        this.min
    }
    
    def max() {
        this.max
    }
    
    override def String toString() {
        "range{"+min+".."+max+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsRangeType) {
            (other.min == min) && (other.max == max)
        } else {
            false
        }
    }
}

class IOstsTupleType extends IOstsType {
    
    public val LinkedHashMap<String,IOstsType> fieldsMap   // map of (name -> type)
    
    // private thus inaccessible, because one cannot create tuple without fields
    private new() {
        fieldsMap = newLinkedHashMap() 
    }
    
    new(LinkedHashMap<String,IOstsType> listOfFields) {
        fieldsMap = listOfFields
    }
    
    override def String toString() {
        var String inner=""
        for (f:fieldsMap.entrySet) {
            inner = inner.concat(f.key+":"+f.value.toString+",")
        }
        "tuple{"+inner+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsTupleType) {
            if (other.fieldsMap.size != fieldsMap.size)
                false
            else {
                var boolean ok1=true
                val size=this.fieldsMap.size
                val ArrayList<Entry<String,IOstsType>> fields1 = newArrayList(this.fieldsMap.entrySet)
                val ArrayList<Entry<String,IOstsType>> fields2 = newArrayList(other.fieldsMap.entrySet)
                var i=0
                while(i < size) {
                    val ok2 = ((fields1.get(i).key == fields2.get(i).key) && (fields1.get(i).value.equals(fields2.get(i).value)))
                    ok1 = (ok1 && ok2)
                    i = i+1
                }
                ok1
            }
        } else false
    }
}

class IOstsSequenceType extends IOstsType {
    
    val IOstsType type
    
    // private thus inaccessible, because one cannot create array without size
    private new() {
        type = new IOstsIntType()
    }
    
    new(IOstsType type) {
        this.type = type
    }
    
    override def String toString() {
        "sequence{"+type.toString+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsSequenceType) {
            other.type.equals(type)
        } else {
            false
        }
    }
}


/*
class IOstsArrayType extends IOstsType {
    
    val int size
    val IOstsType type
    
    // private thus inaccessible, because one cannot create array without size
    private new() {
        size = 0
        type = new IOstsIntType()
    }
    
    new(int size, IOstsType type) {
        this.size = size
        this.type = type
    }
    
    override def String toString() {
        "array["+size+"] of "+type.toString
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsArrayType) {
            if (other.size != size) {
                false
            } else {
                other.type.equals(type)
            }
        } else {
            false
        }
    }
}
*/

class IOstsNamedType extends IOstsType {
    
    val String name
    
    new(String name) {
        this.name = name
    }
    
    override def String toString() {
        name
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsNamedType) {
            other.name == name
        } else {
            false
        }
    }
}

//-------------- Connection, Transition, Process and IOstsSystem

/*
 * Connection
 * 
 * Notes:
 * - name, type, and mode are required at creation time, and immutable.
 * - connections in IOSTS and in SoS-ADL are identical.
 * - now, the mode of IoSTS's connection are the same as in SoSADL: 'in', 'out', 'inout'.
 */
class IOstsConnection {
    val String name
    val String typeName
    val String mode // FIXME! enum au lieu de string!
    
    new(String name, String typeName, String mode) {
        this.name=name
        this.typeName=typeName
        this.mode=mode
    }
    
    def name() {
        this.name
    }
    
    def typeName() {
        this.typeName 
    }
    
    def mode() {
        this.mode
    }
    
    override def String toString() {
        switch mode {
            case "in":
                "  "+name+"("+typeName+");\n"
            case "out":
                "  "+name+"("+typeName+");\n"
            case "inout":
                "  "+name+"("+typeName+");\n"+
                "  "+name+"("+typeName+");\n"
        } 
    }
    
}


/*
 * A IOstsTransition
 * 
 * Note:
 * - fromState and toState are immutable and must be set at creation time.
 * - guard and assignments are optional, thus mutable.
 * - action is mutable thought it is required (tau by default):
 *   this is because it can be initialized after creation.
 *   Note: in the first transition, no sync is allowed.
 * - a comment helps to understand the transformation from SoDADL to IOSTS
 */
class IOstsTransition {
	val int fromState
	val int toState
	var boolean init
	String comment=""
	String guard = "" // optional
	String action = "unobservable" // default action is unobservable
	List<String> assignments = newArrayList // optional

	/* never used!
	new(int fromState, int toState, String action) {
		this.fromState = fromState
		this.toState = toState
		this.action = action
		this.init = false
	}
	*/

	new(int fromState, int toState) {
		this.fromState = fromState
		this.toState = toState
		this.init = false
	}

	def setInit(boolean init) {
		this.init = init
		if (init && guard.empty) {
			guard = "true" // default value for the init transition
		}
	}
	
	def fromState() {
		fromState
	}
	
	def toState() {
		toState
	}

	def setComment(String comment) {
		this.comment = comment
	}

	def setGuard(String guard) {
		this.guard = guard
	}

	def setAction(String action) {
		if (init) {
			System.err.println("Warning! Init transition does not admit action! Ignoring action...")
		} else {
			this.action = action
		}
	}

	def addAssignment(String statement) {
		if (init) {
			System.err.println("Warning! Init transition does not admit statement! Ignoring action...")
		} else {
			assignments.add(statement)
		}
		
	}

	override def String toString() {
		if (init) {
		'''
			from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
			    guard {
			    	«guard»
			    }
			to s«toState»
		'''
		} else {
		'''
			from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
			    «IF !guard.empty»
			    guard {
			    	«guard»
			    }
			    «ENDIF»
			  	action {
			  		«action»
			  	}
			  	«IF assignments.length > 0»
			  	assignments {
			  	    «assignments.join(",\n")»
			  	}
			  	«ENDIF»
			to s«toState»
		'''
		}
	}
}

/*
 * A IOstsProcess
 * 
 * Note:
 * - has an immutable name, which is required at creation time.
 * - connectionsMap: map of connexions declared for this specific process (protocol of gate or duty, behavior)
 * - inputMap, outputMap, and parametersMap are mutable maps of input, output of the Process.
 * - inoutputMap is a map that lives only during the translation from SoS-ADL to IOSTS
 *   because SOS-ADL has inout connections.
 * - parametersMap, and variablesMap are mutable maps containing parameters and variables of the process.
 * - transitions is the mutable list of the transitions.
 * - lastState is an int used internally to assign names to states.
 * - lastParameterNumber is an int used internally to assign names to parameters.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 */
class IOstsProcess{
    val String name
    var String comment=""
    var boolean first = true 
    public var LinkedHashMap<String,IOstsConnection> connectionsMap = newLinkedHashMap()  // map of (connection name -> Connection)
    public var inputMap = newLinkedHashMap()    // map of (in connection -> type name)
    public var outputMap = newLinkedHashMap()   // map of (out connection -> type name)
    public var inoutputMap = newLinkedHashMap() // map of (inout connection -> type name)
    public var parametersMap = newLinkedHashMap()  // map of (received variable -> type name)
    public var variablesMap = newLinkedHashMap()  // map of (variable -> type name) 
    public var List<IOstsTransition> transitions = newArrayList()
    var int lastState = 0 // number of the last state, starting at 0.
    var int lastParameterNumber = 0  // number of the last generated parameter

    new(String name) {
        this.name=name
    }
    
    def String name() {
        this.name
    }
    
    def setComment(String comment) {
        this.comment = comment
    }
    
    def addAllConnections(LinkedHashMap<String,IOstsConnection> connectionsMap) {
    	this.connectionsMap.putAll(connectionsMap)
    }
    
    /*
    def addConnection(IOstsConnection connection) {
        this.connectionsMap.put(connection.name, connection)
    }
    */
    
    def getConnection(String name) {
    	connectionsMap.get(name)
    }
    
    def addInput(String name, String typeName) {
        this.inputMap.put(name, typeName)
    }
    
    def addOutput(String name, String typeName) {
        this.outputMap.put(name, typeName)
    }
    
    def addInoutput(String name, String typeName) {
        this.inoutputMap.put(name, typeName)
    }
    
    def addParameter(String name, String typeName) {
        this.parametersMap.put(name, typeName)
    }
    
    def addVariable(String name, String typeName) {
        this.variablesMap.put(name, typeName)
    }
    
    def addVariable(String name) {
        addVariable(name, new IOstsIntType().toString)
    }
    
    /*
     * addTransition(transition):
     * - if a transition with same fromState and toState exists, then remove it from the transitions.
     * - adds transition to the list of transitions.
     * - updates lastState with fromState (resp. finalState) in case lastState < fromState (resp. finalState)
     */
    def addTransition(IOstsTransition transition) {
    	if (this.transitions.empty) {
    		transition.setInit(true)
    	}
    	if (this.transitions.exists[fromState() == transition.fromState() && toState() == transition.toState()]) {
    		val t = this.transitions.findFirst[fromState() == transition.fromState() && toState() == transition.toState()]
    		this.transitions.remove(t)
    	}
    	this.transitions.add(transition)	
    	if (this.lastState < transition.fromState()) {
    		this.lastState = transition.fromState()
    	}
    	if (this.lastState < transition.toState()) {
    		this.lastState = transition.toState()
    	}
    }
    
    def getTransition(int startState, int finalState) {
    	this.transitions.findFirst[fromState() == startState && toState() == finalState]
    }
    
    /*
     * Returns a new unused state id 
     */
    def int newState() {
        this.lastState = this.lastState+1
        this.lastState
    }
    
    def lastState() {
        this.lastState
    }
    
    /*
     * Returns a new unused parameter name
     */
    def newParameter() {
        this.lastParameterNumber = this.lastParameterNumber+1
        this.lastParameter()
    }
    
    def lastParameter() {
        this.name+"_p"+this.lastParameterNumber
    }
    
    /*
     * Returns the text of the IOSTS Process
     *
     * OLD version:
    override def String toString()'''
    process «name»;
    «IF !inputMap.empty»
    
    input  
      «inputMap.keySet.join(",\n")»;
    «ENDIF»
    «IF !outputMap.empty»
    
    output
      «outputMap.keySet.join(",\n")»;
    «ENDIF»
      
    internal
      tau;
    «IF !parametersMap.empty»
    
    parameters // stg says they have already been declared!
      «FOR p:parametersMap.keySet»
      //«p» : «parametersMap.get(p)»; 
      «ENDFOR»
    «ENDIF»
    «IF !variablesMap.empty»
    
    variables
      «FOR v:variablesMap.entrySet»
      «v.key» : «v.value»;
      «ENDFOR»
    «ENDIF»
    
    state
      init: s0;
      «FOR s:1..lastState»
      s«s»;
      «ENDFOR»  
    
    transition
    «FOR t:transitions»
    «t.toString»
    «ENDFOR»
    '''
    */
    
    override def String toString()'''
    {
    	«IF !parametersMap.empty»
    	messages {
    		«FOR p:parametersMap.keySet»
    		«p» is «parametersMap.get(p)» 
    		«ENDFOR»
    	}
    	«ENDIF»
    	«IF !variablesMap.empty»
    	variables {
    		«FOR v:variablesMap.entrySet»
    		«v.key» is «v.value»
    		«ENDFOR»
    	}
    	«ENDIF»
    	states {
    		init{s0}«FOR s:1..lastState» s«s»«ENDFOR»
    	}
    	transitions {
    		«FOR t:transitions»
    		«t.toString»
    		
    		«ENDFOR»
    	}
    }
    '''
}

/*
 * IOstsSystem
 * 
 * Notes:
 * - has an immutable name, which is required at creation time.
 * - fileName is the name of the file to be sqved.
 * - constantSection is not used at this time.
 * - typesMap is a mutable map containing the declaration of all types used in this system.
 * - connectionsMap is the mutable map of connections, declared inside local gate/duty
 * - processesMap is the map of processes of this system.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 */
class IOstsSystem{
    val String name
    var String fileName=""
    var String comment=""
    //OLD version: not needed anymore: var String behaviorName="UNDEFINED"
    public var LinkedHashMap<String,String> constantsMap = newLinkedHashMap()     // map of (name -> value as tring)
    public var LinkedHashMap<String,IOstsType> typesMap = newLinkedHashMap()     // map of (name -> iosts type)
    public var LinkedHashMap<String,IOstsProcess> processesMap = newLinkedHashMap()  // map of (process name -> Process)
    
    new(String name) {
       this.name=name
    }
    
    def setFileName(String fileName) {
       this.fileName = fileName
    }
    
    def fileName() {
        fileName
    }
    
    def setComment(String comment) {
       this.comment = comment
    }
    
    // Returns all connections known to this system.
    // These connections are declared in local gate/duty or behavior
    def LinkedHashMap<String,IOstsConnection> allConnections() {
    	var allConnections = newLinkedHashMap()
    	for (p : processesMap.entrySet) {
    		allConnections.putAll(p.value.connectionsMap)
    	}
    	allConnections
    }
    
    def getConnection(String name) {
    	val allConnections = allConnections()
    	allConnections.get(name)
    }
    
    def addProcess(IOstsProcess process) {
        // Sometimes, for example when "behavior{done}", the sts is empty.
        // In those cases, do not add the process, because it is invalid! 
        if (process.transitions.empty) {
            System.err.println("Warning! Process '"+process.name+"' is empty! Ignoring...")
        } else {
            /* OLD version: now, there is no need anymore to distinguish protocol process from behavior process.
            if (process.name.contains("_behavior")) {
                behaviorName=process.name
            }
            */
            this.processesMap.put(process.name, process)
        }
    }
    
    /*
     * empty returns true if no process has been generated.
     */
    def empty() {
        processesMap.empty
    }
    
    // OLD version: IOstsSystem.toString is never called.
    /*
    override def String toString() {
        // generate something only if there is at least one process
        if (empty) {
            System.err.println("Warning! System '"+name+"' defines no process! Ignoring...")
            ""
        } else {     
    '''
    / *
    Generated by org.archware.sosadl.generator.SosADL2IOSTSGenerator
    
    WARNING #1: The generator is a work in progress! This IOSTS file may not be complete!
    WARNING #2: The generator assumes the SoSADL source is correct.
                Otherwise, STG may not compile this IOSTS file. 

    Run it with:
      «IF processesMap.size == 1 && behaviorName != "UNDEFINED"»
        stg «fileName» -test_name «behaviorName»
      «ELSE»
        «FOR p:processesMap.values»
        «IF p.name.endsWith("_protocol")»
        stg «fileName» -test_name «behaviorName» -test_purpose_name «p.name»
        «ENDIF»
        «ENDFOR»
      «ENDIF»
    * /
    
    system «name»;
    «IF !constantsMap.empty»
    
    constant
      «FOR c:constantsMap.entrySet»
        «c.key» = «c.value»
      «ENDFOR»
    «ENDIF»
    «IF !typesMap.empty»
    
    type
      «FOR t:typesMap.entrySet»
        «val tk = t.key»
        «val tv = t.value»
        «IF tv.toString == "int"»
          // «tk» = int;
        «ELSE»
          «tk» = «tv»;
        «ENDIF»
      «ENDFOR»
    «ENDIF»
    
    gate
    «FOR g:connectionsMap.values»
    «g.toString»
    «ENDFOR»
    «FOR p:processesMap.values»
    
    //--------------------------------------------------
    «p.toString»
    «ENDFOR»
    '''}
    }
    */
}
