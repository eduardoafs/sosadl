with Base
with Localization

with WsnSensor
with WsnGateway
with WsnMediator

// Description of WsnMonitoring as an Architecture Abstraction
sos WsnMonitoringSos is {
  architecture WnsMonitoringSosArchitecture() is {
  
    gate warning is {
      connection alert is out{MeasureData}  // alert sent to its environment
    } guarantee {
      protocol alertpact is {
        repeat {
          repeat {anyaction}
          repeat {via warning::alert send any}
        }
      }
    }
    
    gate request is {
      connection coordinate is in{Coordinate}
      connection depth is out{Depth}
    } guarantee {
      protocol requestpact is {
        repeat {  // in the case of one statement '{' '}' are not needed
          via request::coordinate receive any
          repeat {anyaction}
          via request::depth send any
        }
      }
    }
    
    behavior coalition() is compose {
        sensors is sequence{Sensor}
  	    gateway is Gateway
        transmitters is sequence{Transmitter}
    } binding {
        relay warning::alert to gateway::notification::alert
        and relay request::coordinate to gateway::request::coordinate
        and relay request::depth to gateway::request::depth
        and forall{itransmitter in transmitters, isensor1 in sensors, isensor2 in sensors, igateway in gateway suchthat
          (isensor1 <> isensor2) implies (
            // multiplicities are 'one', 'none', 'lone' (none or one), 'any' (none or more), 'some' (one or more), 'all'
            unify one{itransmitter::fromSensors} to one{isensor1::measurement::measure} 
            and unify one{itransmitter::toGateway} to one{isensor2::measurement::pass}
              xor unify one{itransmitter::toGateway} to one{igateway::notification::measure}
            )
        }
/* The binding using 1st order logic (using Alloy quantifiers):
     - all = forall
     - one = exists unique

    relay warning::alert to gateway::notification::alert
    and relay request::coordinate to gateway::request::coordinate
    and relay request::depth to gateway::request::depth
    all{s1 in sensors
      suchthat one{t in transmitters
                 suchthat all{s2 in sensors suchthat unify t::fromSensors to s2::measurement::measure implies s1=s2}
                      and unify t::fromSensors to s1::measurement::measure
	              and (unify t::toGateway to gateway::notification::measure
	                   xor one{s2 in sensors
                                 suchthat s1<>s2
                                      and unify t::toGateway to s2::measurement::pass})}


   Alternative 1st order logic:

    all{s in sensors suchthat one{t in transmitters suchthat unify t::fromSensors to s::measurement::measure}}
and all{t in transmitters suchthat one{s in sensors suchthat unify t::fromSensors to s::measurement::measure}}
and all{t in transmitters suchthat (one{s in sensors suchthat unify t::toGateway to s::measurement::pass} xor unify t::toGateway to gateway::notification::measure)}



   Attempt with multiplicities:

    unify one{sensors::measurement::measure} to one{transmitters::fromSensors}
    and unify all{transmitters::toGateway} to (one{sensors::measurement::pass} xor {gateway::notification::measure})
*/
    }
  } guarantee {
    property alerting is {
      always {via notification::alert send any}
    }
  }
}
